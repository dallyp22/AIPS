
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Plant
 * 
 */
export type Plant = $Result.DefaultSelection<Prisma.$PlantPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Workcenter
 * 
 */
export type Workcenter = $Result.DefaultSelection<Prisma.$WorkcenterPayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model SKU
 * 
 */
export type SKU = $Result.DefaultSelection<Prisma.$SKUPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model ScheduleBlock
 * 
 */
export type ScheduleBlock = $Result.DefaultSelection<Prisma.$ScheduleBlockPayload>
/**
 * Model Changeover
 * 
 */
export type Changeover = $Result.DefaultSelection<Prisma.$ChangeoverPayload>
/**
 * Model Operator
 * 
 */
export type Operator = $Result.DefaultSelection<Prisma.$OperatorPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model OperatorCompetency
 * 
 */
export type OperatorCompetency = $Result.DefaultSelection<Prisma.$OperatorCompetencyPayload>
/**
 * Model SkillRequirement
 * 
 */
export type SkillRequirement = $Result.DefaultSelection<Prisma.$SkillRequirementPayload>
/**
 * Model ShiftPattern
 * 
 */
export type ShiftPattern = $Result.DefaultSelection<Prisma.$ShiftPatternPayload>
/**
 * Model ShiftAssignment
 * 
 */
export type ShiftAssignment = $Result.DefaultSelection<Prisma.$ShiftAssignmentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Plants
 * const plants = await prisma.plant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Plants
   * const plants = await prisma.plant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.plant`: Exposes CRUD operations for the **Plant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plants
    * const plants = await prisma.plant.findMany()
    * ```
    */
  get plant(): Prisma.PlantDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.workcenter`: Exposes CRUD operations for the **Workcenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workcenters
    * const workcenters = await prisma.workcenter.findMany()
    * ```
    */
  get workcenter(): Prisma.WorkcenterDelegate<ExtArgs>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs>;

  /**
   * `prisma.sKU`: Exposes CRUD operations for the **SKU** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SKUS
    * const sKUS = await prisma.sKU.findMany()
    * ```
    */
  get sKU(): Prisma.SKUDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.scheduleBlock`: Exposes CRUD operations for the **ScheduleBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleBlocks
    * const scheduleBlocks = await prisma.scheduleBlock.findMany()
    * ```
    */
  get scheduleBlock(): Prisma.ScheduleBlockDelegate<ExtArgs>;

  /**
   * `prisma.changeover`: Exposes CRUD operations for the **Changeover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Changeovers
    * const changeovers = await prisma.changeover.findMany()
    * ```
    */
  get changeover(): Prisma.ChangeoverDelegate<ExtArgs>;

  /**
   * `prisma.operator`: Exposes CRUD operations for the **Operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operator.findMany()
    * ```
    */
  get operator(): Prisma.OperatorDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.operatorCompetency`: Exposes CRUD operations for the **OperatorCompetency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperatorCompetencies
    * const operatorCompetencies = await prisma.operatorCompetency.findMany()
    * ```
    */
  get operatorCompetency(): Prisma.OperatorCompetencyDelegate<ExtArgs>;

  /**
   * `prisma.skillRequirement`: Exposes CRUD operations for the **SkillRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillRequirements
    * const skillRequirements = await prisma.skillRequirement.findMany()
    * ```
    */
  get skillRequirement(): Prisma.SkillRequirementDelegate<ExtArgs>;

  /**
   * `prisma.shiftPattern`: Exposes CRUD operations for the **ShiftPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftPatterns
    * const shiftPatterns = await prisma.shiftPattern.findMany()
    * ```
    */
  get shiftPattern(): Prisma.ShiftPatternDelegate<ExtArgs>;

  /**
   * `prisma.shiftAssignment`: Exposes CRUD operations for the **ShiftAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftAssignments
    * const shiftAssignments = await prisma.shiftAssignment.findMany()
    * ```
    */
  get shiftAssignment(): Prisma.ShiftAssignmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Plant: 'Plant',
    Department: 'Department',
    Workcenter: 'Workcenter',
    Holiday: 'Holiday',
    SKU: 'SKU',
    Product: 'Product',
    Order: 'Order',
    ScheduleBlock: 'ScheduleBlock',
    Changeover: 'Changeover',
    Operator: 'Operator',
    Skill: 'Skill',
    OperatorCompetency: 'OperatorCompetency',
    SkillRequirement: 'SkillRequirement',
    ShiftPattern: 'ShiftPattern',
    ShiftAssignment: 'ShiftAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "plant" | "department" | "workcenter" | "holiday" | "sKU" | "product" | "order" | "scheduleBlock" | "changeover" | "operator" | "skill" | "operatorCompetency" | "skillRequirement" | "shiftPattern" | "shiftAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Plant: {
        payload: Prisma.$PlantPayload<ExtArgs>
        fields: Prisma.PlantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findFirst: {
            args: Prisma.PlantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          findMany: {
            args: Prisma.PlantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          create: {
            args: Prisma.PlantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          createMany: {
            args: Prisma.PlantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>[]
          }
          delete: {
            args: Prisma.PlantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          update: {
            args: Prisma.PlantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          deleteMany: {
            args: Prisma.PlantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantPayload>
          }
          aggregate: {
            args: Prisma.PlantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlant>
          }
          groupBy: {
            args: Prisma.PlantGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantCountArgs<ExtArgs>
            result: $Utils.Optional<PlantCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Workcenter: {
        payload: Prisma.$WorkcenterPayload<ExtArgs>
        fields: Prisma.WorkcenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkcenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkcenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          findFirst: {
            args: Prisma.WorkcenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkcenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          findMany: {
            args: Prisma.WorkcenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>[]
          }
          create: {
            args: Prisma.WorkcenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          createMany: {
            args: Prisma.WorkcenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkcenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>[]
          }
          delete: {
            args: Prisma.WorkcenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          update: {
            args: Prisma.WorkcenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          deleteMany: {
            args: Prisma.WorkcenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkcenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkcenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkcenterPayload>
          }
          aggregate: {
            args: Prisma.WorkcenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkcenter>
          }
          groupBy: {
            args: Prisma.WorkcenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkcenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkcenterCountArgs<ExtArgs>
            result: $Utils.Optional<WorkcenterCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolidayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      SKU: {
        payload: Prisma.$SKUPayload<ExtArgs>
        fields: Prisma.SKUFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SKUFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SKUFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          findFirst: {
            args: Prisma.SKUFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SKUFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          findMany: {
            args: Prisma.SKUFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>[]
          }
          create: {
            args: Prisma.SKUCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          createMany: {
            args: Prisma.SKUCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SKUCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>[]
          }
          delete: {
            args: Prisma.SKUDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          update: {
            args: Prisma.SKUUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          deleteMany: {
            args: Prisma.SKUDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SKUUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SKUUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SKUPayload>
          }
          aggregate: {
            args: Prisma.SKUAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSKU>
          }
          groupBy: {
            args: Prisma.SKUGroupByArgs<ExtArgs>
            result: $Utils.Optional<SKUGroupByOutputType>[]
          }
          count: {
            args: Prisma.SKUCountArgs<ExtArgs>
            result: $Utils.Optional<SKUCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      ScheduleBlock: {
        payload: Prisma.$ScheduleBlockPayload<ExtArgs>
        fields: Prisma.ScheduleBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          findFirst: {
            args: Prisma.ScheduleBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          findMany: {
            args: Prisma.ScheduleBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>[]
          }
          create: {
            args: Prisma.ScheduleBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          createMany: {
            args: Prisma.ScheduleBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>[]
          }
          delete: {
            args: Prisma.ScheduleBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          update: {
            args: Prisma.ScheduleBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleBlockPayload>
          }
          aggregate: {
            args: Prisma.ScheduleBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleBlock>
          }
          groupBy: {
            args: Prisma.ScheduleBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleBlockCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleBlockCountAggregateOutputType> | number
          }
        }
      }
      Changeover: {
        payload: Prisma.$ChangeoverPayload<ExtArgs>
        fields: Prisma.ChangeoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          findFirst: {
            args: Prisma.ChangeoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          findMany: {
            args: Prisma.ChangeoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>[]
          }
          create: {
            args: Prisma.ChangeoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          createMany: {
            args: Prisma.ChangeoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>[]
          }
          delete: {
            args: Prisma.ChangeoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          update: {
            args: Prisma.ChangeoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          deleteMany: {
            args: Prisma.ChangeoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChangeoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeoverPayload>
          }
          aggregate: {
            args: Prisma.ChangeoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeover>
          }
          groupBy: {
            args: Prisma.ChangeoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeoverCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeoverCountAggregateOutputType> | number
          }
        }
      }
      Operator: {
        payload: Prisma.$OperatorPayload<ExtArgs>
        fields: Prisma.OperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findFirst: {
            args: Prisma.OperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findMany: {
            args: Prisma.OperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          create: {
            args: Prisma.OperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          createMany: {
            args: Prisma.OperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          delete: {
            args: Prisma.OperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          update: {
            args: Prisma.OperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          deleteMany: {
            args: Prisma.OperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          aggregate: {
            args: Prisma.OperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator>
          }
          groupBy: {
            args: Prisma.OperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      OperatorCompetency: {
        payload: Prisma.$OperatorCompetencyPayload<ExtArgs>
        fields: Prisma.OperatorCompetencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorCompetencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorCompetencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          findFirst: {
            args: Prisma.OperatorCompetencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorCompetencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          findMany: {
            args: Prisma.OperatorCompetencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>[]
          }
          create: {
            args: Prisma.OperatorCompetencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          createMany: {
            args: Prisma.OperatorCompetencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorCompetencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>[]
          }
          delete: {
            args: Prisma.OperatorCompetencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          update: {
            args: Prisma.OperatorCompetencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          deleteMany: {
            args: Prisma.OperatorCompetencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorCompetencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperatorCompetencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorCompetencyPayload>
          }
          aggregate: {
            args: Prisma.OperatorCompetencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatorCompetency>
          }
          groupBy: {
            args: Prisma.OperatorCompetencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorCompetencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorCompetencyCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCompetencyCountAggregateOutputType> | number
          }
        }
      }
      SkillRequirement: {
        payload: Prisma.$SkillRequirementPayload<ExtArgs>
        fields: Prisma.SkillRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          findFirst: {
            args: Prisma.SkillRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          findMany: {
            args: Prisma.SkillRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>[]
          }
          create: {
            args: Prisma.SkillRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          createMany: {
            args: Prisma.SkillRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillRequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>[]
          }
          delete: {
            args: Prisma.SkillRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          update: {
            args: Prisma.SkillRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          deleteMany: {
            args: Prisma.SkillRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillRequirementPayload>
          }
          aggregate: {
            args: Prisma.SkillRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillRequirement>
          }
          groupBy: {
            args: Prisma.SkillRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<SkillRequirementCountAggregateOutputType> | number
          }
        }
      }
      ShiftPattern: {
        payload: Prisma.$ShiftPatternPayload<ExtArgs>
        fields: Prisma.ShiftPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          findFirst: {
            args: Prisma.ShiftPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          findMany: {
            args: Prisma.ShiftPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>[]
          }
          create: {
            args: Prisma.ShiftPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          createMany: {
            args: Prisma.ShiftPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>[]
          }
          delete: {
            args: Prisma.ShiftPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          update: {
            args: Prisma.ShiftPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          deleteMany: {
            args: Prisma.ShiftPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPatternPayload>
          }
          aggregate: {
            args: Prisma.ShiftPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftPattern>
          }
          groupBy: {
            args: Prisma.ShiftPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftPatternCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftPatternCountAggregateOutputType> | number
          }
        }
      }
      ShiftAssignment: {
        payload: Prisma.$ShiftAssignmentPayload<ExtArgs>
        fields: Prisma.ShiftAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ShiftAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          findMany: {
            args: Prisma.ShiftAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>[]
          }
          create: {
            args: Prisma.ShiftAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          createMany: {
            args: Prisma.ShiftAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ShiftAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          update: {
            args: Prisma.ShiftAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ShiftAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ShiftAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftAssignment>
          }
          groupBy: {
            args: Prisma.ShiftAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlantCountOutputType
   */

  export type PlantCountOutputType = {
    departments: number
    holidays: number
    workcenters: number
  }

  export type PlantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | PlantCountOutputTypeCountDepartmentsArgs
    holidays?: boolean | PlantCountOutputTypeCountHolidaysArgs
    workcenters?: boolean | PlantCountOutputTypeCountWorkcentersArgs
  }

  // Custom InputTypes
  /**
   * PlantCountOutputType without action
   */
  export type PlantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantCountOutputType
     */
    select?: PlantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlantCountOutputType without action
   */
  export type PlantCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * PlantCountOutputType without action
   */
  export type PlantCountOutputTypeCountHolidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
  }

  /**
   * PlantCountOutputType without action
   */
  export type PlantCountOutputTypeCountWorkcentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkcenterWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    operators: number
    workcenters: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operators?: boolean | DepartmentCountOutputTypeCountOperatorsArgs
    workcenters?: boolean | DepartmentCountOutputTypeCountWorkcentersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountOperatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountWorkcentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkcenterWhereInput
  }


  /**
   * Count Type WorkcenterCountOutputType
   */

  export type WorkcenterCountOutputType = {
    changeovers: number
    orders: number
    scheduleBlocks: number
    shiftAssignments: number
    skillRequirements: number
  }

  export type WorkcenterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeovers?: boolean | WorkcenterCountOutputTypeCountChangeoversArgs
    orders?: boolean | WorkcenterCountOutputTypeCountOrdersArgs
    scheduleBlocks?: boolean | WorkcenterCountOutputTypeCountScheduleBlocksArgs
    shiftAssignments?: boolean | WorkcenterCountOutputTypeCountShiftAssignmentsArgs
    skillRequirements?: boolean | WorkcenterCountOutputTypeCountSkillRequirementsArgs
  }

  // Custom InputTypes
  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkcenterCountOutputType
     */
    select?: WorkcenterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeCountChangeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeoverWhereInput
  }

  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeCountScheduleBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleBlockWhereInput
  }

  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeCountShiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }

  /**
   * WorkcenterCountOutputType without action
   */
  export type WorkcenterCountOutputTypeCountSkillRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillRequirementWhereInput
  }


  /**
   * Count Type SKUCountOutputType
   */

  export type SKUCountOutputType = {
    orders: number
    products: number
  }

  export type SKUCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | SKUCountOutputTypeCountOrdersArgs
    products?: boolean | SKUCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SKUCountOutputType without action
   */
  export type SKUCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKUCountOutputType
     */
    select?: SKUCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SKUCountOutputType without action
   */
  export type SKUCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * SKUCountOutputType without action
   */
  export type SKUCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    scheduleBlocks: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduleBlocks?: boolean | OrderCountOutputTypeCountScheduleBlocksArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountScheduleBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleBlockWhereInput
  }


  /**
   * Count Type ScheduleBlockCountOutputType
   */

  export type ScheduleBlockCountOutputType = {
    toChangeovers: number
    fromChangeovers: number
  }

  export type ScheduleBlockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toChangeovers?: boolean | ScheduleBlockCountOutputTypeCountToChangeoversArgs
    fromChangeovers?: boolean | ScheduleBlockCountOutputTypeCountFromChangeoversArgs
  }

  // Custom InputTypes
  /**
   * ScheduleBlockCountOutputType without action
   */
  export type ScheduleBlockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlockCountOutputType
     */
    select?: ScheduleBlockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleBlockCountOutputType without action
   */
  export type ScheduleBlockCountOutputTypeCountToChangeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeoverWhereInput
  }

  /**
   * ScheduleBlockCountOutputType without action
   */
  export type ScheduleBlockCountOutputTypeCountFromChangeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeoverWhereInput
  }


  /**
   * Count Type OperatorCountOutputType
   */

  export type OperatorCountOutputType = {
    competencies: number
    shiftAssignments: number
  }

  export type OperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competencies?: boolean | OperatorCountOutputTypeCountCompetenciesArgs
    shiftAssignments?: boolean | OperatorCountOutputTypeCountShiftAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCountOutputType
     */
    select?: OperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountCompetenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorCompetencyWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountShiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    competencies: number
    skillRequirements: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competencies?: boolean | SkillCountOutputTypeCountCompetenciesArgs
    skillRequirements?: boolean | SkillCountOutputTypeCountSkillRequirementsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountCompetenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorCompetencyWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountSkillRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillRequirementWhereInput
  }


  /**
   * Count Type ShiftPatternCountOutputType
   */

  export type ShiftPatternCountOutputType = {
    shiftAssignments: number
  }

  export type ShiftPatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftAssignments?: boolean | ShiftPatternCountOutputTypeCountShiftAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ShiftPatternCountOutputType without action
   */
  export type ShiftPatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPatternCountOutputType
     */
    select?: ShiftPatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftPatternCountOutputType without action
   */
  export type ShiftPatternCountOutputTypeCountShiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Plant
   */

  export type AggregatePlant = {
    _count: PlantCountAggregateOutputType | null
    _avg: PlantAvgAggregateOutputType | null
    _sum: PlantSumAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  export type PlantAvgAggregateOutputType = {
    id: number | null
  }

  export type PlantSumAggregateOutputType = {
    id: number | null
  }

  export type PlantMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PlantMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PlantCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PlantAvgAggregateInputType = {
    id?: true
  }

  export type PlantSumAggregateInputType = {
    id?: true
  }

  export type PlantMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PlantMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PlantCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PlantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plant to aggregate.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plants
    **/
    _count?: true | PlantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantMaxAggregateInputType
  }

  export type GetPlantAggregateType<T extends PlantAggregateArgs> = {
        [P in keyof T & keyof AggregatePlant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlant[P]>
      : GetScalarType<T[P], AggregatePlant[P]>
  }




  export type PlantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantWhereInput
    orderBy?: PlantOrderByWithAggregationInput | PlantOrderByWithAggregationInput[]
    by: PlantScalarFieldEnum[] | PlantScalarFieldEnum
    having?: PlantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantCountAggregateInputType | true
    _avg?: PlantAvgAggregateInputType
    _sum?: PlantSumAggregateInputType
    _min?: PlantMinAggregateInputType
    _max?: PlantMaxAggregateInputType
  }

  export type PlantGroupByOutputType = {
    id: number
    name: string
    _count: PlantCountAggregateOutputType | null
    _avg: PlantAvgAggregateOutputType | null
    _sum: PlantSumAggregateOutputType | null
    _min: PlantMinAggregateOutputType | null
    _max: PlantMaxAggregateOutputType | null
  }

  type GetPlantGroupByPayload<T extends PlantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantGroupByOutputType[P]>
            : GetScalarType<T[P], PlantGroupByOutputType[P]>
        }
      >
    >


  export type PlantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departments?: boolean | Plant$departmentsArgs<ExtArgs>
    holidays?: boolean | Plant$holidaysArgs<ExtArgs>
    workcenters?: boolean | Plant$workcentersArgs<ExtArgs>
    _count?: boolean | PlantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["plant"]>

  export type PlantSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PlantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Plant$departmentsArgs<ExtArgs>
    holidays?: boolean | Plant$holidaysArgs<ExtArgs>
    workcenters?: boolean | Plant$workcentersArgs<ExtArgs>
    _count?: boolean | PlantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plant"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      holidays: Prisma.$HolidayPayload<ExtArgs>[]
      workcenters: Prisma.$WorkcenterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["plant"]>
    composites: {}
  }

  type PlantGetPayload<S extends boolean | null | undefined | PlantDefaultArgs> = $Result.GetResult<Prisma.$PlantPayload, S>

  type PlantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlantCountAggregateInputType | true
    }

  export interface PlantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plant'], meta: { name: 'Plant' } }
    /**
     * Find zero or one Plant that matches the filter.
     * @param {PlantFindUniqueArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantFindUniqueArgs>(args: SelectSubset<T, PlantFindUniqueArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlantFindUniqueOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantFindFirstArgs>(args?: SelectSubset<T, PlantFindFirstArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindFirstOrThrowArgs} args - Arguments to find a Plant
     * @example
     * // Get one Plant
     * const plant = await prisma.plant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plants
     * const plants = await prisma.plant.findMany()
     * 
     * // Get first 10 Plants
     * const plants = await prisma.plant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantWithIdOnly = await prisma.plant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantFindManyArgs>(args?: SelectSubset<T, PlantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plant.
     * @param {PlantCreateArgs} args - Arguments to create a Plant.
     * @example
     * // Create one Plant
     * const Plant = await prisma.plant.create({
     *   data: {
     *     // ... data to create a Plant
     *   }
     * })
     * 
     */
    create<T extends PlantCreateArgs>(args: SelectSubset<T, PlantCreateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plants.
     * @param {PlantCreateManyArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantCreateManyArgs>(args?: SelectSubset<T, PlantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plants and returns the data saved in the database.
     * @param {PlantCreateManyAndReturnArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plant = await prisma.plant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plants and only return the `id`
     * const plantWithIdOnly = await prisma.plant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Plant.
     * @param {PlantDeleteArgs} args - Arguments to delete one Plant.
     * @example
     * // Delete one Plant
     * const Plant = await prisma.plant.delete({
     *   where: {
     *     // ... filter to delete one Plant
     *   }
     * })
     * 
     */
    delete<T extends PlantDeleteArgs>(args: SelectSubset<T, PlantDeleteArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plant.
     * @param {PlantUpdateArgs} args - Arguments to update one Plant.
     * @example
     * // Update one Plant
     * const plant = await prisma.plant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantUpdateArgs>(args: SelectSubset<T, PlantUpdateArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plants.
     * @param {PlantDeleteManyArgs} args - Arguments to filter Plants to delete.
     * @example
     * // Delete a few Plants
     * const { count } = await prisma.plant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantDeleteManyArgs>(args?: SelectSubset<T, PlantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plants
     * const plant = await prisma.plant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantUpdateManyArgs>(args: SelectSubset<T, PlantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plant.
     * @param {PlantUpsertArgs} args - Arguments to update or create a Plant.
     * @example
     * // Update or create a Plant
     * const plant = await prisma.plant.upsert({
     *   create: {
     *     // ... data to create a Plant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plant we want to update
     *   }
     * })
     */
    upsert<T extends PlantUpsertArgs>(args: SelectSubset<T, PlantUpsertArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantCountArgs} args - Arguments to filter Plants to count.
     * @example
     * // Count the number of Plants
     * const count = await prisma.plant.count({
     *   where: {
     *     // ... the filter for the Plants we want to count
     *   }
     * })
    **/
    count<T extends PlantCountArgs>(
      args?: Subset<T, PlantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantAggregateArgs>(args: Subset<T, PlantAggregateArgs>): Prisma.PrismaPromise<GetPlantAggregateType<T>>

    /**
     * Group by Plant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantGroupByArgs['orderBy'] }
        : { orderBy?: PlantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plant model
   */
  readonly fields: PlantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Plant$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Plant$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    holidays<T extends Plant$holidaysArgs<ExtArgs> = {}>(args?: Subset<T, Plant$holidaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany"> | Null>
    workcenters<T extends Plant$workcentersArgs<ExtArgs> = {}>(args?: Subset<T, Plant$workcentersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plant model
   */ 
  interface PlantFieldRefs {
    readonly id: FieldRef<"Plant", 'Int'>
    readonly name: FieldRef<"Plant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Plant findUnique
   */
  export type PlantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findUniqueOrThrow
   */
  export type PlantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant findFirst
   */
  export type PlantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findFirstOrThrow
   */
  export type PlantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plant to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plants.
     */
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant findMany
   */
  export type PlantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter, which Plants to fetch.
     */
    where?: PlantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plants to fetch.
     */
    orderBy?: PlantOrderByWithRelationInput | PlantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plants.
     */
    cursor?: PlantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plants.
     */
    skip?: number
    distinct?: PlantScalarFieldEnum | PlantScalarFieldEnum[]
  }

  /**
   * Plant create
   */
  export type PlantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to create a Plant.
     */
    data: XOR<PlantCreateInput, PlantUncheckedCreateInput>
  }

  /**
   * Plant createMany
   */
  export type PlantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
  }

  /**
   * Plant createManyAndReturn
   */
  export type PlantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Plants.
     */
    data: PlantCreateManyInput | PlantCreateManyInput[]
  }

  /**
   * Plant update
   */
  export type PlantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The data needed to update a Plant.
     */
    data: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
    /**
     * Choose, which Plant to update.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant updateMany
   */
  export type PlantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plants.
     */
    data: XOR<PlantUpdateManyMutationInput, PlantUncheckedUpdateManyInput>
    /**
     * Filter which Plants to update
     */
    where?: PlantWhereInput
  }

  /**
   * Plant upsert
   */
  export type PlantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * The filter to search for the Plant to update in case it exists.
     */
    where: PlantWhereUniqueInput
    /**
     * In case the Plant found by the `where` argument doesn't exist, create a new Plant with this data.
     */
    create: XOR<PlantCreateInput, PlantUncheckedCreateInput>
    /**
     * In case the Plant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantUpdateInput, PlantUncheckedUpdateInput>
  }

  /**
   * Plant delete
   */
  export type PlantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
    /**
     * Filter which Plant to delete.
     */
    where: PlantWhereUniqueInput
  }

  /**
   * Plant deleteMany
   */
  export type PlantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plants to delete
     */
    where?: PlantWhereInput
  }

  /**
   * Plant.departments
   */
  export type Plant$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Plant.holidays
   */
  export type Plant$holidaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    cursor?: HolidayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Plant.workcenters
   */
  export type Plant$workcentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    where?: WorkcenterWhereInput
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    cursor?: WorkcenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkcenterScalarFieldEnum | WorkcenterScalarFieldEnum[]
  }

  /**
   * Plant without action
   */
  export type PlantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plant
     */
    select?: PlantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlantInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    name: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    name: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    plantId: number
    name: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    plantId?: true
    name?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    plantId?: true
    name?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    plantId?: true
    name?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    plantId: number
    name: string
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    name?: boolean
    plant?: boolean | PlantDefaultArgs<ExtArgs>
    operators?: boolean | Department$operatorsArgs<ExtArgs>
    workcenters?: boolean | Department$workcentersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    name?: boolean
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    plantId?: boolean
    name?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantDefaultArgs<ExtArgs>
    operators?: boolean | Department$operatorsArgs<ExtArgs>
    workcenters?: boolean | Department$workcentersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      plant: Prisma.$PlantPayload<ExtArgs>
      operators: Prisma.$OperatorPayload<ExtArgs>[]
      workcenters: Prisma.$WorkcenterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      name: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantDefaultArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    operators<T extends Department$operatorsArgs<ExtArgs> = {}>(args?: Subset<T, Department$operatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany"> | Null>
    workcenters<T extends Department$workcentersArgs<ExtArgs> = {}>(args?: Subset<T, Department$workcentersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly plantId: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.operators
   */
  export type Department$operatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    cursor?: OperatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Department.workcenters
   */
  export type Department$workcentersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    where?: WorkcenterWhereInput
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    cursor?: WorkcenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkcenterScalarFieldEnum | WorkcenterScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Workcenter
   */

  export type AggregateWorkcenter = {
    _count: WorkcenterCountAggregateOutputType | null
    _avg: WorkcenterAvgAggregateOutputType | null
    _sum: WorkcenterSumAggregateOutputType | null
    _min: WorkcenterMinAggregateOutputType | null
    _max: WorkcenterMaxAggregateOutputType | null
  }

  export type WorkcenterAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
    departmentId: number | null
    defaultSchemeId: number | null
    minStaff: number | null
  }

  export type WorkcenterSumAggregateOutputType = {
    id: number | null
    plantId: number | null
    departmentId: number | null
    defaultSchemeId: number | null
    minStaff: number | null
  }

  export type WorkcenterMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    departmentId: number | null
    workcenterNo: string | null
    name: string | null
    displayTitle: string | null
    defaultSchemeId: number | null
    minStaff: number | null
    gatingRules: string | null
    changeoverFamily: string | null
  }

  export type WorkcenterMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    departmentId: number | null
    workcenterNo: string | null
    name: string | null
    displayTitle: string | null
    defaultSchemeId: number | null
    minStaff: number | null
    gatingRules: string | null
    changeoverFamily: string | null
  }

  export type WorkcenterCountAggregateOutputType = {
    id: number
    plantId: number
    departmentId: number
    workcenterNo: number
    name: number
    displayTitle: number
    defaultSchemeId: number
    minStaff: number
    gatingRules: number
    changeoverFamily: number
    _all: number
  }


  export type WorkcenterAvgAggregateInputType = {
    id?: true
    plantId?: true
    departmentId?: true
    defaultSchemeId?: true
    minStaff?: true
  }

  export type WorkcenterSumAggregateInputType = {
    id?: true
    plantId?: true
    departmentId?: true
    defaultSchemeId?: true
    minStaff?: true
  }

  export type WorkcenterMinAggregateInputType = {
    id?: true
    plantId?: true
    departmentId?: true
    workcenterNo?: true
    name?: true
    displayTitle?: true
    defaultSchemeId?: true
    minStaff?: true
    gatingRules?: true
    changeoverFamily?: true
  }

  export type WorkcenterMaxAggregateInputType = {
    id?: true
    plantId?: true
    departmentId?: true
    workcenterNo?: true
    name?: true
    displayTitle?: true
    defaultSchemeId?: true
    minStaff?: true
    gatingRules?: true
    changeoverFamily?: true
  }

  export type WorkcenterCountAggregateInputType = {
    id?: true
    plantId?: true
    departmentId?: true
    workcenterNo?: true
    name?: true
    displayTitle?: true
    defaultSchemeId?: true
    minStaff?: true
    gatingRules?: true
    changeoverFamily?: true
    _all?: true
  }

  export type WorkcenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workcenter to aggregate.
     */
    where?: WorkcenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workcenters to fetch.
     */
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkcenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workcenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workcenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workcenters
    **/
    _count?: true | WorkcenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkcenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkcenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkcenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkcenterMaxAggregateInputType
  }

  export type GetWorkcenterAggregateType<T extends WorkcenterAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkcenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkcenter[P]>
      : GetScalarType<T[P], AggregateWorkcenter[P]>
  }




  export type WorkcenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkcenterWhereInput
    orderBy?: WorkcenterOrderByWithAggregationInput | WorkcenterOrderByWithAggregationInput[]
    by: WorkcenterScalarFieldEnum[] | WorkcenterScalarFieldEnum
    having?: WorkcenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkcenterCountAggregateInputType | true
    _avg?: WorkcenterAvgAggregateInputType
    _sum?: WorkcenterSumAggregateInputType
    _min?: WorkcenterMinAggregateInputType
    _max?: WorkcenterMaxAggregateInputType
  }

  export type WorkcenterGroupByOutputType = {
    id: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle: string | null
    defaultSchemeId: number | null
    minStaff: number
    gatingRules: string | null
    changeoverFamily: string | null
    _count: WorkcenterCountAggregateOutputType | null
    _avg: WorkcenterAvgAggregateOutputType | null
    _sum: WorkcenterSumAggregateOutputType | null
    _min: WorkcenterMinAggregateOutputType | null
    _max: WorkcenterMaxAggregateOutputType | null
  }

  type GetWorkcenterGroupByPayload<T extends WorkcenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkcenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkcenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkcenterGroupByOutputType[P]>
            : GetScalarType<T[P], WorkcenterGroupByOutputType[P]>
        }
      >
    >


  export type WorkcenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    departmentId?: boolean
    workcenterNo?: boolean
    name?: boolean
    displayTitle?: boolean
    defaultSchemeId?: boolean
    minStaff?: boolean
    gatingRules?: boolean
    changeoverFamily?: boolean
    changeovers?: boolean | Workcenter$changeoversArgs<ExtArgs>
    orders?: boolean | Workcenter$ordersArgs<ExtArgs>
    scheduleBlocks?: boolean | Workcenter$scheduleBlocksArgs<ExtArgs>
    shiftAssignments?: boolean | Workcenter$shiftAssignmentsArgs<ExtArgs>
    skillRequirements?: boolean | Workcenter$skillRequirementsArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    plant?: boolean | PlantDefaultArgs<ExtArgs>
    _count?: boolean | WorkcenterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workcenter"]>

  export type WorkcenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    departmentId?: boolean
    workcenterNo?: boolean
    name?: boolean
    displayTitle?: boolean
    defaultSchemeId?: boolean
    minStaff?: boolean
    gatingRules?: boolean
    changeoverFamily?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workcenter"]>

  export type WorkcenterSelectScalar = {
    id?: boolean
    plantId?: boolean
    departmentId?: boolean
    workcenterNo?: boolean
    name?: boolean
    displayTitle?: boolean
    defaultSchemeId?: boolean
    minStaff?: boolean
    gatingRules?: boolean
    changeoverFamily?: boolean
  }

  export type WorkcenterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeovers?: boolean | Workcenter$changeoversArgs<ExtArgs>
    orders?: boolean | Workcenter$ordersArgs<ExtArgs>
    scheduleBlocks?: boolean | Workcenter$scheduleBlocksArgs<ExtArgs>
    shiftAssignments?: boolean | Workcenter$shiftAssignmentsArgs<ExtArgs>
    skillRequirements?: boolean | Workcenter$skillRequirementsArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    plant?: boolean | PlantDefaultArgs<ExtArgs>
    _count?: boolean | WorkcenterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkcenterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }

  export type $WorkcenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workcenter"
    objects: {
      changeovers: Prisma.$ChangeoverPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      scheduleBlocks: Prisma.$ScheduleBlockPayload<ExtArgs>[]
      shiftAssignments: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
      skillRequirements: Prisma.$SkillRequirementPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs>
      plant: Prisma.$PlantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      departmentId: number
      workcenterNo: string
      name: string
      displayTitle: string | null
      defaultSchemeId: number | null
      minStaff: number
      gatingRules: string | null
      changeoverFamily: string | null
    }, ExtArgs["result"]["workcenter"]>
    composites: {}
  }

  type WorkcenterGetPayload<S extends boolean | null | undefined | WorkcenterDefaultArgs> = $Result.GetResult<Prisma.$WorkcenterPayload, S>

  type WorkcenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkcenterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkcenterCountAggregateInputType | true
    }

  export interface WorkcenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workcenter'], meta: { name: 'Workcenter' } }
    /**
     * Find zero or one Workcenter that matches the filter.
     * @param {WorkcenterFindUniqueArgs} args - Arguments to find a Workcenter
     * @example
     * // Get one Workcenter
     * const workcenter = await prisma.workcenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkcenterFindUniqueArgs>(args: SelectSubset<T, WorkcenterFindUniqueArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workcenter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkcenterFindUniqueOrThrowArgs} args - Arguments to find a Workcenter
     * @example
     * // Get one Workcenter
     * const workcenter = await prisma.workcenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkcenterFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkcenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workcenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterFindFirstArgs} args - Arguments to find a Workcenter
     * @example
     * // Get one Workcenter
     * const workcenter = await prisma.workcenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkcenterFindFirstArgs>(args?: SelectSubset<T, WorkcenterFindFirstArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workcenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterFindFirstOrThrowArgs} args - Arguments to find a Workcenter
     * @example
     * // Get one Workcenter
     * const workcenter = await prisma.workcenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkcenterFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkcenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workcenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workcenters
     * const workcenters = await prisma.workcenter.findMany()
     * 
     * // Get first 10 Workcenters
     * const workcenters = await prisma.workcenter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workcenterWithIdOnly = await prisma.workcenter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkcenterFindManyArgs>(args?: SelectSubset<T, WorkcenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workcenter.
     * @param {WorkcenterCreateArgs} args - Arguments to create a Workcenter.
     * @example
     * // Create one Workcenter
     * const Workcenter = await prisma.workcenter.create({
     *   data: {
     *     // ... data to create a Workcenter
     *   }
     * })
     * 
     */
    create<T extends WorkcenterCreateArgs>(args: SelectSubset<T, WorkcenterCreateArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workcenters.
     * @param {WorkcenterCreateManyArgs} args - Arguments to create many Workcenters.
     * @example
     * // Create many Workcenters
     * const workcenter = await prisma.workcenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkcenterCreateManyArgs>(args?: SelectSubset<T, WorkcenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workcenters and returns the data saved in the database.
     * @param {WorkcenterCreateManyAndReturnArgs} args - Arguments to create many Workcenters.
     * @example
     * // Create many Workcenters
     * const workcenter = await prisma.workcenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workcenters and only return the `id`
     * const workcenterWithIdOnly = await prisma.workcenter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkcenterCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkcenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workcenter.
     * @param {WorkcenterDeleteArgs} args - Arguments to delete one Workcenter.
     * @example
     * // Delete one Workcenter
     * const Workcenter = await prisma.workcenter.delete({
     *   where: {
     *     // ... filter to delete one Workcenter
     *   }
     * })
     * 
     */
    delete<T extends WorkcenterDeleteArgs>(args: SelectSubset<T, WorkcenterDeleteArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workcenter.
     * @param {WorkcenterUpdateArgs} args - Arguments to update one Workcenter.
     * @example
     * // Update one Workcenter
     * const workcenter = await prisma.workcenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkcenterUpdateArgs>(args: SelectSubset<T, WorkcenterUpdateArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workcenters.
     * @param {WorkcenterDeleteManyArgs} args - Arguments to filter Workcenters to delete.
     * @example
     * // Delete a few Workcenters
     * const { count } = await prisma.workcenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkcenterDeleteManyArgs>(args?: SelectSubset<T, WorkcenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workcenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workcenters
     * const workcenter = await prisma.workcenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkcenterUpdateManyArgs>(args: SelectSubset<T, WorkcenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workcenter.
     * @param {WorkcenterUpsertArgs} args - Arguments to update or create a Workcenter.
     * @example
     * // Update or create a Workcenter
     * const workcenter = await prisma.workcenter.upsert({
     *   create: {
     *     // ... data to create a Workcenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workcenter we want to update
     *   }
     * })
     */
    upsert<T extends WorkcenterUpsertArgs>(args: SelectSubset<T, WorkcenterUpsertArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workcenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterCountArgs} args - Arguments to filter Workcenters to count.
     * @example
     * // Count the number of Workcenters
     * const count = await prisma.workcenter.count({
     *   where: {
     *     // ... the filter for the Workcenters we want to count
     *   }
     * })
    **/
    count<T extends WorkcenterCountArgs>(
      args?: Subset<T, WorkcenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkcenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workcenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkcenterAggregateArgs>(args: Subset<T, WorkcenterAggregateArgs>): Prisma.PrismaPromise<GetWorkcenterAggregateType<T>>

    /**
     * Group by Workcenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkcenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkcenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkcenterGroupByArgs['orderBy'] }
        : { orderBy?: WorkcenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkcenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkcenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workcenter model
   */
  readonly fields: WorkcenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workcenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkcenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    changeovers<T extends Workcenter$changeoversArgs<ExtArgs> = {}>(args?: Subset<T, Workcenter$changeoversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Workcenter$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Workcenter$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    scheduleBlocks<T extends Workcenter$scheduleBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Workcenter$scheduleBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findMany"> | Null>
    shiftAssignments<T extends Workcenter$shiftAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Workcenter$shiftAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    skillRequirements<T extends Workcenter$skillRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, Workcenter$skillRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plant<T extends PlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantDefaultArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workcenter model
   */ 
  interface WorkcenterFieldRefs {
    readonly id: FieldRef<"Workcenter", 'Int'>
    readonly plantId: FieldRef<"Workcenter", 'Int'>
    readonly departmentId: FieldRef<"Workcenter", 'Int'>
    readonly workcenterNo: FieldRef<"Workcenter", 'String'>
    readonly name: FieldRef<"Workcenter", 'String'>
    readonly displayTitle: FieldRef<"Workcenter", 'String'>
    readonly defaultSchemeId: FieldRef<"Workcenter", 'Int'>
    readonly minStaff: FieldRef<"Workcenter", 'Int'>
    readonly gatingRules: FieldRef<"Workcenter", 'String'>
    readonly changeoverFamily: FieldRef<"Workcenter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workcenter findUnique
   */
  export type WorkcenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter, which Workcenter to fetch.
     */
    where: WorkcenterWhereUniqueInput
  }

  /**
   * Workcenter findUniqueOrThrow
   */
  export type WorkcenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter, which Workcenter to fetch.
     */
    where: WorkcenterWhereUniqueInput
  }

  /**
   * Workcenter findFirst
   */
  export type WorkcenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter, which Workcenter to fetch.
     */
    where?: WorkcenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workcenters to fetch.
     */
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workcenters.
     */
    cursor?: WorkcenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workcenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workcenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workcenters.
     */
    distinct?: WorkcenterScalarFieldEnum | WorkcenterScalarFieldEnum[]
  }

  /**
   * Workcenter findFirstOrThrow
   */
  export type WorkcenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter, which Workcenter to fetch.
     */
    where?: WorkcenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workcenters to fetch.
     */
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workcenters.
     */
    cursor?: WorkcenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workcenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workcenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workcenters.
     */
    distinct?: WorkcenterScalarFieldEnum | WorkcenterScalarFieldEnum[]
  }

  /**
   * Workcenter findMany
   */
  export type WorkcenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter, which Workcenters to fetch.
     */
    where?: WorkcenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workcenters to fetch.
     */
    orderBy?: WorkcenterOrderByWithRelationInput | WorkcenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workcenters.
     */
    cursor?: WorkcenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workcenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workcenters.
     */
    skip?: number
    distinct?: WorkcenterScalarFieldEnum | WorkcenterScalarFieldEnum[]
  }

  /**
   * Workcenter create
   */
  export type WorkcenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * The data needed to create a Workcenter.
     */
    data: XOR<WorkcenterCreateInput, WorkcenterUncheckedCreateInput>
  }

  /**
   * Workcenter createMany
   */
  export type WorkcenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workcenters.
     */
    data: WorkcenterCreateManyInput | WorkcenterCreateManyInput[]
  }

  /**
   * Workcenter createManyAndReturn
   */
  export type WorkcenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workcenters.
     */
    data: WorkcenterCreateManyInput | WorkcenterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workcenter update
   */
  export type WorkcenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * The data needed to update a Workcenter.
     */
    data: XOR<WorkcenterUpdateInput, WorkcenterUncheckedUpdateInput>
    /**
     * Choose, which Workcenter to update.
     */
    where: WorkcenterWhereUniqueInput
  }

  /**
   * Workcenter updateMany
   */
  export type WorkcenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workcenters.
     */
    data: XOR<WorkcenterUpdateManyMutationInput, WorkcenterUncheckedUpdateManyInput>
    /**
     * Filter which Workcenters to update
     */
    where?: WorkcenterWhereInput
  }

  /**
   * Workcenter upsert
   */
  export type WorkcenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * The filter to search for the Workcenter to update in case it exists.
     */
    where: WorkcenterWhereUniqueInput
    /**
     * In case the Workcenter found by the `where` argument doesn't exist, create a new Workcenter with this data.
     */
    create: XOR<WorkcenterCreateInput, WorkcenterUncheckedCreateInput>
    /**
     * In case the Workcenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkcenterUpdateInput, WorkcenterUncheckedUpdateInput>
  }

  /**
   * Workcenter delete
   */
  export type WorkcenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    /**
     * Filter which Workcenter to delete.
     */
    where: WorkcenterWhereUniqueInput
  }

  /**
   * Workcenter deleteMany
   */
  export type WorkcenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workcenters to delete
     */
    where?: WorkcenterWhereInput
  }

  /**
   * Workcenter.changeovers
   */
  export type Workcenter$changeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    where?: ChangeoverWhereInput
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    cursor?: ChangeoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * Workcenter.orders
   */
  export type Workcenter$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Workcenter.scheduleBlocks
   */
  export type Workcenter$scheduleBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    where?: ScheduleBlockWhereInput
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    cursor?: ScheduleBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleBlockScalarFieldEnum | ScheduleBlockScalarFieldEnum[]
  }

  /**
   * Workcenter.shiftAssignments
   */
  export type Workcenter$shiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * Workcenter.skillRequirements
   */
  export type Workcenter$skillRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    where?: SkillRequirementWhereInput
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    cursor?: SkillRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillRequirementScalarFieldEnum | SkillRequirementScalarFieldEnum[]
  }

  /**
   * Workcenter without action
   */
  export type WorkcenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type HolidaySumAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type HolidayMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    date: Date | null
    label: string | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    date: Date | null
    label: string | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    plantId: number
    date: number
    label: number
    _all: number
  }


  export type HolidayAvgAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type HolidaySumAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type HolidayMinAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    label?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    label?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    label?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolidayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolidaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _avg?: HolidayAvgAggregateInputType
    _sum?: HolidaySumAggregateInputType
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: number
    plantId: number
    date: Date
    label: string | null
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    date?: boolean
    label?: boolean
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    date?: boolean
    label?: boolean
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holiday"]>

  export type HolidaySelectScalar = {
    id?: boolean
    plantId?: boolean
    date?: boolean
    label?: boolean
  }

  export type HolidayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }
  export type HolidayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plant?: boolean | PlantDefaultArgs<ExtArgs>
  }

  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {
      plant: Prisma.$PlantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number
      date: Date
      label: string | null
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holidays and returns the data saved in the database.
     * @param {HolidayCreateManyAndReturnArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holidays and only return the `id`
     * const holidayWithIdOnly = await prisma.holiday.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolidayCreateManyAndReturnArgs>(args?: SelectSubset<T, HolidayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plant<T extends PlantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlantDefaultArgs<ExtArgs>>): Prisma__PlantClient<$Result.GetResult<Prisma.$PlantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */ 
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'Int'>
    readonly plantId: FieldRef<"Holiday", 'Int'>
    readonly date: FieldRef<"Holiday", 'DateTime'>
    readonly label: FieldRef<"Holiday", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
  }

  /**
   * Holiday createManyAndReturn
   */
  export type HolidayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolidayInclude<ExtArgs> | null
  }


  /**
   * Model SKU
   */

  export type AggregateSKU = {
    _count: SKUCountAggregateOutputType | null
    _avg: SKUAvgAggregateOutputType | null
    _sum: SKUSumAggregateOutputType | null
    _min: SKUMinAggregateOutputType | null
    _max: SKUMaxAggregateOutputType | null
  }

  export type SKUAvgAggregateOutputType = {
    id: number | null
  }

  export type SKUSumAggregateOutputType = {
    id: number | null
  }

  export type SKUMinAggregateOutputType = {
    id: number | null
    code: string | null
    family: string | null
    familyColorHex: string | null
    formula: string | null
    bottleSize: string | null
    caseSize: string | null
  }

  export type SKUMaxAggregateOutputType = {
    id: number | null
    code: string | null
    family: string | null
    familyColorHex: string | null
    formula: string | null
    bottleSize: string | null
    caseSize: string | null
  }

  export type SKUCountAggregateOutputType = {
    id: number
    code: number
    family: number
    familyColorHex: number
    formula: number
    bottleSize: number
    caseSize: number
    _all: number
  }


  export type SKUAvgAggregateInputType = {
    id?: true
  }

  export type SKUSumAggregateInputType = {
    id?: true
  }

  export type SKUMinAggregateInputType = {
    id?: true
    code?: true
    family?: true
    familyColorHex?: true
    formula?: true
    bottleSize?: true
    caseSize?: true
  }

  export type SKUMaxAggregateInputType = {
    id?: true
    code?: true
    family?: true
    familyColorHex?: true
    formula?: true
    bottleSize?: true
    caseSize?: true
  }

  export type SKUCountAggregateInputType = {
    id?: true
    code?: true
    family?: true
    familyColorHex?: true
    formula?: true
    bottleSize?: true
    caseSize?: true
    _all?: true
  }

  export type SKUAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SKU to aggregate.
     */
    where?: SKUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SKUS to fetch.
     */
    orderBy?: SKUOrderByWithRelationInput | SKUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SKUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SKUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SKUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SKUS
    **/
    _count?: true | SKUCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SKUAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SKUSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SKUMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SKUMaxAggregateInputType
  }

  export type GetSKUAggregateType<T extends SKUAggregateArgs> = {
        [P in keyof T & keyof AggregateSKU]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSKU[P]>
      : GetScalarType<T[P], AggregateSKU[P]>
  }




  export type SKUGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SKUWhereInput
    orderBy?: SKUOrderByWithAggregationInput | SKUOrderByWithAggregationInput[]
    by: SKUScalarFieldEnum[] | SKUScalarFieldEnum
    having?: SKUScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SKUCountAggregateInputType | true
    _avg?: SKUAvgAggregateInputType
    _sum?: SKUSumAggregateInputType
    _min?: SKUMinAggregateInputType
    _max?: SKUMaxAggregateInputType
  }

  export type SKUGroupByOutputType = {
    id: number
    code: string
    family: string
    familyColorHex: string | null
    formula: string | null
    bottleSize: string | null
    caseSize: string | null
    _count: SKUCountAggregateOutputType | null
    _avg: SKUAvgAggregateOutputType | null
    _sum: SKUSumAggregateOutputType | null
    _min: SKUMinAggregateOutputType | null
    _max: SKUMaxAggregateOutputType | null
  }

  type GetSKUGroupByPayload<T extends SKUGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SKUGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SKUGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SKUGroupByOutputType[P]>
            : GetScalarType<T[P], SKUGroupByOutputType[P]>
        }
      >
    >


  export type SKUSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    family?: boolean
    familyColorHex?: boolean
    formula?: boolean
    bottleSize?: boolean
    caseSize?: boolean
    orders?: boolean | SKU$ordersArgs<ExtArgs>
    products?: boolean | SKU$productsArgs<ExtArgs>
    _count?: boolean | SKUCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sKU"]>

  export type SKUSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    family?: boolean
    familyColorHex?: boolean
    formula?: boolean
    bottleSize?: boolean
    caseSize?: boolean
  }, ExtArgs["result"]["sKU"]>

  export type SKUSelectScalar = {
    id?: boolean
    code?: boolean
    family?: boolean
    familyColorHex?: boolean
    formula?: boolean
    bottleSize?: boolean
    caseSize?: boolean
  }

  export type SKUInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | SKU$ordersArgs<ExtArgs>
    products?: boolean | SKU$productsArgs<ExtArgs>
    _count?: boolean | SKUCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SKUIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SKUPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SKU"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      family: string
      familyColorHex: string | null
      formula: string | null
      bottleSize: string | null
      caseSize: string | null
    }, ExtArgs["result"]["sKU"]>
    composites: {}
  }

  type SKUGetPayload<S extends boolean | null | undefined | SKUDefaultArgs> = $Result.GetResult<Prisma.$SKUPayload, S>

  type SKUCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SKUFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SKUCountAggregateInputType | true
    }

  export interface SKUDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SKU'], meta: { name: 'SKU' } }
    /**
     * Find zero or one SKU that matches the filter.
     * @param {SKUFindUniqueArgs} args - Arguments to find a SKU
     * @example
     * // Get one SKU
     * const sKU = await prisma.sKU.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SKUFindUniqueArgs>(args: SelectSubset<T, SKUFindUniqueArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SKU that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SKUFindUniqueOrThrowArgs} args - Arguments to find a SKU
     * @example
     * // Get one SKU
     * const sKU = await prisma.sKU.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SKUFindUniqueOrThrowArgs>(args: SelectSubset<T, SKUFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SKU that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUFindFirstArgs} args - Arguments to find a SKU
     * @example
     * // Get one SKU
     * const sKU = await prisma.sKU.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SKUFindFirstArgs>(args?: SelectSubset<T, SKUFindFirstArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SKU that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUFindFirstOrThrowArgs} args - Arguments to find a SKU
     * @example
     * // Get one SKU
     * const sKU = await prisma.sKU.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SKUFindFirstOrThrowArgs>(args?: SelectSubset<T, SKUFindFirstOrThrowArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SKUS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SKUS
     * const sKUS = await prisma.sKU.findMany()
     * 
     * // Get first 10 SKUS
     * const sKUS = await prisma.sKU.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sKUWithIdOnly = await prisma.sKU.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SKUFindManyArgs>(args?: SelectSubset<T, SKUFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SKU.
     * @param {SKUCreateArgs} args - Arguments to create a SKU.
     * @example
     * // Create one SKU
     * const SKU = await prisma.sKU.create({
     *   data: {
     *     // ... data to create a SKU
     *   }
     * })
     * 
     */
    create<T extends SKUCreateArgs>(args: SelectSubset<T, SKUCreateArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SKUS.
     * @param {SKUCreateManyArgs} args - Arguments to create many SKUS.
     * @example
     * // Create many SKUS
     * const sKU = await prisma.sKU.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SKUCreateManyArgs>(args?: SelectSubset<T, SKUCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SKUS and returns the data saved in the database.
     * @param {SKUCreateManyAndReturnArgs} args - Arguments to create many SKUS.
     * @example
     * // Create many SKUS
     * const sKU = await prisma.sKU.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SKUS and only return the `id`
     * const sKUWithIdOnly = await prisma.sKU.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SKUCreateManyAndReturnArgs>(args?: SelectSubset<T, SKUCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SKU.
     * @param {SKUDeleteArgs} args - Arguments to delete one SKU.
     * @example
     * // Delete one SKU
     * const SKU = await prisma.sKU.delete({
     *   where: {
     *     // ... filter to delete one SKU
     *   }
     * })
     * 
     */
    delete<T extends SKUDeleteArgs>(args: SelectSubset<T, SKUDeleteArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SKU.
     * @param {SKUUpdateArgs} args - Arguments to update one SKU.
     * @example
     * // Update one SKU
     * const sKU = await prisma.sKU.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SKUUpdateArgs>(args: SelectSubset<T, SKUUpdateArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SKUS.
     * @param {SKUDeleteManyArgs} args - Arguments to filter SKUS to delete.
     * @example
     * // Delete a few SKUS
     * const { count } = await prisma.sKU.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SKUDeleteManyArgs>(args?: SelectSubset<T, SKUDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SKUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SKUS
     * const sKU = await prisma.sKU.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SKUUpdateManyArgs>(args: SelectSubset<T, SKUUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SKU.
     * @param {SKUUpsertArgs} args - Arguments to update or create a SKU.
     * @example
     * // Update or create a SKU
     * const sKU = await prisma.sKU.upsert({
     *   create: {
     *     // ... data to create a SKU
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SKU we want to update
     *   }
     * })
     */
    upsert<T extends SKUUpsertArgs>(args: SelectSubset<T, SKUUpsertArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SKUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUCountArgs} args - Arguments to filter SKUS to count.
     * @example
     * // Count the number of SKUS
     * const count = await prisma.sKU.count({
     *   where: {
     *     // ... the filter for the SKUS we want to count
     *   }
     * })
    **/
    count<T extends SKUCountArgs>(
      args?: Subset<T, SKUCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SKUCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SKU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SKUAggregateArgs>(args: Subset<T, SKUAggregateArgs>): Prisma.PrismaPromise<GetSKUAggregateType<T>>

    /**
     * Group by SKU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SKUGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SKUGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SKUGroupByArgs['orderBy'] }
        : { orderBy?: SKUGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SKUGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSKUGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SKU model
   */
  readonly fields: SKUFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SKU.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SKUClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends SKU$ordersArgs<ExtArgs> = {}>(args?: Subset<T, SKU$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends SKU$productsArgs<ExtArgs> = {}>(args?: Subset<T, SKU$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SKU model
   */ 
  interface SKUFieldRefs {
    readonly id: FieldRef<"SKU", 'Int'>
    readonly code: FieldRef<"SKU", 'String'>
    readonly family: FieldRef<"SKU", 'String'>
    readonly familyColorHex: FieldRef<"SKU", 'String'>
    readonly formula: FieldRef<"SKU", 'String'>
    readonly bottleSize: FieldRef<"SKU", 'String'>
    readonly caseSize: FieldRef<"SKU", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SKU findUnique
   */
  export type SKUFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter, which SKU to fetch.
     */
    where: SKUWhereUniqueInput
  }

  /**
   * SKU findUniqueOrThrow
   */
  export type SKUFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter, which SKU to fetch.
     */
    where: SKUWhereUniqueInput
  }

  /**
   * SKU findFirst
   */
  export type SKUFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter, which SKU to fetch.
     */
    where?: SKUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SKUS to fetch.
     */
    orderBy?: SKUOrderByWithRelationInput | SKUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SKUS.
     */
    cursor?: SKUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SKUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SKUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SKUS.
     */
    distinct?: SKUScalarFieldEnum | SKUScalarFieldEnum[]
  }

  /**
   * SKU findFirstOrThrow
   */
  export type SKUFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter, which SKU to fetch.
     */
    where?: SKUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SKUS to fetch.
     */
    orderBy?: SKUOrderByWithRelationInput | SKUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SKUS.
     */
    cursor?: SKUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SKUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SKUS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SKUS.
     */
    distinct?: SKUScalarFieldEnum | SKUScalarFieldEnum[]
  }

  /**
   * SKU findMany
   */
  export type SKUFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter, which SKUS to fetch.
     */
    where?: SKUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SKUS to fetch.
     */
    orderBy?: SKUOrderByWithRelationInput | SKUOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SKUS.
     */
    cursor?: SKUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SKUS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SKUS.
     */
    skip?: number
    distinct?: SKUScalarFieldEnum | SKUScalarFieldEnum[]
  }

  /**
   * SKU create
   */
  export type SKUCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * The data needed to create a SKU.
     */
    data: XOR<SKUCreateInput, SKUUncheckedCreateInput>
  }

  /**
   * SKU createMany
   */
  export type SKUCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SKUS.
     */
    data: SKUCreateManyInput | SKUCreateManyInput[]
  }

  /**
   * SKU createManyAndReturn
   */
  export type SKUCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SKUS.
     */
    data: SKUCreateManyInput | SKUCreateManyInput[]
  }

  /**
   * SKU update
   */
  export type SKUUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * The data needed to update a SKU.
     */
    data: XOR<SKUUpdateInput, SKUUncheckedUpdateInput>
    /**
     * Choose, which SKU to update.
     */
    where: SKUWhereUniqueInput
  }

  /**
   * SKU updateMany
   */
  export type SKUUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SKUS.
     */
    data: XOR<SKUUpdateManyMutationInput, SKUUncheckedUpdateManyInput>
    /**
     * Filter which SKUS to update
     */
    where?: SKUWhereInput
  }

  /**
   * SKU upsert
   */
  export type SKUUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * The filter to search for the SKU to update in case it exists.
     */
    where: SKUWhereUniqueInput
    /**
     * In case the SKU found by the `where` argument doesn't exist, create a new SKU with this data.
     */
    create: XOR<SKUCreateInput, SKUUncheckedCreateInput>
    /**
     * In case the SKU was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SKUUpdateInput, SKUUncheckedUpdateInput>
  }

  /**
   * SKU delete
   */
  export type SKUDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
    /**
     * Filter which SKU to delete.
     */
    where: SKUWhereUniqueInput
  }

  /**
   * SKU deleteMany
   */
  export type SKUDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SKUS to delete
     */
    where?: SKUWhereInput
  }

  /**
   * SKU.orders
   */
  export type SKU$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * SKU.products
   */
  export type SKU$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * SKU without action
   */
  export type SKUDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SKU
     */
    select?: SKUSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SKUInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    skuId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    skuId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    skuId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    skuId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    skuId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    skuId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    skuId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    skuId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    skuId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    skuId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    skuId: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    skuId?: boolean
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    skuId?: boolean
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    skuId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      sku: Prisma.$SKUPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      skuId: number
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sku<T extends SKUDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SKUDefaultArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly skuId: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    skuId: number | null
    qty: number | null
    runRateUph: number | null
    performanceLeverPct: number | null
    priority: number | null
    workcenterId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    skuId: number | null
    qty: number | null
    runRateUph: number | null
    performanceLeverPct: number | null
    priority: number | null
    workcenterId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    orderNo: string | null
    skuId: number | null
    qty: number | null
    runRateUph: number | null
    performanceLeverPct: number | null
    priority: number | null
    dueAt: Date | null
    workcenterId: number | null
    shopfloorTitle: string | null
    colorHex: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    orderNo: string | null
    skuId: number | null
    qty: number | null
    runRateUph: number | null
    performanceLeverPct: number | null
    priority: number | null
    dueAt: Date | null
    workcenterId: number | null
    shopfloorTitle: string | null
    colorHex: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNo: number
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct: number
    priority: number
    dueAt: number
    workcenterId: number
    shopfloorTitle: number
    colorHex: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    skuId?: true
    qty?: true
    runRateUph?: true
    performanceLeverPct?: true
    priority?: true
    workcenterId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    skuId?: true
    qty?: true
    runRateUph?: true
    performanceLeverPct?: true
    priority?: true
    workcenterId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNo?: true
    skuId?: true
    qty?: true
    runRateUph?: true
    performanceLeverPct?: true
    priority?: true
    dueAt?: true
    workcenterId?: true
    shopfloorTitle?: true
    colorHex?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNo?: true
    skuId?: true
    qty?: true
    runRateUph?: true
    performanceLeverPct?: true
    priority?: true
    dueAt?: true
    workcenterId?: true
    shopfloorTitle?: true
    colorHex?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNo?: true
    skuId?: true
    qty?: true
    runRateUph?: true
    performanceLeverPct?: true
    priority?: true
    dueAt?: true
    workcenterId?: true
    shopfloorTitle?: true
    colorHex?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct: number
    priority: number
    dueAt: Date
    workcenterId: number | null
    shopfloorTitle: string | null
    colorHex: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    skuId?: boolean
    qty?: boolean
    runRateUph?: boolean
    performanceLeverPct?: boolean
    priority?: boolean
    dueAt?: boolean
    workcenterId?: boolean
    shopfloorTitle?: boolean
    colorHex?: boolean
    plannedWorkcenter?: boolean | Order$plannedWorkcenterArgs<ExtArgs>
    sku?: boolean | SKUDefaultArgs<ExtArgs>
    scheduleBlocks?: boolean | Order$scheduleBlocksArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    skuId?: boolean
    qty?: boolean
    runRateUph?: boolean
    performanceLeverPct?: boolean
    priority?: boolean
    dueAt?: boolean
    workcenterId?: boolean
    shopfloorTitle?: boolean
    colorHex?: boolean
    plannedWorkcenter?: boolean | Order$plannedWorkcenterArgs<ExtArgs>
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNo?: boolean
    skuId?: boolean
    qty?: boolean
    runRateUph?: boolean
    performanceLeverPct?: boolean
    priority?: boolean
    dueAt?: boolean
    workcenterId?: boolean
    shopfloorTitle?: boolean
    colorHex?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannedWorkcenter?: boolean | Order$plannedWorkcenterArgs<ExtArgs>
    sku?: boolean | SKUDefaultArgs<ExtArgs>
    scheduleBlocks?: boolean | Order$scheduleBlocksArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plannedWorkcenter?: boolean | Order$plannedWorkcenterArgs<ExtArgs>
    sku?: boolean | SKUDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      plannedWorkcenter: Prisma.$WorkcenterPayload<ExtArgs> | null
      sku: Prisma.$SKUPayload<ExtArgs>
      scheduleBlocks: Prisma.$ScheduleBlockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNo: string
      skuId: number
      qty: number
      runRateUph: number
      performanceLeverPct: number
      priority: number
      dueAt: Date
      workcenterId: number | null
      shopfloorTitle: string | null
      colorHex: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plannedWorkcenter<T extends Order$plannedWorkcenterArgs<ExtArgs> = {}>(args?: Subset<T, Order$plannedWorkcenterArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sku<T extends SKUDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SKUDefaultArgs<ExtArgs>>): Prisma__SKUClient<$Result.GetResult<Prisma.$SKUPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scheduleBlocks<T extends Order$scheduleBlocksArgs<ExtArgs> = {}>(args?: Subset<T, Order$scheduleBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly orderNo: FieldRef<"Order", 'String'>
    readonly skuId: FieldRef<"Order", 'Int'>
    readonly qty: FieldRef<"Order", 'Int'>
    readonly runRateUph: FieldRef<"Order", 'Int'>
    readonly performanceLeverPct: FieldRef<"Order", 'Float'>
    readonly priority: FieldRef<"Order", 'Int'>
    readonly dueAt: FieldRef<"Order", 'DateTime'>
    readonly workcenterId: FieldRef<"Order", 'Int'>
    readonly shopfloorTitle: FieldRef<"Order", 'String'>
    readonly colorHex: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.plannedWorkcenter
   */
  export type Order$plannedWorkcenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workcenter
     */
    select?: WorkcenterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkcenterInclude<ExtArgs> | null
    where?: WorkcenterWhereInput
  }

  /**
   * Order.scheduleBlocks
   */
  export type Order$scheduleBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    where?: ScheduleBlockWhereInput
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    cursor?: ScheduleBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleBlockScalarFieldEnum | ScheduleBlockScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleBlock
   */

  export type AggregateScheduleBlock = {
    _count: ScheduleBlockCountAggregateOutputType | null
    _avg: ScheduleBlockAvgAggregateOutputType | null
    _sum: ScheduleBlockSumAggregateOutputType | null
    _min: ScheduleBlockMinAggregateOutputType | null
    _max: ScheduleBlockMaxAggregateOutputType | null
  }

  export type ScheduleBlockAvgAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    orderId: number | null
  }

  export type ScheduleBlockSumAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    orderId: number | null
  }

  export type ScheduleBlockMinAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    orderId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type ScheduleBlockMaxAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    orderId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type ScheduleBlockCountAggregateOutputType = {
    id: number
    workcenterId: number
    orderId: number
    startAt: number
    endAt: number
    _all: number
  }


  export type ScheduleBlockAvgAggregateInputType = {
    id?: true
    workcenterId?: true
    orderId?: true
  }

  export type ScheduleBlockSumAggregateInputType = {
    id?: true
    workcenterId?: true
    orderId?: true
  }

  export type ScheduleBlockMinAggregateInputType = {
    id?: true
    workcenterId?: true
    orderId?: true
    startAt?: true
    endAt?: true
  }

  export type ScheduleBlockMaxAggregateInputType = {
    id?: true
    workcenterId?: true
    orderId?: true
    startAt?: true
    endAt?: true
  }

  export type ScheduleBlockCountAggregateInputType = {
    id?: true
    workcenterId?: true
    orderId?: true
    startAt?: true
    endAt?: true
    _all?: true
  }

  export type ScheduleBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleBlock to aggregate.
     */
    where?: ScheduleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleBlocks to fetch.
     */
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleBlocks
    **/
    _count?: true | ScheduleBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleBlockMaxAggregateInputType
  }

  export type GetScheduleBlockAggregateType<T extends ScheduleBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleBlock[P]>
      : GetScalarType<T[P], AggregateScheduleBlock[P]>
  }




  export type ScheduleBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleBlockWhereInput
    orderBy?: ScheduleBlockOrderByWithAggregationInput | ScheduleBlockOrderByWithAggregationInput[]
    by: ScheduleBlockScalarFieldEnum[] | ScheduleBlockScalarFieldEnum
    having?: ScheduleBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleBlockCountAggregateInputType | true
    _avg?: ScheduleBlockAvgAggregateInputType
    _sum?: ScheduleBlockSumAggregateInputType
    _min?: ScheduleBlockMinAggregateInputType
    _max?: ScheduleBlockMaxAggregateInputType
  }

  export type ScheduleBlockGroupByOutputType = {
    id: number
    workcenterId: number
    orderId: number | null
    startAt: Date
    endAt: Date
    _count: ScheduleBlockCountAggregateOutputType | null
    _avg: ScheduleBlockAvgAggregateOutputType | null
    _sum: ScheduleBlockSumAggregateOutputType | null
    _min: ScheduleBlockMinAggregateOutputType | null
    _max: ScheduleBlockMaxAggregateOutputType | null
  }

  type GetScheduleBlockGroupByPayload<T extends ScheduleBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleBlockGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleBlockGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    orderId?: boolean
    startAt?: boolean
    endAt?: boolean
    toChangeovers?: boolean | ScheduleBlock$toChangeoversArgs<ExtArgs>
    fromChangeovers?: boolean | ScheduleBlock$fromChangeoversArgs<ExtArgs>
    order?: boolean | ScheduleBlock$orderArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    _count?: boolean | ScheduleBlockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleBlock"]>

  export type ScheduleBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    orderId?: boolean
    startAt?: boolean
    endAt?: boolean
    order?: boolean | ScheduleBlock$orderArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleBlock"]>

  export type ScheduleBlockSelectScalar = {
    id?: boolean
    workcenterId?: boolean
    orderId?: boolean
    startAt?: boolean
    endAt?: boolean
  }

  export type ScheduleBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toChangeovers?: boolean | ScheduleBlock$toChangeoversArgs<ExtArgs>
    fromChangeovers?: boolean | ScheduleBlock$fromChangeoversArgs<ExtArgs>
    order?: boolean | ScheduleBlock$orderArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    _count?: boolean | ScheduleBlockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ScheduleBlock$orderArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }

  export type $ScheduleBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleBlock"
    objects: {
      toChangeovers: Prisma.$ChangeoverPayload<ExtArgs>[]
      fromChangeovers: Prisma.$ChangeoverPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs> | null
      workcenter: Prisma.$WorkcenterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workcenterId: number
      orderId: number | null
      startAt: Date
      endAt: Date
    }, ExtArgs["result"]["scheduleBlock"]>
    composites: {}
  }

  type ScheduleBlockGetPayload<S extends boolean | null | undefined | ScheduleBlockDefaultArgs> = $Result.GetResult<Prisma.$ScheduleBlockPayload, S>

  type ScheduleBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleBlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleBlockCountAggregateInputType | true
    }

  export interface ScheduleBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleBlock'], meta: { name: 'ScheduleBlock' } }
    /**
     * Find zero or one ScheduleBlock that matches the filter.
     * @param {ScheduleBlockFindUniqueArgs} args - Arguments to find a ScheduleBlock
     * @example
     * // Get one ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleBlockFindUniqueArgs>(args: SelectSubset<T, ScheduleBlockFindUniqueArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduleBlock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleBlockFindUniqueOrThrowArgs} args - Arguments to find a ScheduleBlock
     * @example
     * // Get one ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduleBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockFindFirstArgs} args - Arguments to find a ScheduleBlock
     * @example
     * // Get one ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleBlockFindFirstArgs>(args?: SelectSubset<T, ScheduleBlockFindFirstArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduleBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockFindFirstOrThrowArgs} args - Arguments to find a ScheduleBlock
     * @example
     * // Get one ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduleBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleBlocks
     * const scheduleBlocks = await prisma.scheduleBlock.findMany()
     * 
     * // Get first 10 ScheduleBlocks
     * const scheduleBlocks = await prisma.scheduleBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleBlockWithIdOnly = await prisma.scheduleBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleBlockFindManyArgs>(args?: SelectSubset<T, ScheduleBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduleBlock.
     * @param {ScheduleBlockCreateArgs} args - Arguments to create a ScheduleBlock.
     * @example
     * // Create one ScheduleBlock
     * const ScheduleBlock = await prisma.scheduleBlock.create({
     *   data: {
     *     // ... data to create a ScheduleBlock
     *   }
     * })
     * 
     */
    create<T extends ScheduleBlockCreateArgs>(args: SelectSubset<T, ScheduleBlockCreateArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduleBlocks.
     * @param {ScheduleBlockCreateManyArgs} args - Arguments to create many ScheduleBlocks.
     * @example
     * // Create many ScheduleBlocks
     * const scheduleBlock = await prisma.scheduleBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleBlockCreateManyArgs>(args?: SelectSubset<T, ScheduleBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleBlocks and returns the data saved in the database.
     * @param {ScheduleBlockCreateManyAndReturnArgs} args - Arguments to create many ScheduleBlocks.
     * @example
     * // Create many ScheduleBlocks
     * const scheduleBlock = await prisma.scheduleBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleBlocks and only return the `id`
     * const scheduleBlockWithIdOnly = await prisma.scheduleBlock.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduleBlock.
     * @param {ScheduleBlockDeleteArgs} args - Arguments to delete one ScheduleBlock.
     * @example
     * // Delete one ScheduleBlock
     * const ScheduleBlock = await prisma.scheduleBlock.delete({
     *   where: {
     *     // ... filter to delete one ScheduleBlock
     *   }
     * })
     * 
     */
    delete<T extends ScheduleBlockDeleteArgs>(args: SelectSubset<T, ScheduleBlockDeleteArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduleBlock.
     * @param {ScheduleBlockUpdateArgs} args - Arguments to update one ScheduleBlock.
     * @example
     * // Update one ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleBlockUpdateArgs>(args: SelectSubset<T, ScheduleBlockUpdateArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduleBlocks.
     * @param {ScheduleBlockDeleteManyArgs} args - Arguments to filter ScheduleBlocks to delete.
     * @example
     * // Delete a few ScheduleBlocks
     * const { count } = await prisma.scheduleBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleBlockDeleteManyArgs>(args?: SelectSubset<T, ScheduleBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleBlocks
     * const scheduleBlock = await prisma.scheduleBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleBlockUpdateManyArgs>(args: SelectSubset<T, ScheduleBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduleBlock.
     * @param {ScheduleBlockUpsertArgs} args - Arguments to update or create a ScheduleBlock.
     * @example
     * // Update or create a ScheduleBlock
     * const scheduleBlock = await prisma.scheduleBlock.upsert({
     *   create: {
     *     // ... data to create a ScheduleBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleBlock we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleBlockUpsertArgs>(args: SelectSubset<T, ScheduleBlockUpsertArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduleBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockCountArgs} args - Arguments to filter ScheduleBlocks to count.
     * @example
     * // Count the number of ScheduleBlocks
     * const count = await prisma.scheduleBlock.count({
     *   where: {
     *     // ... the filter for the ScheduleBlocks we want to count
     *   }
     * })
    **/
    count<T extends ScheduleBlockCountArgs>(
      args?: Subset<T, ScheduleBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleBlockAggregateArgs>(args: Subset<T, ScheduleBlockAggregateArgs>): Prisma.PrismaPromise<GetScheduleBlockAggregateType<T>>

    /**
     * Group by ScheduleBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleBlockGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleBlock model
   */
  readonly fields: ScheduleBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toChangeovers<T extends ScheduleBlock$toChangeoversArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleBlock$toChangeoversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findMany"> | Null>
    fromChangeovers<T extends ScheduleBlock$fromChangeoversArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleBlock$fromChangeoversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findMany"> | Null>
    order<T extends ScheduleBlock$orderArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleBlock$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workcenter<T extends WorkcenterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkcenterDefaultArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleBlock model
   */ 
  interface ScheduleBlockFieldRefs {
    readonly id: FieldRef<"ScheduleBlock", 'Int'>
    readonly workcenterId: FieldRef<"ScheduleBlock", 'Int'>
    readonly orderId: FieldRef<"ScheduleBlock", 'Int'>
    readonly startAt: FieldRef<"ScheduleBlock", 'DateTime'>
    readonly endAt: FieldRef<"ScheduleBlock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleBlock findUnique
   */
  export type ScheduleBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleBlock to fetch.
     */
    where: ScheduleBlockWhereUniqueInput
  }

  /**
   * ScheduleBlock findUniqueOrThrow
   */
  export type ScheduleBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleBlock to fetch.
     */
    where: ScheduleBlockWhereUniqueInput
  }

  /**
   * ScheduleBlock findFirst
   */
  export type ScheduleBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleBlock to fetch.
     */
    where?: ScheduleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleBlocks to fetch.
     */
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleBlocks.
     */
    cursor?: ScheduleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleBlocks.
     */
    distinct?: ScheduleBlockScalarFieldEnum | ScheduleBlockScalarFieldEnum[]
  }

  /**
   * ScheduleBlock findFirstOrThrow
   */
  export type ScheduleBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleBlock to fetch.
     */
    where?: ScheduleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleBlocks to fetch.
     */
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleBlocks.
     */
    cursor?: ScheduleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleBlocks.
     */
    distinct?: ScheduleBlockScalarFieldEnum | ScheduleBlockScalarFieldEnum[]
  }

  /**
   * ScheduleBlock findMany
   */
  export type ScheduleBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleBlocks to fetch.
     */
    where?: ScheduleBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleBlocks to fetch.
     */
    orderBy?: ScheduleBlockOrderByWithRelationInput | ScheduleBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleBlocks.
     */
    cursor?: ScheduleBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleBlocks.
     */
    skip?: number
    distinct?: ScheduleBlockScalarFieldEnum | ScheduleBlockScalarFieldEnum[]
  }

  /**
   * ScheduleBlock create
   */
  export type ScheduleBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleBlock.
     */
    data: XOR<ScheduleBlockCreateInput, ScheduleBlockUncheckedCreateInput>
  }

  /**
   * ScheduleBlock createMany
   */
  export type ScheduleBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleBlocks.
     */
    data: ScheduleBlockCreateManyInput | ScheduleBlockCreateManyInput[]
  }

  /**
   * ScheduleBlock createManyAndReturn
   */
  export type ScheduleBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduleBlocks.
     */
    data: ScheduleBlockCreateManyInput | ScheduleBlockCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleBlock update
   */
  export type ScheduleBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleBlock.
     */
    data: XOR<ScheduleBlockUpdateInput, ScheduleBlockUncheckedUpdateInput>
    /**
     * Choose, which ScheduleBlock to update.
     */
    where: ScheduleBlockWhereUniqueInput
  }

  /**
   * ScheduleBlock updateMany
   */
  export type ScheduleBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleBlocks.
     */
    data: XOR<ScheduleBlockUpdateManyMutationInput, ScheduleBlockUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleBlocks to update
     */
    where?: ScheduleBlockWhereInput
  }

  /**
   * ScheduleBlock upsert
   */
  export type ScheduleBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleBlock to update in case it exists.
     */
    where: ScheduleBlockWhereUniqueInput
    /**
     * In case the ScheduleBlock found by the `where` argument doesn't exist, create a new ScheduleBlock with this data.
     */
    create: XOR<ScheduleBlockCreateInput, ScheduleBlockUncheckedCreateInput>
    /**
     * In case the ScheduleBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleBlockUpdateInput, ScheduleBlockUncheckedUpdateInput>
  }

  /**
   * ScheduleBlock delete
   */
  export type ScheduleBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
    /**
     * Filter which ScheduleBlock to delete.
     */
    where: ScheduleBlockWhereUniqueInput
  }

  /**
   * ScheduleBlock deleteMany
   */
  export type ScheduleBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleBlocks to delete
     */
    where?: ScheduleBlockWhereInput
  }

  /**
   * ScheduleBlock.toChangeovers
   */
  export type ScheduleBlock$toChangeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    where?: ChangeoverWhereInput
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    cursor?: ChangeoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * ScheduleBlock.fromChangeovers
   */
  export type ScheduleBlock$fromChangeoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    where?: ChangeoverWhereInput
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    cursor?: ChangeoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * ScheduleBlock.order
   */
  export type ScheduleBlock$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * ScheduleBlock without action
   */
  export type ScheduleBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleBlock
     */
    select?: ScheduleBlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleBlockInclude<ExtArgs> | null
  }


  /**
   * Model Changeover
   */

  export type AggregateChangeover = {
    _count: ChangeoverCountAggregateOutputType | null
    _avg: ChangeoverAvgAggregateOutputType | null
    _sum: ChangeoverSumAggregateOutputType | null
    _min: ChangeoverMinAggregateOutputType | null
    _max: ChangeoverMaxAggregateOutputType | null
  }

  export type ChangeoverAvgAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    fromBlockId: number | null
    toBlockId: number | null
    plannedMinutes: number | null
  }

  export type ChangeoverSumAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    fromBlockId: number | null
    toBlockId: number | null
    plannedMinutes: number | null
  }

  export type ChangeoverMinAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    fromBlockId: number | null
    toBlockId: number | null
    typeCode: string | null
    plannedMinutes: number | null
    includeInOee: boolean | null
    complexityTier: string | null
  }

  export type ChangeoverMaxAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    fromBlockId: number | null
    toBlockId: number | null
    typeCode: string | null
    plannedMinutes: number | null
    includeInOee: boolean | null
    complexityTier: string | null
  }

  export type ChangeoverCountAggregateOutputType = {
    id: number
    workcenterId: number
    fromBlockId: number
    toBlockId: number
    typeCode: number
    plannedMinutes: number
    includeInOee: number
    complexityTier: number
    _all: number
  }


  export type ChangeoverAvgAggregateInputType = {
    id?: true
    workcenterId?: true
    fromBlockId?: true
    toBlockId?: true
    plannedMinutes?: true
  }

  export type ChangeoverSumAggregateInputType = {
    id?: true
    workcenterId?: true
    fromBlockId?: true
    toBlockId?: true
    plannedMinutes?: true
  }

  export type ChangeoverMinAggregateInputType = {
    id?: true
    workcenterId?: true
    fromBlockId?: true
    toBlockId?: true
    typeCode?: true
    plannedMinutes?: true
    includeInOee?: true
    complexityTier?: true
  }

  export type ChangeoverMaxAggregateInputType = {
    id?: true
    workcenterId?: true
    fromBlockId?: true
    toBlockId?: true
    typeCode?: true
    plannedMinutes?: true
    includeInOee?: true
    complexityTier?: true
  }

  export type ChangeoverCountAggregateInputType = {
    id?: true
    workcenterId?: true
    fromBlockId?: true
    toBlockId?: true
    typeCode?: true
    plannedMinutes?: true
    includeInOee?: true
    complexityTier?: true
    _all?: true
  }

  export type ChangeoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Changeover to aggregate.
     */
    where?: ChangeoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changeovers to fetch.
     */
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changeovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changeovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Changeovers
    **/
    _count?: true | ChangeoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangeoverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangeoverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeoverMaxAggregateInputType
  }

  export type GetChangeoverAggregateType<T extends ChangeoverAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeover[P]>
      : GetScalarType<T[P], AggregateChangeover[P]>
  }




  export type ChangeoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeoverWhereInput
    orderBy?: ChangeoverOrderByWithAggregationInput | ChangeoverOrderByWithAggregationInput[]
    by: ChangeoverScalarFieldEnum[] | ChangeoverScalarFieldEnum
    having?: ChangeoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeoverCountAggregateInputType | true
    _avg?: ChangeoverAvgAggregateInputType
    _sum?: ChangeoverSumAggregateInputType
    _min?: ChangeoverMinAggregateInputType
    _max?: ChangeoverMaxAggregateInputType
  }

  export type ChangeoverGroupByOutputType = {
    id: number
    workcenterId: number
    fromBlockId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee: boolean
    complexityTier: string | null
    _count: ChangeoverCountAggregateOutputType | null
    _avg: ChangeoverAvgAggregateOutputType | null
    _sum: ChangeoverSumAggregateOutputType | null
    _min: ChangeoverMinAggregateOutputType | null
    _max: ChangeoverMaxAggregateOutputType | null
  }

  type GetChangeoverGroupByPayload<T extends ChangeoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeoverGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeoverGroupByOutputType[P]>
        }
      >
    >


  export type ChangeoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    fromBlockId?: boolean
    toBlockId?: boolean
    typeCode?: boolean
    plannedMinutes?: boolean
    includeInOee?: boolean
    complexityTier?: boolean
    toBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    fromBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeover"]>

  export type ChangeoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    fromBlockId?: boolean
    toBlockId?: boolean
    typeCode?: boolean
    plannedMinutes?: boolean
    includeInOee?: boolean
    complexityTier?: boolean
    toBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    fromBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeover"]>

  export type ChangeoverSelectScalar = {
    id?: boolean
    workcenterId?: boolean
    fromBlockId?: boolean
    toBlockId?: boolean
    typeCode?: boolean
    plannedMinutes?: boolean
    includeInOee?: boolean
    complexityTier?: boolean
  }

  export type ChangeoverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    fromBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }
  export type ChangeoverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    fromBlock?: boolean | ScheduleBlockDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }

  export type $ChangeoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Changeover"
    objects: {
      toBlock: Prisma.$ScheduleBlockPayload<ExtArgs>
      fromBlock: Prisma.$ScheduleBlockPayload<ExtArgs>
      workcenter: Prisma.$WorkcenterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workcenterId: number
      fromBlockId: number
      toBlockId: number
      typeCode: string
      plannedMinutes: number
      includeInOee: boolean
      complexityTier: string | null
    }, ExtArgs["result"]["changeover"]>
    composites: {}
  }

  type ChangeoverGetPayload<S extends boolean | null | undefined | ChangeoverDefaultArgs> = $Result.GetResult<Prisma.$ChangeoverPayload, S>

  type ChangeoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChangeoverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangeoverCountAggregateInputType | true
    }

  export interface ChangeoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Changeover'], meta: { name: 'Changeover' } }
    /**
     * Find zero or one Changeover that matches the filter.
     * @param {ChangeoverFindUniqueArgs} args - Arguments to find a Changeover
     * @example
     * // Get one Changeover
     * const changeover = await prisma.changeover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeoverFindUniqueArgs>(args: SelectSubset<T, ChangeoverFindUniqueArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Changeover that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChangeoverFindUniqueOrThrowArgs} args - Arguments to find a Changeover
     * @example
     * // Get one Changeover
     * const changeover = await prisma.changeover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeoverFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Changeover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverFindFirstArgs} args - Arguments to find a Changeover
     * @example
     * // Get one Changeover
     * const changeover = await prisma.changeover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeoverFindFirstArgs>(args?: SelectSubset<T, ChangeoverFindFirstArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Changeover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverFindFirstOrThrowArgs} args - Arguments to find a Changeover
     * @example
     * // Get one Changeover
     * const changeover = await prisma.changeover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeoverFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Changeovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Changeovers
     * const changeovers = await prisma.changeover.findMany()
     * 
     * // Get first 10 Changeovers
     * const changeovers = await prisma.changeover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeoverWithIdOnly = await prisma.changeover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeoverFindManyArgs>(args?: SelectSubset<T, ChangeoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Changeover.
     * @param {ChangeoverCreateArgs} args - Arguments to create a Changeover.
     * @example
     * // Create one Changeover
     * const Changeover = await prisma.changeover.create({
     *   data: {
     *     // ... data to create a Changeover
     *   }
     * })
     * 
     */
    create<T extends ChangeoverCreateArgs>(args: SelectSubset<T, ChangeoverCreateArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Changeovers.
     * @param {ChangeoverCreateManyArgs} args - Arguments to create many Changeovers.
     * @example
     * // Create many Changeovers
     * const changeover = await prisma.changeover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeoverCreateManyArgs>(args?: SelectSubset<T, ChangeoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Changeovers and returns the data saved in the database.
     * @param {ChangeoverCreateManyAndReturnArgs} args - Arguments to create many Changeovers.
     * @example
     * // Create many Changeovers
     * const changeover = await prisma.changeover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Changeovers and only return the `id`
     * const changeoverWithIdOnly = await prisma.changeover.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeoverCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Changeover.
     * @param {ChangeoverDeleteArgs} args - Arguments to delete one Changeover.
     * @example
     * // Delete one Changeover
     * const Changeover = await prisma.changeover.delete({
     *   where: {
     *     // ... filter to delete one Changeover
     *   }
     * })
     * 
     */
    delete<T extends ChangeoverDeleteArgs>(args: SelectSubset<T, ChangeoverDeleteArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Changeover.
     * @param {ChangeoverUpdateArgs} args - Arguments to update one Changeover.
     * @example
     * // Update one Changeover
     * const changeover = await prisma.changeover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeoverUpdateArgs>(args: SelectSubset<T, ChangeoverUpdateArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Changeovers.
     * @param {ChangeoverDeleteManyArgs} args - Arguments to filter Changeovers to delete.
     * @example
     * // Delete a few Changeovers
     * const { count } = await prisma.changeover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeoverDeleteManyArgs>(args?: SelectSubset<T, ChangeoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Changeovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Changeovers
     * const changeover = await prisma.changeover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeoverUpdateManyArgs>(args: SelectSubset<T, ChangeoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Changeover.
     * @param {ChangeoverUpsertArgs} args - Arguments to update or create a Changeover.
     * @example
     * // Update or create a Changeover
     * const changeover = await prisma.changeover.upsert({
     *   create: {
     *     // ... data to create a Changeover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Changeover we want to update
     *   }
     * })
     */
    upsert<T extends ChangeoverUpsertArgs>(args: SelectSubset<T, ChangeoverUpsertArgs<ExtArgs>>): Prisma__ChangeoverClient<$Result.GetResult<Prisma.$ChangeoverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Changeovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverCountArgs} args - Arguments to filter Changeovers to count.
     * @example
     * // Count the number of Changeovers
     * const count = await prisma.changeover.count({
     *   where: {
     *     // ... the filter for the Changeovers we want to count
     *   }
     * })
    **/
    count<T extends ChangeoverCountArgs>(
      args?: Subset<T, ChangeoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Changeover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeoverAggregateArgs>(args: Subset<T, ChangeoverAggregateArgs>): Prisma.PrismaPromise<GetChangeoverAggregateType<T>>

    /**
     * Group by Changeover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeoverGroupByArgs['orderBy'] }
        : { orderBy?: ChangeoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Changeover model
   */
  readonly fields: ChangeoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Changeover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toBlock<T extends ScheduleBlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleBlockDefaultArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromBlock<T extends ScheduleBlockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleBlockDefaultArgs<ExtArgs>>): Prisma__ScheduleBlockClient<$Result.GetResult<Prisma.$ScheduleBlockPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workcenter<T extends WorkcenterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkcenterDefaultArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Changeover model
   */ 
  interface ChangeoverFieldRefs {
    readonly id: FieldRef<"Changeover", 'Int'>
    readonly workcenterId: FieldRef<"Changeover", 'Int'>
    readonly fromBlockId: FieldRef<"Changeover", 'Int'>
    readonly toBlockId: FieldRef<"Changeover", 'Int'>
    readonly typeCode: FieldRef<"Changeover", 'String'>
    readonly plannedMinutes: FieldRef<"Changeover", 'Int'>
    readonly includeInOee: FieldRef<"Changeover", 'Boolean'>
    readonly complexityTier: FieldRef<"Changeover", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Changeover findUnique
   */
  export type ChangeoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter, which Changeover to fetch.
     */
    where: ChangeoverWhereUniqueInput
  }

  /**
   * Changeover findUniqueOrThrow
   */
  export type ChangeoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter, which Changeover to fetch.
     */
    where: ChangeoverWhereUniqueInput
  }

  /**
   * Changeover findFirst
   */
  export type ChangeoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter, which Changeover to fetch.
     */
    where?: ChangeoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changeovers to fetch.
     */
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changeovers.
     */
    cursor?: ChangeoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changeovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changeovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changeovers.
     */
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * Changeover findFirstOrThrow
   */
  export type ChangeoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter, which Changeover to fetch.
     */
    where?: ChangeoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changeovers to fetch.
     */
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Changeovers.
     */
    cursor?: ChangeoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changeovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changeovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Changeovers.
     */
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * Changeover findMany
   */
  export type ChangeoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter, which Changeovers to fetch.
     */
    where?: ChangeoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Changeovers to fetch.
     */
    orderBy?: ChangeoverOrderByWithRelationInput | ChangeoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Changeovers.
     */
    cursor?: ChangeoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Changeovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Changeovers.
     */
    skip?: number
    distinct?: ChangeoverScalarFieldEnum | ChangeoverScalarFieldEnum[]
  }

  /**
   * Changeover create
   */
  export type ChangeoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * The data needed to create a Changeover.
     */
    data: XOR<ChangeoverCreateInput, ChangeoverUncheckedCreateInput>
  }

  /**
   * Changeover createMany
   */
  export type ChangeoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Changeovers.
     */
    data: ChangeoverCreateManyInput | ChangeoverCreateManyInput[]
  }

  /**
   * Changeover createManyAndReturn
   */
  export type ChangeoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Changeovers.
     */
    data: ChangeoverCreateManyInput | ChangeoverCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Changeover update
   */
  export type ChangeoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * The data needed to update a Changeover.
     */
    data: XOR<ChangeoverUpdateInput, ChangeoverUncheckedUpdateInput>
    /**
     * Choose, which Changeover to update.
     */
    where: ChangeoverWhereUniqueInput
  }

  /**
   * Changeover updateMany
   */
  export type ChangeoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Changeovers.
     */
    data: XOR<ChangeoverUpdateManyMutationInput, ChangeoverUncheckedUpdateManyInput>
    /**
     * Filter which Changeovers to update
     */
    where?: ChangeoverWhereInput
  }

  /**
   * Changeover upsert
   */
  export type ChangeoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * The filter to search for the Changeover to update in case it exists.
     */
    where: ChangeoverWhereUniqueInput
    /**
     * In case the Changeover found by the `where` argument doesn't exist, create a new Changeover with this data.
     */
    create: XOR<ChangeoverCreateInput, ChangeoverUncheckedCreateInput>
    /**
     * In case the Changeover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeoverUpdateInput, ChangeoverUncheckedUpdateInput>
  }

  /**
   * Changeover delete
   */
  export type ChangeoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
    /**
     * Filter which Changeover to delete.
     */
    where: ChangeoverWhereUniqueInput
  }

  /**
   * Changeover deleteMany
   */
  export type ChangeoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Changeovers to delete
     */
    where?: ChangeoverWhereInput
  }

  /**
   * Changeover without action
   */
  export type ChangeoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Changeover
     */
    select?: ChangeoverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeoverInclude<ExtArgs> | null
  }


  /**
   * Model Operator
   */

  export type AggregateOperator = {
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  export type OperatorAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
    basePayRate: number | null
  }

  export type OperatorSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
    basePayRate: number | null
  }

  export type OperatorMinAggregateOutputType = {
    id: number | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    hireDate: Date | null
    departmentId: number | null
    isActive: boolean | null
    basePayRate: number | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorMaxAggregateOutputType = {
    id: number | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    hireDate: Date | null
    departmentId: number | null
    isActive: boolean | null
    basePayRate: number | null
    emergencyContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorCountAggregateOutputType = {
    id: number
    employeeId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    hireDate: number
    departmentId: number
    isActive: number
    basePayRate: number
    emergencyContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatorAvgAggregateInputType = {
    id?: true
    departmentId?: true
    basePayRate?: true
  }

  export type OperatorSumAggregateInputType = {
    id?: true
    departmentId?: true
    basePayRate?: true
  }

  export type OperatorMinAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    hireDate?: true
    departmentId?: true
    isActive?: true
    basePayRate?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorMaxAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    hireDate?: true
    departmentId?: true
    isActive?: true
    basePayRate?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorCountAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    hireDate?: true
    departmentId?: true
    isActive?: true
    basePayRate?: true
    emergencyContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operator to aggregate.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operators
    **/
    _count?: true | OperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorMaxAggregateInputType
  }

  export type GetOperatorAggregateType<T extends OperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator[P]>
      : GetScalarType<T[P], AggregateOperator[P]>
  }




  export type OperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithAggregationInput | OperatorOrderByWithAggregationInput[]
    by: OperatorScalarFieldEnum[] | OperatorScalarFieldEnum
    having?: OperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCountAggregateInputType | true
    _avg?: OperatorAvgAggregateInputType
    _sum?: OperatorSumAggregateInputType
    _min?: OperatorMinAggregateInputType
    _max?: OperatorMaxAggregateInputType
  }

  export type OperatorGroupByOutputType = {
    id: number
    employeeId: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    hireDate: Date
    departmentId: number | null
    isActive: boolean
    basePayRate: number | null
    emergencyContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  type GetOperatorGroupByPayload<T extends OperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorGroupByOutputType[P]>
        }
      >
    >


  export type OperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    hireDate?: boolean
    departmentId?: boolean
    isActive?: boolean
    basePayRate?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Operator$departmentArgs<ExtArgs>
    competencies?: boolean | Operator$competenciesArgs<ExtArgs>
    shiftAssignments?: boolean | Operator$shiftAssignmentsArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    hireDate?: boolean
    departmentId?: boolean
    isActive?: boolean
    basePayRate?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Operator$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectScalar = {
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    hireDate?: boolean
    departmentId?: boolean
    isActive?: boolean
    basePayRate?: boolean
    emergencyContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Operator$departmentArgs<ExtArgs>
    competencies?: boolean | Operator$competenciesArgs<ExtArgs>
    shiftAssignments?: boolean | Operator$shiftAssignmentsArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Operator$departmentArgs<ExtArgs>
  }

  export type $OperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operator"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      competencies: Prisma.$OperatorCompetencyPayload<ExtArgs>[]
      shiftAssignments: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      hireDate: Date
      departmentId: number | null
      isActive: boolean
      basePayRate: number | null
      emergencyContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operator"]>
    composites: {}
  }

  type OperatorGetPayload<S extends boolean | null | undefined | OperatorDefaultArgs> = $Result.GetResult<Prisma.$OperatorPayload, S>

  type OperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperatorCountAggregateInputType | true
    }

  export interface OperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operator'], meta: { name: 'Operator' } }
    /**
     * Find zero or one Operator that matches the filter.
     * @param {OperatorFindUniqueArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorFindUniqueArgs>(args: SelectSubset<T, OperatorFindUniqueArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Operator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperatorFindUniqueOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorFindFirstArgs>(args?: SelectSubset<T, OperatorFindFirstArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operator.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorWithIdOnly = await prisma.operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorFindManyArgs>(args?: SelectSubset<T, OperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Operator.
     * @param {OperatorCreateArgs} args - Arguments to create a Operator.
     * @example
     * // Create one Operator
     * const Operator = await prisma.operator.create({
     *   data: {
     *     // ... data to create a Operator
     *   }
     * })
     * 
     */
    create<T extends OperatorCreateArgs>(args: SelectSubset<T, OperatorCreateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Operators.
     * @param {OperatorCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorCreateManyArgs>(args?: SelectSubset<T, OperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {OperatorCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Operator.
     * @param {OperatorDeleteArgs} args - Arguments to delete one Operator.
     * @example
     * // Delete one Operator
     * const Operator = await prisma.operator.delete({
     *   where: {
     *     // ... filter to delete one Operator
     *   }
     * })
     * 
     */
    delete<T extends OperatorDeleteArgs>(args: SelectSubset<T, OperatorDeleteArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Operator.
     * @param {OperatorUpdateArgs} args - Arguments to update one Operator.
     * @example
     * // Update one Operator
     * const operator = await prisma.operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorUpdateArgs>(args: SelectSubset<T, OperatorUpdateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Operators.
     * @param {OperatorDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorDeleteManyArgs>(args?: SelectSubset<T, OperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorUpdateManyArgs>(args: SelectSubset<T, OperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operator.
     * @param {OperatorUpsertArgs} args - Arguments to update or create a Operator.
     * @example
     * // Update or create a Operator
     * const operator = await prisma.operator.upsert({
     *   create: {
     *     // ... data to create a Operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator we want to update
     *   }
     * })
     */
    upsert<T extends OperatorUpsertArgs>(args: SelectSubset<T, OperatorUpsertArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operator.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends OperatorCountArgs>(
      args?: Subset<T, OperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorAggregateArgs>(args: Subset<T, OperatorAggregateArgs>): Prisma.PrismaPromise<GetOperatorAggregateType<T>>

    /**
     * Group by Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorGroupByArgs['orderBy'] }
        : { orderBy?: OperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operator model
   */
  readonly fields: OperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Operator$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Operator$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    competencies<T extends Operator$competenciesArgs<ExtArgs> = {}>(args?: Subset<T, Operator$competenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findMany"> | Null>
    shiftAssignments<T extends Operator$shiftAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Operator$shiftAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operator model
   */ 
  interface OperatorFieldRefs {
    readonly id: FieldRef<"Operator", 'Int'>
    readonly employeeId: FieldRef<"Operator", 'String'>
    readonly firstName: FieldRef<"Operator", 'String'>
    readonly lastName: FieldRef<"Operator", 'String'>
    readonly email: FieldRef<"Operator", 'String'>
    readonly phone: FieldRef<"Operator", 'String'>
    readonly hireDate: FieldRef<"Operator", 'DateTime'>
    readonly departmentId: FieldRef<"Operator", 'Int'>
    readonly isActive: FieldRef<"Operator", 'Boolean'>
    readonly basePayRate: FieldRef<"Operator", 'Float'>
    readonly emergencyContact: FieldRef<"Operator", 'String'>
    readonly createdAt: FieldRef<"Operator", 'DateTime'>
    readonly updatedAt: FieldRef<"Operator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Operator findUnique
   */
  export type OperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findUniqueOrThrow
   */
  export type OperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findFirst
   */
  export type OperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findFirstOrThrow
   */
  export type OperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findMany
   */
  export type OperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operators to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator create
   */
  export type OperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Operator.
     */
    data: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
  }

  /**
   * Operator createMany
   */
  export type OperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
  }

  /**
   * Operator createManyAndReturn
   */
  export type OperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operator update
   */
  export type OperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Operator.
     */
    data: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
    /**
     * Choose, which Operator to update.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator updateMany
   */
  export type OperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
  }

  /**
   * Operator upsert
   */
  export type OperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Operator to update in case it exists.
     */
    where: OperatorWhereUniqueInput
    /**
     * In case the Operator found by the `where` argument doesn't exist, create a new Operator with this data.
     */
    create: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
    /**
     * In case the Operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
  }

  /**
   * Operator delete
   */
  export type OperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter which Operator to delete.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator deleteMany
   */
  export type OperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operators to delete
     */
    where?: OperatorWhereInput
  }

  /**
   * Operator.department
   */
  export type Operator$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Operator.competencies
   */
  export type Operator$competenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    where?: OperatorCompetencyWhereInput
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    cursor?: OperatorCompetencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorCompetencyScalarFieldEnum | OperatorCompetencyScalarFieldEnum[]
  }

  /**
   * Operator.shiftAssignments
   */
  export type Operator$shiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * Operator without action
   */
  export type OperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillAvgAggregateOutputType = {
    id: number | null
    expiryMonths: number | null
  }

  export type SkillSumAggregateOutputType = {
    id: number | null
    expiryMonths: number | null
  }

  export type SkillMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    category: string | null
    isCore: boolean | null
    isCertification: boolean | null
    expiryMonths: number | null
    createdAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    category: string | null
    isCore: boolean | null
    isCertification: boolean | null
    expiryMonths: number | null
    createdAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    category: number
    isCore: number
    isCertification: number
    expiryMonths: number
    createdAt: number
    _all: number
  }


  export type SkillAvgAggregateInputType = {
    id?: true
    expiryMonths?: true
  }

  export type SkillSumAggregateInputType = {
    id?: true
    expiryMonths?: true
  }

  export type SkillMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isCore?: true
    isCertification?: true
    expiryMonths?: true
    createdAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isCore?: true
    isCertification?: true
    expiryMonths?: true
    createdAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isCore?: true
    isCertification?: true
    expiryMonths?: true
    createdAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _avg?: SkillAvgAggregateInputType
    _sum?: SkillSumAggregateInputType
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    category: string
    isCore: boolean
    isCertification: boolean
    expiryMonths: number | null
    createdAt: Date
    _count: SkillCountAggregateOutputType | null
    _avg: SkillAvgAggregateOutputType | null
    _sum: SkillSumAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
    competencies?: boolean | Skill$competenciesArgs<ExtArgs>
    skillRequirements?: boolean | Skill$skillRequirementsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: boolean
    createdAt?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    competencies?: boolean | Skill$competenciesArgs<ExtArgs>
    skillRequirements?: boolean | Skill$skillRequirementsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      competencies: Prisma.$OperatorCompetencyPayload<ExtArgs>[]
      skillRequirements: Prisma.$SkillRequirementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      category: string
      isCore: boolean
      isCertification: boolean
      expiryMonths: number | null
      createdAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    competencies<T extends Skill$competenciesArgs<ExtArgs> = {}>(args?: Subset<T, Skill$competenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findMany"> | Null>
    skillRequirements<T extends Skill$skillRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$skillRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'Int'>
    readonly code: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly isCore: FieldRef<"Skill", 'Boolean'>
    readonly isCertification: FieldRef<"Skill", 'Boolean'>
    readonly expiryMonths: FieldRef<"Skill", 'Int'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }

  /**
   * Skill.competencies
   */
  export type Skill$competenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    where?: OperatorCompetencyWhereInput
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    cursor?: OperatorCompetencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorCompetencyScalarFieldEnum | OperatorCompetencyScalarFieldEnum[]
  }

  /**
   * Skill.skillRequirements
   */
  export type Skill$skillRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    where?: SkillRequirementWhereInput
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    cursor?: SkillRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillRequirementScalarFieldEnum | SkillRequirementScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model OperatorCompetency
   */

  export type AggregateOperatorCompetency = {
    _count: OperatorCompetencyCountAggregateOutputType | null
    _avg: OperatorCompetencyAvgAggregateOutputType | null
    _sum: OperatorCompetencySumAggregateOutputType | null
    _min: OperatorCompetencyMinAggregateOutputType | null
    _max: OperatorCompetencyMaxAggregateOutputType | null
  }

  export type OperatorCompetencyAvgAggregateOutputType = {
    id: number | null
    operatorId: number | null
    skillId: number | null
    level: number | null
  }

  export type OperatorCompetencySumAggregateOutputType = {
    id: number | null
    operatorId: number | null
    skillId: number | null
    level: number | null
  }

  export type OperatorCompetencyMinAggregateOutputType = {
    id: number | null
    operatorId: number | null
    skillId: number | null
    level: number | null
    certifiedAt: Date | null
    expiresAt: Date | null
    certifiedBy: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorCompetencyMaxAggregateOutputType = {
    id: number | null
    operatorId: number | null
    skillId: number | null
    level: number | null
    certifiedAt: Date | null
    expiresAt: Date | null
    certifiedBy: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorCompetencyCountAggregateOutputType = {
    id: number
    operatorId: number
    skillId: number
    level: number
    certifiedAt: number
    expiresAt: number
    certifiedBy: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatorCompetencyAvgAggregateInputType = {
    id?: true
    operatorId?: true
    skillId?: true
    level?: true
  }

  export type OperatorCompetencySumAggregateInputType = {
    id?: true
    operatorId?: true
    skillId?: true
    level?: true
  }

  export type OperatorCompetencyMinAggregateInputType = {
    id?: true
    operatorId?: true
    skillId?: true
    level?: true
    certifiedAt?: true
    expiresAt?: true
    certifiedBy?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorCompetencyMaxAggregateInputType = {
    id?: true
    operatorId?: true
    skillId?: true
    level?: true
    certifiedAt?: true
    expiresAt?: true
    certifiedBy?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorCompetencyCountAggregateInputType = {
    id?: true
    operatorId?: true
    skillId?: true
    level?: true
    certifiedAt?: true
    expiresAt?: true
    certifiedBy?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatorCompetencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatorCompetency to aggregate.
     */
    where?: OperatorCompetencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatorCompetencies to fetch.
     */
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorCompetencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatorCompetencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatorCompetencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperatorCompetencies
    **/
    _count?: true | OperatorCompetencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorCompetencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorCompetencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorCompetencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorCompetencyMaxAggregateInputType
  }

  export type GetOperatorCompetencyAggregateType<T extends OperatorCompetencyAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatorCompetency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatorCompetency[P]>
      : GetScalarType<T[P], AggregateOperatorCompetency[P]>
  }




  export type OperatorCompetencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorCompetencyWhereInput
    orderBy?: OperatorCompetencyOrderByWithAggregationInput | OperatorCompetencyOrderByWithAggregationInput[]
    by: OperatorCompetencyScalarFieldEnum[] | OperatorCompetencyScalarFieldEnum
    having?: OperatorCompetencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCompetencyCountAggregateInputType | true
    _avg?: OperatorCompetencyAvgAggregateInputType
    _sum?: OperatorCompetencySumAggregateInputType
    _min?: OperatorCompetencyMinAggregateInputType
    _max?: OperatorCompetencyMaxAggregateInputType
  }

  export type OperatorCompetencyGroupByOutputType = {
    id: number
    operatorId: number
    skillId: number
    level: number
    certifiedAt: Date | null
    expiresAt: Date | null
    certifiedBy: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OperatorCompetencyCountAggregateOutputType | null
    _avg: OperatorCompetencyAvgAggregateOutputType | null
    _sum: OperatorCompetencySumAggregateOutputType | null
    _min: OperatorCompetencyMinAggregateOutputType | null
    _max: OperatorCompetencyMaxAggregateOutputType | null
  }

  type GetOperatorCompetencyGroupByPayload<T extends OperatorCompetencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorCompetencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorCompetencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorCompetencyGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorCompetencyGroupByOutputType[P]>
        }
      >
    >


  export type OperatorCompetencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    skillId?: boolean
    level?: boolean
    certifiedAt?: boolean
    expiresAt?: boolean
    certifiedBy?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatorCompetency"]>

  export type OperatorCompetencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    skillId?: boolean
    level?: boolean
    certifiedAt?: boolean
    expiresAt?: boolean
    certifiedBy?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatorCompetency"]>

  export type OperatorCompetencySelectScalar = {
    id?: boolean
    operatorId?: boolean
    skillId?: boolean
    level?: boolean
    certifiedAt?: boolean
    expiresAt?: boolean
    certifiedBy?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatorCompetencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }
  export type OperatorCompetencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }

  export type $OperatorCompetencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperatorCompetency"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
      operator: Prisma.$OperatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operatorId: number
      skillId: number
      level: number
      certifiedAt: Date | null
      expiresAt: Date | null
      certifiedBy: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operatorCompetency"]>
    composites: {}
  }

  type OperatorCompetencyGetPayload<S extends boolean | null | undefined | OperatorCompetencyDefaultArgs> = $Result.GetResult<Prisma.$OperatorCompetencyPayload, S>

  type OperatorCompetencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperatorCompetencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperatorCompetencyCountAggregateInputType | true
    }

  export interface OperatorCompetencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperatorCompetency'], meta: { name: 'OperatorCompetency' } }
    /**
     * Find zero or one OperatorCompetency that matches the filter.
     * @param {OperatorCompetencyFindUniqueArgs} args - Arguments to find a OperatorCompetency
     * @example
     * // Get one OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorCompetencyFindUniqueArgs>(args: SelectSubset<T, OperatorCompetencyFindUniqueArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperatorCompetency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperatorCompetencyFindUniqueOrThrowArgs} args - Arguments to find a OperatorCompetency
     * @example
     * // Get one OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorCompetencyFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorCompetencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperatorCompetency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyFindFirstArgs} args - Arguments to find a OperatorCompetency
     * @example
     * // Get one OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorCompetencyFindFirstArgs>(args?: SelectSubset<T, OperatorCompetencyFindFirstArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperatorCompetency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyFindFirstOrThrowArgs} args - Arguments to find a OperatorCompetency
     * @example
     * // Get one OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorCompetencyFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorCompetencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperatorCompetencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperatorCompetencies
     * const operatorCompetencies = await prisma.operatorCompetency.findMany()
     * 
     * // Get first 10 OperatorCompetencies
     * const operatorCompetencies = await prisma.operatorCompetency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorCompetencyWithIdOnly = await prisma.operatorCompetency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorCompetencyFindManyArgs>(args?: SelectSubset<T, OperatorCompetencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperatorCompetency.
     * @param {OperatorCompetencyCreateArgs} args - Arguments to create a OperatorCompetency.
     * @example
     * // Create one OperatorCompetency
     * const OperatorCompetency = await prisma.operatorCompetency.create({
     *   data: {
     *     // ... data to create a OperatorCompetency
     *   }
     * })
     * 
     */
    create<T extends OperatorCompetencyCreateArgs>(args: SelectSubset<T, OperatorCompetencyCreateArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperatorCompetencies.
     * @param {OperatorCompetencyCreateManyArgs} args - Arguments to create many OperatorCompetencies.
     * @example
     * // Create many OperatorCompetencies
     * const operatorCompetency = await prisma.operatorCompetency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorCompetencyCreateManyArgs>(args?: SelectSubset<T, OperatorCompetencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperatorCompetencies and returns the data saved in the database.
     * @param {OperatorCompetencyCreateManyAndReturnArgs} args - Arguments to create many OperatorCompetencies.
     * @example
     * // Create many OperatorCompetencies
     * const operatorCompetency = await prisma.operatorCompetency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperatorCompetencies and only return the `id`
     * const operatorCompetencyWithIdOnly = await prisma.operatorCompetency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorCompetencyCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorCompetencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OperatorCompetency.
     * @param {OperatorCompetencyDeleteArgs} args - Arguments to delete one OperatorCompetency.
     * @example
     * // Delete one OperatorCompetency
     * const OperatorCompetency = await prisma.operatorCompetency.delete({
     *   where: {
     *     // ... filter to delete one OperatorCompetency
     *   }
     * })
     * 
     */
    delete<T extends OperatorCompetencyDeleteArgs>(args: SelectSubset<T, OperatorCompetencyDeleteArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperatorCompetency.
     * @param {OperatorCompetencyUpdateArgs} args - Arguments to update one OperatorCompetency.
     * @example
     * // Update one OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorCompetencyUpdateArgs>(args: SelectSubset<T, OperatorCompetencyUpdateArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperatorCompetencies.
     * @param {OperatorCompetencyDeleteManyArgs} args - Arguments to filter OperatorCompetencies to delete.
     * @example
     * // Delete a few OperatorCompetencies
     * const { count } = await prisma.operatorCompetency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorCompetencyDeleteManyArgs>(args?: SelectSubset<T, OperatorCompetencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperatorCompetencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperatorCompetencies
     * const operatorCompetency = await prisma.operatorCompetency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorCompetencyUpdateManyArgs>(args: SelectSubset<T, OperatorCompetencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperatorCompetency.
     * @param {OperatorCompetencyUpsertArgs} args - Arguments to update or create a OperatorCompetency.
     * @example
     * // Update or create a OperatorCompetency
     * const operatorCompetency = await prisma.operatorCompetency.upsert({
     *   create: {
     *     // ... data to create a OperatorCompetency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperatorCompetency we want to update
     *   }
     * })
     */
    upsert<T extends OperatorCompetencyUpsertArgs>(args: SelectSubset<T, OperatorCompetencyUpsertArgs<ExtArgs>>): Prisma__OperatorCompetencyClient<$Result.GetResult<Prisma.$OperatorCompetencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperatorCompetencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyCountArgs} args - Arguments to filter OperatorCompetencies to count.
     * @example
     * // Count the number of OperatorCompetencies
     * const count = await prisma.operatorCompetency.count({
     *   where: {
     *     // ... the filter for the OperatorCompetencies we want to count
     *   }
     * })
    **/
    count<T extends OperatorCompetencyCountArgs>(
      args?: Subset<T, OperatorCompetencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCompetencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperatorCompetency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorCompetencyAggregateArgs>(args: Subset<T, OperatorCompetencyAggregateArgs>): Prisma.PrismaPromise<GetOperatorCompetencyAggregateType<T>>

    /**
     * Group by OperatorCompetency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCompetencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorCompetencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorCompetencyGroupByArgs['orderBy'] }
        : { orderBy?: OperatorCompetencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorCompetencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorCompetencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperatorCompetency model
   */
  readonly fields: OperatorCompetencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperatorCompetency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorCompetencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperatorCompetency model
   */ 
  interface OperatorCompetencyFieldRefs {
    readonly id: FieldRef<"OperatorCompetency", 'Int'>
    readonly operatorId: FieldRef<"OperatorCompetency", 'Int'>
    readonly skillId: FieldRef<"OperatorCompetency", 'Int'>
    readonly level: FieldRef<"OperatorCompetency", 'Int'>
    readonly certifiedAt: FieldRef<"OperatorCompetency", 'DateTime'>
    readonly expiresAt: FieldRef<"OperatorCompetency", 'DateTime'>
    readonly certifiedBy: FieldRef<"OperatorCompetency", 'String'>
    readonly notes: FieldRef<"OperatorCompetency", 'String'>
    readonly isActive: FieldRef<"OperatorCompetency", 'Boolean'>
    readonly createdAt: FieldRef<"OperatorCompetency", 'DateTime'>
    readonly updatedAt: FieldRef<"OperatorCompetency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperatorCompetency findUnique
   */
  export type OperatorCompetencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter, which OperatorCompetency to fetch.
     */
    where: OperatorCompetencyWhereUniqueInput
  }

  /**
   * OperatorCompetency findUniqueOrThrow
   */
  export type OperatorCompetencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter, which OperatorCompetency to fetch.
     */
    where: OperatorCompetencyWhereUniqueInput
  }

  /**
   * OperatorCompetency findFirst
   */
  export type OperatorCompetencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter, which OperatorCompetency to fetch.
     */
    where?: OperatorCompetencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatorCompetencies to fetch.
     */
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatorCompetencies.
     */
    cursor?: OperatorCompetencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatorCompetencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatorCompetencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatorCompetencies.
     */
    distinct?: OperatorCompetencyScalarFieldEnum | OperatorCompetencyScalarFieldEnum[]
  }

  /**
   * OperatorCompetency findFirstOrThrow
   */
  export type OperatorCompetencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter, which OperatorCompetency to fetch.
     */
    where?: OperatorCompetencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatorCompetencies to fetch.
     */
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperatorCompetencies.
     */
    cursor?: OperatorCompetencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatorCompetencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatorCompetencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperatorCompetencies.
     */
    distinct?: OperatorCompetencyScalarFieldEnum | OperatorCompetencyScalarFieldEnum[]
  }

  /**
   * OperatorCompetency findMany
   */
  export type OperatorCompetencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter, which OperatorCompetencies to fetch.
     */
    where?: OperatorCompetencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperatorCompetencies to fetch.
     */
    orderBy?: OperatorCompetencyOrderByWithRelationInput | OperatorCompetencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperatorCompetencies.
     */
    cursor?: OperatorCompetencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperatorCompetencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperatorCompetencies.
     */
    skip?: number
    distinct?: OperatorCompetencyScalarFieldEnum | OperatorCompetencyScalarFieldEnum[]
  }

  /**
   * OperatorCompetency create
   */
  export type OperatorCompetencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * The data needed to create a OperatorCompetency.
     */
    data: XOR<OperatorCompetencyCreateInput, OperatorCompetencyUncheckedCreateInput>
  }

  /**
   * OperatorCompetency createMany
   */
  export type OperatorCompetencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperatorCompetencies.
     */
    data: OperatorCompetencyCreateManyInput | OperatorCompetencyCreateManyInput[]
  }

  /**
   * OperatorCompetency createManyAndReturn
   */
  export type OperatorCompetencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperatorCompetencies.
     */
    data: OperatorCompetencyCreateManyInput | OperatorCompetencyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperatorCompetency update
   */
  export type OperatorCompetencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * The data needed to update a OperatorCompetency.
     */
    data: XOR<OperatorCompetencyUpdateInput, OperatorCompetencyUncheckedUpdateInput>
    /**
     * Choose, which OperatorCompetency to update.
     */
    where: OperatorCompetencyWhereUniqueInput
  }

  /**
   * OperatorCompetency updateMany
   */
  export type OperatorCompetencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperatorCompetencies.
     */
    data: XOR<OperatorCompetencyUpdateManyMutationInput, OperatorCompetencyUncheckedUpdateManyInput>
    /**
     * Filter which OperatorCompetencies to update
     */
    where?: OperatorCompetencyWhereInput
  }

  /**
   * OperatorCompetency upsert
   */
  export type OperatorCompetencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * The filter to search for the OperatorCompetency to update in case it exists.
     */
    where: OperatorCompetencyWhereUniqueInput
    /**
     * In case the OperatorCompetency found by the `where` argument doesn't exist, create a new OperatorCompetency with this data.
     */
    create: XOR<OperatorCompetencyCreateInput, OperatorCompetencyUncheckedCreateInput>
    /**
     * In case the OperatorCompetency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorCompetencyUpdateInput, OperatorCompetencyUncheckedUpdateInput>
  }

  /**
   * OperatorCompetency delete
   */
  export type OperatorCompetencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
    /**
     * Filter which OperatorCompetency to delete.
     */
    where: OperatorCompetencyWhereUniqueInput
  }

  /**
   * OperatorCompetency deleteMany
   */
  export type OperatorCompetencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperatorCompetencies to delete
     */
    where?: OperatorCompetencyWhereInput
  }

  /**
   * OperatorCompetency without action
   */
  export type OperatorCompetencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCompetency
     */
    select?: OperatorCompetencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorCompetencyInclude<ExtArgs> | null
  }


  /**
   * Model SkillRequirement
   */

  export type AggregateSkillRequirement = {
    _count: SkillRequirementCountAggregateOutputType | null
    _avg: SkillRequirementAvgAggregateOutputType | null
    _sum: SkillRequirementSumAggregateOutputType | null
    _min: SkillRequirementMinAggregateOutputType | null
    _max: SkillRequirementMaxAggregateOutputType | null
  }

  export type SkillRequirementAvgAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    skillId: number | null
    minLevel: number | null
  }

  export type SkillRequirementSumAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    skillId: number | null
    minLevel: number | null
  }

  export type SkillRequirementMinAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    skillId: number | null
    minLevel: number | null
    isRequired: boolean | null
    shiftType: string | null
    createdAt: Date | null
  }

  export type SkillRequirementMaxAggregateOutputType = {
    id: number | null
    workcenterId: number | null
    skillId: number | null
    minLevel: number | null
    isRequired: boolean | null
    shiftType: string | null
    createdAt: Date | null
  }

  export type SkillRequirementCountAggregateOutputType = {
    id: number
    workcenterId: number
    skillId: number
    minLevel: number
    isRequired: number
    shiftType: number
    createdAt: number
    _all: number
  }


  export type SkillRequirementAvgAggregateInputType = {
    id?: true
    workcenterId?: true
    skillId?: true
    minLevel?: true
  }

  export type SkillRequirementSumAggregateInputType = {
    id?: true
    workcenterId?: true
    skillId?: true
    minLevel?: true
  }

  export type SkillRequirementMinAggregateInputType = {
    id?: true
    workcenterId?: true
    skillId?: true
    minLevel?: true
    isRequired?: true
    shiftType?: true
    createdAt?: true
  }

  export type SkillRequirementMaxAggregateInputType = {
    id?: true
    workcenterId?: true
    skillId?: true
    minLevel?: true
    isRequired?: true
    shiftType?: true
    createdAt?: true
  }

  export type SkillRequirementCountAggregateInputType = {
    id?: true
    workcenterId?: true
    skillId?: true
    minLevel?: true
    isRequired?: true
    shiftType?: true
    createdAt?: true
    _all?: true
  }

  export type SkillRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillRequirement to aggregate.
     */
    where?: SkillRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillRequirements to fetch.
     */
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillRequirements
    **/
    _count?: true | SkillRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillRequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillRequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillRequirementMaxAggregateInputType
  }

  export type GetSkillRequirementAggregateType<T extends SkillRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillRequirement[P]>
      : GetScalarType<T[P], AggregateSkillRequirement[P]>
  }




  export type SkillRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillRequirementWhereInput
    orderBy?: SkillRequirementOrderByWithAggregationInput | SkillRequirementOrderByWithAggregationInput[]
    by: SkillRequirementScalarFieldEnum[] | SkillRequirementScalarFieldEnum
    having?: SkillRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillRequirementCountAggregateInputType | true
    _avg?: SkillRequirementAvgAggregateInputType
    _sum?: SkillRequirementSumAggregateInputType
    _min?: SkillRequirementMinAggregateInputType
    _max?: SkillRequirementMaxAggregateInputType
  }

  export type SkillRequirementGroupByOutputType = {
    id: number
    workcenterId: number
    skillId: number
    minLevel: number
    isRequired: boolean
    shiftType: string | null
    createdAt: Date
    _count: SkillRequirementCountAggregateOutputType | null
    _avg: SkillRequirementAvgAggregateOutputType | null
    _sum: SkillRequirementSumAggregateOutputType | null
    _min: SkillRequirementMinAggregateOutputType | null
    _max: SkillRequirementMaxAggregateOutputType | null
  }

  type GetSkillRequirementGroupByPayload<T extends SkillRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], SkillRequirementGroupByOutputType[P]>
        }
      >
    >


  export type SkillRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    skillId?: boolean
    minLevel?: boolean
    isRequired?: boolean
    shiftType?: boolean
    createdAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillRequirement"]>

  export type SkillRequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workcenterId?: boolean
    skillId?: boolean
    minLevel?: boolean
    isRequired?: boolean
    shiftType?: boolean
    createdAt?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillRequirement"]>

  export type SkillRequirementSelectScalar = {
    id?: boolean
    workcenterId?: boolean
    skillId?: boolean
    minLevel?: boolean
    isRequired?: boolean
    shiftType?: boolean
    createdAt?: boolean
  }

  export type SkillRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }
  export type SkillRequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
  }

  export type $SkillRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillRequirement"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
      workcenter: Prisma.$WorkcenterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workcenterId: number
      skillId: number
      minLevel: number
      isRequired: boolean
      shiftType: string | null
      createdAt: Date
    }, ExtArgs["result"]["skillRequirement"]>
    composites: {}
  }

  type SkillRequirementGetPayload<S extends boolean | null | undefined | SkillRequirementDefaultArgs> = $Result.GetResult<Prisma.$SkillRequirementPayload, S>

  type SkillRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillRequirementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillRequirementCountAggregateInputType | true
    }

  export interface SkillRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillRequirement'], meta: { name: 'SkillRequirement' } }
    /**
     * Find zero or one SkillRequirement that matches the filter.
     * @param {SkillRequirementFindUniqueArgs} args - Arguments to find a SkillRequirement
     * @example
     * // Get one SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillRequirementFindUniqueArgs>(args: SelectSubset<T, SkillRequirementFindUniqueArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkillRequirement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillRequirementFindUniqueOrThrowArgs} args - Arguments to find a SkillRequirement
     * @example
     * // Get one SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkillRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementFindFirstArgs} args - Arguments to find a SkillRequirement
     * @example
     * // Get one SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillRequirementFindFirstArgs>(args?: SelectSubset<T, SkillRequirementFindFirstArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkillRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementFindFirstOrThrowArgs} args - Arguments to find a SkillRequirement
     * @example
     * // Get one SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkillRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillRequirements
     * const skillRequirements = await prisma.skillRequirement.findMany()
     * 
     * // Get first 10 SkillRequirements
     * const skillRequirements = await prisma.skillRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillRequirementWithIdOnly = await prisma.skillRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillRequirementFindManyArgs>(args?: SelectSubset<T, SkillRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkillRequirement.
     * @param {SkillRequirementCreateArgs} args - Arguments to create a SkillRequirement.
     * @example
     * // Create one SkillRequirement
     * const SkillRequirement = await prisma.skillRequirement.create({
     *   data: {
     *     // ... data to create a SkillRequirement
     *   }
     * })
     * 
     */
    create<T extends SkillRequirementCreateArgs>(args: SelectSubset<T, SkillRequirementCreateArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkillRequirements.
     * @param {SkillRequirementCreateManyArgs} args - Arguments to create many SkillRequirements.
     * @example
     * // Create many SkillRequirements
     * const skillRequirement = await prisma.skillRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillRequirementCreateManyArgs>(args?: SelectSubset<T, SkillRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillRequirements and returns the data saved in the database.
     * @param {SkillRequirementCreateManyAndReturnArgs} args - Arguments to create many SkillRequirements.
     * @example
     * // Create many SkillRequirements
     * const skillRequirement = await prisma.skillRequirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillRequirements and only return the `id`
     * const skillRequirementWithIdOnly = await prisma.skillRequirement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillRequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillRequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkillRequirement.
     * @param {SkillRequirementDeleteArgs} args - Arguments to delete one SkillRequirement.
     * @example
     * // Delete one SkillRequirement
     * const SkillRequirement = await prisma.skillRequirement.delete({
     *   where: {
     *     // ... filter to delete one SkillRequirement
     *   }
     * })
     * 
     */
    delete<T extends SkillRequirementDeleteArgs>(args: SelectSubset<T, SkillRequirementDeleteArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkillRequirement.
     * @param {SkillRequirementUpdateArgs} args - Arguments to update one SkillRequirement.
     * @example
     * // Update one SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillRequirementUpdateArgs>(args: SelectSubset<T, SkillRequirementUpdateArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkillRequirements.
     * @param {SkillRequirementDeleteManyArgs} args - Arguments to filter SkillRequirements to delete.
     * @example
     * // Delete a few SkillRequirements
     * const { count } = await prisma.skillRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillRequirementDeleteManyArgs>(args?: SelectSubset<T, SkillRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillRequirements
     * const skillRequirement = await prisma.skillRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillRequirementUpdateManyArgs>(args: SelectSubset<T, SkillRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkillRequirement.
     * @param {SkillRequirementUpsertArgs} args - Arguments to update or create a SkillRequirement.
     * @example
     * // Update or create a SkillRequirement
     * const skillRequirement = await prisma.skillRequirement.upsert({
     *   create: {
     *     // ... data to create a SkillRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillRequirement we want to update
     *   }
     * })
     */
    upsert<T extends SkillRequirementUpsertArgs>(args: SelectSubset<T, SkillRequirementUpsertArgs<ExtArgs>>): Prisma__SkillRequirementClient<$Result.GetResult<Prisma.$SkillRequirementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkillRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementCountArgs} args - Arguments to filter SkillRequirements to count.
     * @example
     * // Count the number of SkillRequirements
     * const count = await prisma.skillRequirement.count({
     *   where: {
     *     // ... the filter for the SkillRequirements we want to count
     *   }
     * })
    **/
    count<T extends SkillRequirementCountArgs>(
      args?: Subset<T, SkillRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillRequirementAggregateArgs>(args: Subset<T, SkillRequirementAggregateArgs>): Prisma.PrismaPromise<GetSkillRequirementAggregateType<T>>

    /**
     * Group by SkillRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillRequirementGroupByArgs['orderBy'] }
        : { orderBy?: SkillRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillRequirement model
   */
  readonly fields: SkillRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workcenter<T extends WorkcenterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkcenterDefaultArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillRequirement model
   */ 
  interface SkillRequirementFieldRefs {
    readonly id: FieldRef<"SkillRequirement", 'Int'>
    readonly workcenterId: FieldRef<"SkillRequirement", 'Int'>
    readonly skillId: FieldRef<"SkillRequirement", 'Int'>
    readonly minLevel: FieldRef<"SkillRequirement", 'Int'>
    readonly isRequired: FieldRef<"SkillRequirement", 'Boolean'>
    readonly shiftType: FieldRef<"SkillRequirement", 'String'>
    readonly createdAt: FieldRef<"SkillRequirement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillRequirement findUnique
   */
  export type SkillRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter, which SkillRequirement to fetch.
     */
    where: SkillRequirementWhereUniqueInput
  }

  /**
   * SkillRequirement findUniqueOrThrow
   */
  export type SkillRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter, which SkillRequirement to fetch.
     */
    where: SkillRequirementWhereUniqueInput
  }

  /**
   * SkillRequirement findFirst
   */
  export type SkillRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter, which SkillRequirement to fetch.
     */
    where?: SkillRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillRequirements to fetch.
     */
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillRequirements.
     */
    cursor?: SkillRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillRequirements.
     */
    distinct?: SkillRequirementScalarFieldEnum | SkillRequirementScalarFieldEnum[]
  }

  /**
   * SkillRequirement findFirstOrThrow
   */
  export type SkillRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter, which SkillRequirement to fetch.
     */
    where?: SkillRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillRequirements to fetch.
     */
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillRequirements.
     */
    cursor?: SkillRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillRequirements.
     */
    distinct?: SkillRequirementScalarFieldEnum | SkillRequirementScalarFieldEnum[]
  }

  /**
   * SkillRequirement findMany
   */
  export type SkillRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter, which SkillRequirements to fetch.
     */
    where?: SkillRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillRequirements to fetch.
     */
    orderBy?: SkillRequirementOrderByWithRelationInput | SkillRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillRequirements.
     */
    cursor?: SkillRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillRequirements.
     */
    skip?: number
    distinct?: SkillRequirementScalarFieldEnum | SkillRequirementScalarFieldEnum[]
  }

  /**
   * SkillRequirement create
   */
  export type SkillRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillRequirement.
     */
    data: XOR<SkillRequirementCreateInput, SkillRequirementUncheckedCreateInput>
  }

  /**
   * SkillRequirement createMany
   */
  export type SkillRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillRequirements.
     */
    data: SkillRequirementCreateManyInput | SkillRequirementCreateManyInput[]
  }

  /**
   * SkillRequirement createManyAndReturn
   */
  export type SkillRequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkillRequirements.
     */
    data: SkillRequirementCreateManyInput | SkillRequirementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillRequirement update
   */
  export type SkillRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillRequirement.
     */
    data: XOR<SkillRequirementUpdateInput, SkillRequirementUncheckedUpdateInput>
    /**
     * Choose, which SkillRequirement to update.
     */
    where: SkillRequirementWhereUniqueInput
  }

  /**
   * SkillRequirement updateMany
   */
  export type SkillRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillRequirements.
     */
    data: XOR<SkillRequirementUpdateManyMutationInput, SkillRequirementUncheckedUpdateManyInput>
    /**
     * Filter which SkillRequirements to update
     */
    where?: SkillRequirementWhereInput
  }

  /**
   * SkillRequirement upsert
   */
  export type SkillRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillRequirement to update in case it exists.
     */
    where: SkillRequirementWhereUniqueInput
    /**
     * In case the SkillRequirement found by the `where` argument doesn't exist, create a new SkillRequirement with this data.
     */
    create: XOR<SkillRequirementCreateInput, SkillRequirementUncheckedCreateInput>
    /**
     * In case the SkillRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillRequirementUpdateInput, SkillRequirementUncheckedUpdateInput>
  }

  /**
   * SkillRequirement delete
   */
  export type SkillRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
    /**
     * Filter which SkillRequirement to delete.
     */
    where: SkillRequirementWhereUniqueInput
  }

  /**
   * SkillRequirement deleteMany
   */
  export type SkillRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillRequirements to delete
     */
    where?: SkillRequirementWhereInput
  }

  /**
   * SkillRequirement without action
   */
  export type SkillRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillRequirement
     */
    select?: SkillRequirementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillRequirementInclude<ExtArgs> | null
  }


  /**
   * Model ShiftPattern
   */

  export type AggregateShiftPattern = {
    _count: ShiftPatternCountAggregateOutputType | null
    _avg: ShiftPatternAvgAggregateOutputType | null
    _sum: ShiftPatternSumAggregateOutputType | null
    _min: ShiftPatternMinAggregateOutputType | null
    _max: ShiftPatternMaxAggregateOutputType | null
  }

  export type ShiftPatternAvgAggregateOutputType = {
    id: number | null
    hoursPerShift: number | null
  }

  export type ShiftPatternSumAggregateOutputType = {
    id: number | null
    hoursPerShift: number | null
  }

  export type ShiftPatternMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    hoursPerShift: number | null
    daysPattern: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ShiftPatternMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    hoursPerShift: number | null
    daysPattern: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ShiftPatternCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startTime: number
    endTime: number
    hoursPerShift: number
    daysPattern: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ShiftPatternAvgAggregateInputType = {
    id?: true
    hoursPerShift?: true
  }

  export type ShiftPatternSumAggregateInputType = {
    id?: true
    hoursPerShift?: true
  }

  export type ShiftPatternMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    hoursPerShift?: true
    daysPattern?: true
    isActive?: true
    createdAt?: true
  }

  export type ShiftPatternMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    hoursPerShift?: true
    daysPattern?: true
    isActive?: true
    createdAt?: true
  }

  export type ShiftPatternCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    hoursPerShift?: true
    daysPattern?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ShiftPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftPattern to aggregate.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftPatterns
    **/
    _count?: true | ShiftPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftPatternMaxAggregateInputType
  }

  export type GetShiftPatternAggregateType<T extends ShiftPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftPattern[P]>
      : GetScalarType<T[P], AggregateShiftPattern[P]>
  }




  export type ShiftPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftPatternWhereInput
    orderBy?: ShiftPatternOrderByWithAggregationInput | ShiftPatternOrderByWithAggregationInput[]
    by: ShiftPatternScalarFieldEnum[] | ShiftPatternScalarFieldEnum
    having?: ShiftPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftPatternCountAggregateInputType | true
    _avg?: ShiftPatternAvgAggregateInputType
    _sum?: ShiftPatternSumAggregateInputType
    _min?: ShiftPatternMinAggregateInputType
    _max?: ShiftPatternMaxAggregateInputType
  }

  export type ShiftPatternGroupByOutputType = {
    id: number
    name: string
    description: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive: boolean
    createdAt: Date
    _count: ShiftPatternCountAggregateOutputType | null
    _avg: ShiftPatternAvgAggregateOutputType | null
    _sum: ShiftPatternSumAggregateOutputType | null
    _min: ShiftPatternMinAggregateOutputType | null
    _max: ShiftPatternMaxAggregateOutputType | null
  }

  type GetShiftPatternGroupByPayload<T extends ShiftPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftPatternGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftPatternGroupByOutputType[P]>
        }
      >
    >


  export type ShiftPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    hoursPerShift?: boolean
    daysPattern?: boolean
    isActive?: boolean
    createdAt?: boolean
    shiftAssignments?: boolean | ShiftPattern$shiftAssignmentsArgs<ExtArgs>
    _count?: boolean | ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftPattern"]>

  export type ShiftPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    hoursPerShift?: boolean
    daysPattern?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["shiftPattern"]>

  export type ShiftPatternSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    hoursPerShift?: boolean
    daysPattern?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ShiftPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftAssignments?: boolean | ShiftPattern$shiftAssignmentsArgs<ExtArgs>
    _count?: boolean | ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ShiftPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftPattern"
    objects: {
      shiftAssignments: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      startTime: string
      endTime: string
      hoursPerShift: number
      daysPattern: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["shiftPattern"]>
    composites: {}
  }

  type ShiftPatternGetPayload<S extends boolean | null | undefined | ShiftPatternDefaultArgs> = $Result.GetResult<Prisma.$ShiftPatternPayload, S>

  type ShiftPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftPatternCountAggregateInputType | true
    }

  export interface ShiftPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftPattern'], meta: { name: 'ShiftPattern' } }
    /**
     * Find zero or one ShiftPattern that matches the filter.
     * @param {ShiftPatternFindUniqueArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftPatternFindUniqueArgs>(args: SelectSubset<T, ShiftPatternFindUniqueArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShiftPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftPatternFindUniqueOrThrowArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShiftPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindFirstArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftPatternFindFirstArgs>(args?: SelectSubset<T, ShiftPatternFindFirstArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShiftPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindFirstOrThrowArgs} args - Arguments to find a ShiftPattern
     * @example
     * // Get one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShiftPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftPatterns
     * const shiftPatterns = await prisma.shiftPattern.findMany()
     * 
     * // Get first 10 ShiftPatterns
     * const shiftPatterns = await prisma.shiftPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftPatternWithIdOnly = await prisma.shiftPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftPatternFindManyArgs>(args?: SelectSubset<T, ShiftPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShiftPattern.
     * @param {ShiftPatternCreateArgs} args - Arguments to create a ShiftPattern.
     * @example
     * // Create one ShiftPattern
     * const ShiftPattern = await prisma.shiftPattern.create({
     *   data: {
     *     // ... data to create a ShiftPattern
     *   }
     * })
     * 
     */
    create<T extends ShiftPatternCreateArgs>(args: SelectSubset<T, ShiftPatternCreateArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShiftPatterns.
     * @param {ShiftPatternCreateManyArgs} args - Arguments to create many ShiftPatterns.
     * @example
     * // Create many ShiftPatterns
     * const shiftPattern = await prisma.shiftPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftPatternCreateManyArgs>(args?: SelectSubset<T, ShiftPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftPatterns and returns the data saved in the database.
     * @param {ShiftPatternCreateManyAndReturnArgs} args - Arguments to create many ShiftPatterns.
     * @example
     * // Create many ShiftPatterns
     * const shiftPattern = await prisma.shiftPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftPatterns and only return the `id`
     * const shiftPatternWithIdOnly = await prisma.shiftPattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShiftPattern.
     * @param {ShiftPatternDeleteArgs} args - Arguments to delete one ShiftPattern.
     * @example
     * // Delete one ShiftPattern
     * const ShiftPattern = await prisma.shiftPattern.delete({
     *   where: {
     *     // ... filter to delete one ShiftPattern
     *   }
     * })
     * 
     */
    delete<T extends ShiftPatternDeleteArgs>(args: SelectSubset<T, ShiftPatternDeleteArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShiftPattern.
     * @param {ShiftPatternUpdateArgs} args - Arguments to update one ShiftPattern.
     * @example
     * // Update one ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftPatternUpdateArgs>(args: SelectSubset<T, ShiftPatternUpdateArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShiftPatterns.
     * @param {ShiftPatternDeleteManyArgs} args - Arguments to filter ShiftPatterns to delete.
     * @example
     * // Delete a few ShiftPatterns
     * const { count } = await prisma.shiftPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftPatternDeleteManyArgs>(args?: SelectSubset<T, ShiftPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftPatterns
     * const shiftPattern = await prisma.shiftPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftPatternUpdateManyArgs>(args: SelectSubset<T, ShiftPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftPattern.
     * @param {ShiftPatternUpsertArgs} args - Arguments to update or create a ShiftPattern.
     * @example
     * // Update or create a ShiftPattern
     * const shiftPattern = await prisma.shiftPattern.upsert({
     *   create: {
     *     // ... data to create a ShiftPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftPattern we want to update
     *   }
     * })
     */
    upsert<T extends ShiftPatternUpsertArgs>(args: SelectSubset<T, ShiftPatternUpsertArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShiftPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternCountArgs} args - Arguments to filter ShiftPatterns to count.
     * @example
     * // Count the number of ShiftPatterns
     * const count = await prisma.shiftPattern.count({
     *   where: {
     *     // ... the filter for the ShiftPatterns we want to count
     *   }
     * })
    **/
    count<T extends ShiftPatternCountArgs>(
      args?: Subset<T, ShiftPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftPatternAggregateArgs>(args: Subset<T, ShiftPatternAggregateArgs>): Prisma.PrismaPromise<GetShiftPatternAggregateType<T>>

    /**
     * Group by ShiftPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftPatternGroupByArgs['orderBy'] }
        : { orderBy?: ShiftPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftPattern model
   */
  readonly fields: ShiftPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shiftAssignments<T extends ShiftPattern$shiftAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ShiftPattern$shiftAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftPattern model
   */ 
  interface ShiftPatternFieldRefs {
    readonly id: FieldRef<"ShiftPattern", 'Int'>
    readonly name: FieldRef<"ShiftPattern", 'String'>
    readonly description: FieldRef<"ShiftPattern", 'String'>
    readonly startTime: FieldRef<"ShiftPattern", 'String'>
    readonly endTime: FieldRef<"ShiftPattern", 'String'>
    readonly hoursPerShift: FieldRef<"ShiftPattern", 'Float'>
    readonly daysPattern: FieldRef<"ShiftPattern", 'String'>
    readonly isActive: FieldRef<"ShiftPattern", 'Boolean'>
    readonly createdAt: FieldRef<"ShiftPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftPattern findUnique
   */
  export type ShiftPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern findUniqueOrThrow
   */
  export type ShiftPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern findFirst
   */
  export type ShiftPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftPatterns.
     */
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern findFirstOrThrow
   */
  export type ShiftPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPattern to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftPatterns.
     */
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern findMany
   */
  export type ShiftPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter, which ShiftPatterns to fetch.
     */
    where?: ShiftPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftPatterns to fetch.
     */
    orderBy?: ShiftPatternOrderByWithRelationInput | ShiftPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftPatterns.
     */
    cursor?: ShiftPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftPatterns.
     */
    skip?: number
    distinct?: ShiftPatternScalarFieldEnum | ShiftPatternScalarFieldEnum[]
  }

  /**
   * ShiftPattern create
   */
  export type ShiftPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftPattern.
     */
    data: XOR<ShiftPatternCreateInput, ShiftPatternUncheckedCreateInput>
  }

  /**
   * ShiftPattern createMany
   */
  export type ShiftPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftPatterns.
     */
    data: ShiftPatternCreateManyInput | ShiftPatternCreateManyInput[]
  }

  /**
   * ShiftPattern createManyAndReturn
   */
  export type ShiftPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShiftPatterns.
     */
    data: ShiftPatternCreateManyInput | ShiftPatternCreateManyInput[]
  }

  /**
   * ShiftPattern update
   */
  export type ShiftPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftPattern.
     */
    data: XOR<ShiftPatternUpdateInput, ShiftPatternUncheckedUpdateInput>
    /**
     * Choose, which ShiftPattern to update.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern updateMany
   */
  export type ShiftPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftPatterns.
     */
    data: XOR<ShiftPatternUpdateManyMutationInput, ShiftPatternUncheckedUpdateManyInput>
    /**
     * Filter which ShiftPatterns to update
     */
    where?: ShiftPatternWhereInput
  }

  /**
   * ShiftPattern upsert
   */
  export type ShiftPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftPattern to update in case it exists.
     */
    where: ShiftPatternWhereUniqueInput
    /**
     * In case the ShiftPattern found by the `where` argument doesn't exist, create a new ShiftPattern with this data.
     */
    create: XOR<ShiftPatternCreateInput, ShiftPatternUncheckedCreateInput>
    /**
     * In case the ShiftPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftPatternUpdateInput, ShiftPatternUncheckedUpdateInput>
  }

  /**
   * ShiftPattern delete
   */
  export type ShiftPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
    /**
     * Filter which ShiftPattern to delete.
     */
    where: ShiftPatternWhereUniqueInput
  }

  /**
   * ShiftPattern deleteMany
   */
  export type ShiftPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftPatterns to delete
     */
    where?: ShiftPatternWhereInput
  }

  /**
   * ShiftPattern.shiftAssignments
   */
  export type ShiftPattern$shiftAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftPattern without action
   */
  export type ShiftPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftPattern
     */
    select?: ShiftPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftPatternInclude<ExtArgs> | null
  }


  /**
   * Model ShiftAssignment
   */

  export type AggregateShiftAssignment = {
    _count: ShiftAssignmentCountAggregateOutputType | null
    _avg: ShiftAssignmentAvgAggregateOutputType | null
    _sum: ShiftAssignmentSumAggregateOutputType | null
    _min: ShiftAssignmentMinAggregateOutputType | null
    _max: ShiftAssignmentMaxAggregateOutputType | null
  }

  export type ShiftAssignmentAvgAggregateOutputType = {
    id: number | null
    operatorId: number | null
    workcenterId: number | null
    shiftPatternId: number | null
    payRate: number | null
  }

  export type ShiftAssignmentSumAggregateOutputType = {
    id: number | null
    operatorId: number | null
    workcenterId: number | null
    shiftPatternId: number | null
    payRate: number | null
  }

  export type ShiftAssignmentMinAggregateOutputType = {
    id: number | null
    operatorId: number | null
    workcenterId: number | null
    shiftPatternId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    role: string | null
    payRate: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftAssignmentMaxAggregateOutputType = {
    id: number | null
    operatorId: number | null
    workcenterId: number | null
    shiftPatternId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    role: string | null
    payRate: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftAssignmentCountAggregateOutputType = {
    id: number
    operatorId: number
    workcenterId: number
    shiftPatternId: number
    startDate: number
    endDate: number
    isActive: number
    role: number
    payRate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAssignmentAvgAggregateInputType = {
    id?: true
    operatorId?: true
    workcenterId?: true
    shiftPatternId?: true
    payRate?: true
  }

  export type ShiftAssignmentSumAggregateInputType = {
    id?: true
    operatorId?: true
    workcenterId?: true
    shiftPatternId?: true
    payRate?: true
  }

  export type ShiftAssignmentMinAggregateInputType = {
    id?: true
    operatorId?: true
    workcenterId?: true
    shiftPatternId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    role?: true
    payRate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftAssignmentMaxAggregateInputType = {
    id?: true
    operatorId?: true
    workcenterId?: true
    shiftPatternId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    role?: true
    payRate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftAssignmentCountAggregateInputType = {
    id?: true
    operatorId?: true
    workcenterId?: true
    shiftPatternId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    role?: true
    payRate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAssignment to aggregate.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftAssignments
    **/
    _count?: true | ShiftAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftAssignmentMaxAggregateInputType
  }

  export type GetShiftAssignmentAggregateType<T extends ShiftAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftAssignment[P]>
      : GetScalarType<T[P], AggregateShiftAssignment[P]>
  }




  export type ShiftAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithAggregationInput | ShiftAssignmentOrderByWithAggregationInput[]
    by: ShiftAssignmentScalarFieldEnum[] | ShiftAssignmentScalarFieldEnum
    having?: ShiftAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftAssignmentCountAggregateInputType | true
    _avg?: ShiftAssignmentAvgAggregateInputType
    _sum?: ShiftAssignmentSumAggregateInputType
    _min?: ShiftAssignmentMinAggregateInputType
    _max?: ShiftAssignmentMaxAggregateInputType
  }

  export type ShiftAssignmentGroupByOutputType = {
    id: number
    operatorId: number
    workcenterId: number
    shiftPatternId: number
    startDate: Date
    endDate: Date | null
    isActive: boolean
    role: string
    payRate: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShiftAssignmentCountAggregateOutputType | null
    _avg: ShiftAssignmentAvgAggregateOutputType | null
    _sum: ShiftAssignmentSumAggregateOutputType | null
    _min: ShiftAssignmentMinAggregateOutputType | null
    _max: ShiftAssignmentMaxAggregateOutputType | null
  }

  type GetShiftAssignmentGroupByPayload<T extends ShiftAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ShiftAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    workcenterId?: boolean
    shiftPatternId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    role?: boolean
    payRate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shiftPattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftAssignment"]>

  export type ShiftAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    operatorId?: boolean
    workcenterId?: boolean
    shiftPatternId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    role?: boolean
    payRate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shiftPattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shiftAssignment"]>

  export type ShiftAssignmentSelectScalar = {
    id?: boolean
    operatorId?: boolean
    workcenterId?: boolean
    shiftPatternId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    role?: boolean
    payRate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftPattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }
  export type ShiftAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shiftPattern?: boolean | ShiftPatternDefaultArgs<ExtArgs>
    workcenter?: boolean | WorkcenterDefaultArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }

  export type $ShiftAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftAssignment"
    objects: {
      shiftPattern: Prisma.$ShiftPatternPayload<ExtArgs>
      workcenter: Prisma.$WorkcenterPayload<ExtArgs>
      operator: Prisma.$OperatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      operatorId: number
      workcenterId: number
      shiftPatternId: number
      startDate: Date
      endDate: Date | null
      isActive: boolean
      role: string
      payRate: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shiftAssignment"]>
    composites: {}
  }

  type ShiftAssignmentGetPayload<S extends boolean | null | undefined | ShiftAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ShiftAssignmentPayload, S>

  type ShiftAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftAssignmentCountAggregateInputType | true
    }

  export interface ShiftAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftAssignment'], meta: { name: 'ShiftAssignment' } }
    /**
     * Find zero or one ShiftAssignment that matches the filter.
     * @param {ShiftAssignmentFindUniqueArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftAssignmentFindUniqueArgs>(args: SelectSubset<T, ShiftAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShiftAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShiftAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindFirstArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftAssignmentFindFirstArgs>(args?: SelectSubset<T, ShiftAssignmentFindFirstArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShiftAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindFirstOrThrowArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShiftAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftAssignments
     * const shiftAssignments = await prisma.shiftAssignment.findMany()
     * 
     * // Get first 10 ShiftAssignments
     * const shiftAssignments = await prisma.shiftAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftAssignmentWithIdOnly = await prisma.shiftAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftAssignmentFindManyArgs>(args?: SelectSubset<T, ShiftAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShiftAssignment.
     * @param {ShiftAssignmentCreateArgs} args - Arguments to create a ShiftAssignment.
     * @example
     * // Create one ShiftAssignment
     * const ShiftAssignment = await prisma.shiftAssignment.create({
     *   data: {
     *     // ... data to create a ShiftAssignment
     *   }
     * })
     * 
     */
    create<T extends ShiftAssignmentCreateArgs>(args: SelectSubset<T, ShiftAssignmentCreateArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShiftAssignments.
     * @param {ShiftAssignmentCreateManyArgs} args - Arguments to create many ShiftAssignments.
     * @example
     * // Create many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftAssignmentCreateManyArgs>(args?: SelectSubset<T, ShiftAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftAssignments and returns the data saved in the database.
     * @param {ShiftAssignmentCreateManyAndReturnArgs} args - Arguments to create many ShiftAssignments.
     * @example
     * // Create many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftAssignments and only return the `id`
     * const shiftAssignmentWithIdOnly = await prisma.shiftAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShiftAssignment.
     * @param {ShiftAssignmentDeleteArgs} args - Arguments to delete one ShiftAssignment.
     * @example
     * // Delete one ShiftAssignment
     * const ShiftAssignment = await prisma.shiftAssignment.delete({
     *   where: {
     *     // ... filter to delete one ShiftAssignment
     *   }
     * })
     * 
     */
    delete<T extends ShiftAssignmentDeleteArgs>(args: SelectSubset<T, ShiftAssignmentDeleteArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShiftAssignment.
     * @param {ShiftAssignmentUpdateArgs} args - Arguments to update one ShiftAssignment.
     * @example
     * // Update one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftAssignmentUpdateArgs>(args: SelectSubset<T, ShiftAssignmentUpdateArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShiftAssignments.
     * @param {ShiftAssignmentDeleteManyArgs} args - Arguments to filter ShiftAssignments to delete.
     * @example
     * // Delete a few ShiftAssignments
     * const { count } = await prisma.shiftAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftAssignmentDeleteManyArgs>(args?: SelectSubset<T, ShiftAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftAssignmentUpdateManyArgs>(args: SelectSubset<T, ShiftAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftAssignment.
     * @param {ShiftAssignmentUpsertArgs} args - Arguments to update or create a ShiftAssignment.
     * @example
     * // Update or create a ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.upsert({
     *   create: {
     *     // ... data to create a ShiftAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ShiftAssignmentUpsertArgs>(args: SelectSubset<T, ShiftAssignmentUpsertArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShiftAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentCountArgs} args - Arguments to filter ShiftAssignments to count.
     * @example
     * // Count the number of ShiftAssignments
     * const count = await prisma.shiftAssignment.count({
     *   where: {
     *     // ... the filter for the ShiftAssignments we want to count
     *   }
     * })
    **/
    count<T extends ShiftAssignmentCountArgs>(
      args?: Subset<T, ShiftAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAssignmentAggregateArgs>(args: Subset<T, ShiftAssignmentAggregateArgs>): Prisma.PrismaPromise<GetShiftAssignmentAggregateType<T>>

    /**
     * Group by ShiftAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ShiftAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftAssignment model
   */
  readonly fields: ShiftAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shiftPattern<T extends ShiftPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftPatternDefaultArgs<ExtArgs>>): Prisma__ShiftPatternClient<$Result.GetResult<Prisma.$ShiftPatternPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workcenter<T extends WorkcenterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkcenterDefaultArgs<ExtArgs>>): Prisma__WorkcenterClient<$Result.GetResult<Prisma.$WorkcenterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftAssignment model
   */ 
  interface ShiftAssignmentFieldRefs {
    readonly id: FieldRef<"ShiftAssignment", 'Int'>
    readonly operatorId: FieldRef<"ShiftAssignment", 'Int'>
    readonly workcenterId: FieldRef<"ShiftAssignment", 'Int'>
    readonly shiftPatternId: FieldRef<"ShiftAssignment", 'Int'>
    readonly startDate: FieldRef<"ShiftAssignment", 'DateTime'>
    readonly endDate: FieldRef<"ShiftAssignment", 'DateTime'>
    readonly isActive: FieldRef<"ShiftAssignment", 'Boolean'>
    readonly role: FieldRef<"ShiftAssignment", 'String'>
    readonly payRate: FieldRef<"ShiftAssignment", 'Float'>
    readonly notes: FieldRef<"ShiftAssignment", 'String'>
    readonly createdAt: FieldRef<"ShiftAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"ShiftAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftAssignment findUnique
   */
  export type ShiftAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment findUniqueOrThrow
   */
  export type ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment findFirst
   */
  export type ShiftAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAssignments.
     */
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment findFirstOrThrow
   */
  export type ShiftAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAssignments.
     */
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment findMany
   */
  export type ShiftAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignments to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment create
   */
  export type ShiftAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftAssignment.
     */
    data: XOR<ShiftAssignmentCreateInput, ShiftAssignmentUncheckedCreateInput>
  }

  /**
   * ShiftAssignment createMany
   */
  export type ShiftAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftAssignments.
     */
    data: ShiftAssignmentCreateManyInput | ShiftAssignmentCreateManyInput[]
  }

  /**
   * ShiftAssignment createManyAndReturn
   */
  export type ShiftAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShiftAssignments.
     */
    data: ShiftAssignmentCreateManyInput | ShiftAssignmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftAssignment update
   */
  export type ShiftAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftAssignment.
     */
    data: XOR<ShiftAssignmentUpdateInput, ShiftAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ShiftAssignment to update.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment updateMany
   */
  export type ShiftAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftAssignments.
     */
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ShiftAssignments to update
     */
    where?: ShiftAssignmentWhereInput
  }

  /**
   * ShiftAssignment upsert
   */
  export type ShiftAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftAssignment to update in case it exists.
     */
    where: ShiftAssignmentWhereUniqueInput
    /**
     * In case the ShiftAssignment found by the `where` argument doesn't exist, create a new ShiftAssignment with this data.
     */
    create: XOR<ShiftAssignmentCreateInput, ShiftAssignmentUncheckedCreateInput>
    /**
     * In case the ShiftAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftAssignmentUpdateInput, ShiftAssignmentUncheckedUpdateInput>
  }

  /**
   * ShiftAssignment delete
   */
  export type ShiftAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ShiftAssignment to delete.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment deleteMany
   */
  export type ShiftAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAssignments to delete
     */
    where?: ShiftAssignmentWhereInput
  }

  /**
   * ShiftAssignment without action
   */
  export type ShiftAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PlantScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PlantScalarFieldEnum = (typeof PlantScalarFieldEnum)[keyof typeof PlantScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    name: 'name'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const WorkcenterScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    departmentId: 'departmentId',
    workcenterNo: 'workcenterNo',
    name: 'name',
    displayTitle: 'displayTitle',
    defaultSchemeId: 'defaultSchemeId',
    minStaff: 'minStaff',
    gatingRules: 'gatingRules',
    changeoverFamily: 'changeoverFamily'
  };

  export type WorkcenterScalarFieldEnum = (typeof WorkcenterScalarFieldEnum)[keyof typeof WorkcenterScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    date: 'date',
    label: 'label'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const SKUScalarFieldEnum: {
    id: 'id',
    code: 'code',
    family: 'family',
    familyColorHex: 'familyColorHex',
    formula: 'formula',
    bottleSize: 'bottleSize',
    caseSize: 'caseSize'
  };

  export type SKUScalarFieldEnum = (typeof SKUScalarFieldEnum)[keyof typeof SKUScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    skuId: 'skuId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    skuId: 'skuId',
    qty: 'qty',
    runRateUph: 'runRateUph',
    performanceLeverPct: 'performanceLeverPct',
    priority: 'priority',
    dueAt: 'dueAt',
    workcenterId: 'workcenterId',
    shopfloorTitle: 'shopfloorTitle',
    colorHex: 'colorHex'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const ScheduleBlockScalarFieldEnum: {
    id: 'id',
    workcenterId: 'workcenterId',
    orderId: 'orderId',
    startAt: 'startAt',
    endAt: 'endAt'
  };

  export type ScheduleBlockScalarFieldEnum = (typeof ScheduleBlockScalarFieldEnum)[keyof typeof ScheduleBlockScalarFieldEnum]


  export const ChangeoverScalarFieldEnum: {
    id: 'id',
    workcenterId: 'workcenterId',
    fromBlockId: 'fromBlockId',
    toBlockId: 'toBlockId',
    typeCode: 'typeCode',
    plannedMinutes: 'plannedMinutes',
    includeInOee: 'includeInOee',
    complexityTier: 'complexityTier'
  };

  export type ChangeoverScalarFieldEnum = (typeof ChangeoverScalarFieldEnum)[keyof typeof ChangeoverScalarFieldEnum]


  export const OperatorScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    hireDate: 'hireDate',
    departmentId: 'departmentId',
    isActive: 'isActive',
    basePayRate: 'basePayRate',
    emergencyContact: 'emergencyContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatorScalarFieldEnum = (typeof OperatorScalarFieldEnum)[keyof typeof OperatorScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    category: 'category',
    isCore: 'isCore',
    isCertification: 'isCertification',
    expiryMonths: 'expiryMonths',
    createdAt: 'createdAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const OperatorCompetencyScalarFieldEnum: {
    id: 'id',
    operatorId: 'operatorId',
    skillId: 'skillId',
    level: 'level',
    certifiedAt: 'certifiedAt',
    expiresAt: 'expiresAt',
    certifiedBy: 'certifiedBy',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatorCompetencyScalarFieldEnum = (typeof OperatorCompetencyScalarFieldEnum)[keyof typeof OperatorCompetencyScalarFieldEnum]


  export const SkillRequirementScalarFieldEnum: {
    id: 'id',
    workcenterId: 'workcenterId',
    skillId: 'skillId',
    minLevel: 'minLevel',
    isRequired: 'isRequired',
    shiftType: 'shiftType',
    createdAt: 'createdAt'
  };

  export type SkillRequirementScalarFieldEnum = (typeof SkillRequirementScalarFieldEnum)[keyof typeof SkillRequirementScalarFieldEnum]


  export const ShiftPatternScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    hoursPerShift: 'hoursPerShift',
    daysPattern: 'daysPattern',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ShiftPatternScalarFieldEnum = (typeof ShiftPatternScalarFieldEnum)[keyof typeof ShiftPatternScalarFieldEnum]


  export const ShiftAssignmentScalarFieldEnum: {
    id: 'id',
    operatorId: 'operatorId',
    workcenterId: 'workcenterId',
    shiftPatternId: 'shiftPatternId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    role: 'role',
    payRate: 'payRate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftAssignmentScalarFieldEnum = (typeof ShiftAssignmentScalarFieldEnum)[keyof typeof ShiftAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type PlantWhereInput = {
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    id?: IntFilter<"Plant"> | number
    name?: StringFilter<"Plant"> | string
    departments?: DepartmentListRelationFilter
    holidays?: HolidayListRelationFilter
    workcenters?: WorkcenterListRelationFilter
  }

  export type PlantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    holidays?: HolidayOrderByRelationAggregateInput
    workcenters?: WorkcenterOrderByRelationAggregateInput
  }

  export type PlantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlantWhereInput | PlantWhereInput[]
    OR?: PlantWhereInput[]
    NOT?: PlantWhereInput | PlantWhereInput[]
    name?: StringFilter<"Plant"> | string
    departments?: DepartmentListRelationFilter
    holidays?: HolidayListRelationFilter
    workcenters?: WorkcenterListRelationFilter
  }, "id">

  export type PlantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PlantCountOrderByAggregateInput
    _avg?: PlantAvgOrderByAggregateInput
    _max?: PlantMaxOrderByAggregateInput
    _min?: PlantMinOrderByAggregateInput
    _sum?: PlantSumOrderByAggregateInput
  }

  export type PlantScalarWhereWithAggregatesInput = {
    AND?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    OR?: PlantScalarWhereWithAggregatesInput[]
    NOT?: PlantScalarWhereWithAggregatesInput | PlantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plant"> | number
    name?: StringWithAggregatesFilter<"Plant"> | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    plantId?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
    operators?: OperatorListRelationFilter
    workcenters?: WorkcenterListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    name?: SortOrder
    plant?: PlantOrderByWithRelationInput
    operators?: OperatorOrderByRelationAggregateInput
    workcenters?: WorkcenterOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    plantId?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
    operators?: OperatorListRelationFilter
    workcenters?: WorkcenterListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    name?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    plantId?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
  }

  export type WorkcenterWhereInput = {
    AND?: WorkcenterWhereInput | WorkcenterWhereInput[]
    OR?: WorkcenterWhereInput[]
    NOT?: WorkcenterWhereInput | WorkcenterWhereInput[]
    id?: IntFilter<"Workcenter"> | number
    plantId?: IntFilter<"Workcenter"> | number
    departmentId?: IntFilter<"Workcenter"> | number
    workcenterNo?: StringFilter<"Workcenter"> | string
    name?: StringFilter<"Workcenter"> | string
    displayTitle?: StringNullableFilter<"Workcenter"> | string | null
    defaultSchemeId?: IntNullableFilter<"Workcenter"> | number | null
    minStaff?: IntFilter<"Workcenter"> | number
    gatingRules?: StringNullableFilter<"Workcenter"> | string | null
    changeoverFamily?: StringNullableFilter<"Workcenter"> | string | null
    changeovers?: ChangeoverListRelationFilter
    orders?: OrderListRelationFilter
    scheduleBlocks?: ScheduleBlockListRelationFilter
    shiftAssignments?: ShiftAssignmentListRelationFilter
    skillRequirements?: SkillRequirementListRelationFilter
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
  }

  export type WorkcenterOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    workcenterNo?: SortOrder
    name?: SortOrder
    displayTitle?: SortOrderInput | SortOrder
    defaultSchemeId?: SortOrderInput | SortOrder
    minStaff?: SortOrder
    gatingRules?: SortOrderInput | SortOrder
    changeoverFamily?: SortOrderInput | SortOrder
    changeovers?: ChangeoverOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    scheduleBlocks?: ScheduleBlockOrderByRelationAggregateInput
    shiftAssignments?: ShiftAssignmentOrderByRelationAggregateInput
    skillRequirements?: SkillRequirementOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    plant?: PlantOrderByWithRelationInput
  }

  export type WorkcenterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    plantId_workcenterNo?: WorkcenterPlantIdWorkcenterNoCompoundUniqueInput
    AND?: WorkcenterWhereInput | WorkcenterWhereInput[]
    OR?: WorkcenterWhereInput[]
    NOT?: WorkcenterWhereInput | WorkcenterWhereInput[]
    plantId?: IntFilter<"Workcenter"> | number
    departmentId?: IntFilter<"Workcenter"> | number
    workcenterNo?: StringFilter<"Workcenter"> | string
    name?: StringFilter<"Workcenter"> | string
    displayTitle?: StringNullableFilter<"Workcenter"> | string | null
    defaultSchemeId?: IntNullableFilter<"Workcenter"> | number | null
    minStaff?: IntFilter<"Workcenter"> | number
    gatingRules?: StringNullableFilter<"Workcenter"> | string | null
    changeoverFamily?: StringNullableFilter<"Workcenter"> | string | null
    changeovers?: ChangeoverListRelationFilter
    orders?: OrderListRelationFilter
    scheduleBlocks?: ScheduleBlockListRelationFilter
    shiftAssignments?: ShiftAssignmentListRelationFilter
    skillRequirements?: SkillRequirementListRelationFilter
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
  }, "id" | "plantId_workcenterNo">

  export type WorkcenterOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    workcenterNo?: SortOrder
    name?: SortOrder
    displayTitle?: SortOrderInput | SortOrder
    defaultSchemeId?: SortOrderInput | SortOrder
    minStaff?: SortOrder
    gatingRules?: SortOrderInput | SortOrder
    changeoverFamily?: SortOrderInput | SortOrder
    _count?: WorkcenterCountOrderByAggregateInput
    _avg?: WorkcenterAvgOrderByAggregateInput
    _max?: WorkcenterMaxOrderByAggregateInput
    _min?: WorkcenterMinOrderByAggregateInput
    _sum?: WorkcenterSumOrderByAggregateInput
  }

  export type WorkcenterScalarWhereWithAggregatesInput = {
    AND?: WorkcenterScalarWhereWithAggregatesInput | WorkcenterScalarWhereWithAggregatesInput[]
    OR?: WorkcenterScalarWhereWithAggregatesInput[]
    NOT?: WorkcenterScalarWhereWithAggregatesInput | WorkcenterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Workcenter"> | number
    plantId?: IntWithAggregatesFilter<"Workcenter"> | number
    departmentId?: IntWithAggregatesFilter<"Workcenter"> | number
    workcenterNo?: StringWithAggregatesFilter<"Workcenter"> | string
    name?: StringWithAggregatesFilter<"Workcenter"> | string
    displayTitle?: StringNullableWithAggregatesFilter<"Workcenter"> | string | null
    defaultSchemeId?: IntNullableWithAggregatesFilter<"Workcenter"> | number | null
    minStaff?: IntWithAggregatesFilter<"Workcenter"> | number
    gatingRules?: StringNullableWithAggregatesFilter<"Workcenter"> | string | null
    changeoverFamily?: StringNullableWithAggregatesFilter<"Workcenter"> | string | null
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: IntFilter<"Holiday"> | number
    plantId?: IntFilter<"Holiday"> | number
    date?: DateTimeFilter<"Holiday"> | Date | string
    label?: StringNullableFilter<"Holiday"> | string | null
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    label?: SortOrderInput | SortOrder
    plant?: PlantOrderByWithRelationInput
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    plantId?: IntFilter<"Holiday"> | number
    date?: DateTimeFilter<"Holiday"> | Date | string
    label?: StringNullableFilter<"Holiday"> | string | null
    plant?: XOR<PlantRelationFilter, PlantWhereInput>
  }, "id">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    label?: SortOrderInput | SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _avg?: HolidayAvgOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
    _sum?: HolidaySumOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Holiday"> | number
    plantId?: IntWithAggregatesFilter<"Holiday"> | number
    date?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    label?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
  }

  export type SKUWhereInput = {
    AND?: SKUWhereInput | SKUWhereInput[]
    OR?: SKUWhereInput[]
    NOT?: SKUWhereInput | SKUWhereInput[]
    id?: IntFilter<"SKU"> | number
    code?: StringFilter<"SKU"> | string
    family?: StringFilter<"SKU"> | string
    familyColorHex?: StringNullableFilter<"SKU"> | string | null
    formula?: StringNullableFilter<"SKU"> | string | null
    bottleSize?: StringNullableFilter<"SKU"> | string | null
    caseSize?: StringNullableFilter<"SKU"> | string | null
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
  }

  export type SKUOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    family?: SortOrder
    familyColorHex?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    bottleSize?: SortOrderInput | SortOrder
    caseSize?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type SKUWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SKUWhereInput | SKUWhereInput[]
    OR?: SKUWhereInput[]
    NOT?: SKUWhereInput | SKUWhereInput[]
    family?: StringFilter<"SKU"> | string
    familyColorHex?: StringNullableFilter<"SKU"> | string | null
    formula?: StringNullableFilter<"SKU"> | string | null
    bottleSize?: StringNullableFilter<"SKU"> | string | null
    caseSize?: StringNullableFilter<"SKU"> | string | null
    orders?: OrderListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "code">

  export type SKUOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    family?: SortOrder
    familyColorHex?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    bottleSize?: SortOrderInput | SortOrder
    caseSize?: SortOrderInput | SortOrder
    _count?: SKUCountOrderByAggregateInput
    _avg?: SKUAvgOrderByAggregateInput
    _max?: SKUMaxOrderByAggregateInput
    _min?: SKUMinOrderByAggregateInput
    _sum?: SKUSumOrderByAggregateInput
  }

  export type SKUScalarWhereWithAggregatesInput = {
    AND?: SKUScalarWhereWithAggregatesInput | SKUScalarWhereWithAggregatesInput[]
    OR?: SKUScalarWhereWithAggregatesInput[]
    NOT?: SKUScalarWhereWithAggregatesInput | SKUScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SKU"> | number
    code?: StringWithAggregatesFilter<"SKU"> | string
    family?: StringWithAggregatesFilter<"SKU"> | string
    familyColorHex?: StringNullableWithAggregatesFilter<"SKU"> | string | null
    formula?: StringNullableWithAggregatesFilter<"SKU"> | string | null
    bottleSize?: StringNullableWithAggregatesFilter<"SKU"> | string | null
    caseSize?: StringNullableWithAggregatesFilter<"SKU"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    skuId?: IntFilter<"Product"> | number
    sku?: XOR<SKURelationFilter, SKUWhereInput>
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    skuId?: SortOrder
    sku?: SKUOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    skuId?: IntFilter<"Product"> | number
    sku?: XOR<SKURelationFilter, SKUWhereInput>
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    skuId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    skuId?: IntWithAggregatesFilter<"Product"> | number
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNo?: StringFilter<"Order"> | string
    skuId?: IntFilter<"Order"> | number
    qty?: IntFilter<"Order"> | number
    runRateUph?: IntFilter<"Order"> | number
    performanceLeverPct?: FloatFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    dueAt?: DateTimeFilter<"Order"> | Date | string
    workcenterId?: IntNullableFilter<"Order"> | number | null
    shopfloorTitle?: StringNullableFilter<"Order"> | string | null
    colorHex?: StringNullableFilter<"Order"> | string | null
    plannedWorkcenter?: XOR<WorkcenterNullableRelationFilter, WorkcenterWhereInput> | null
    sku?: XOR<SKURelationFilter, SKUWhereInput>
    scheduleBlocks?: ScheduleBlockListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    dueAt?: SortOrder
    workcenterId?: SortOrderInput | SortOrder
    shopfloorTitle?: SortOrderInput | SortOrder
    colorHex?: SortOrderInput | SortOrder
    plannedWorkcenter?: WorkcenterOrderByWithRelationInput
    sku?: SKUOrderByWithRelationInput
    scheduleBlocks?: ScheduleBlockOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNo?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    skuId?: IntFilter<"Order"> | number
    qty?: IntFilter<"Order"> | number
    runRateUph?: IntFilter<"Order"> | number
    performanceLeverPct?: FloatFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    dueAt?: DateTimeFilter<"Order"> | Date | string
    workcenterId?: IntNullableFilter<"Order"> | number | null
    shopfloorTitle?: StringNullableFilter<"Order"> | string | null
    colorHex?: StringNullableFilter<"Order"> | string | null
    plannedWorkcenter?: XOR<WorkcenterNullableRelationFilter, WorkcenterWhereInput> | null
    sku?: XOR<SKURelationFilter, SKUWhereInput>
    scheduleBlocks?: ScheduleBlockListRelationFilter
  }, "id" | "orderNo">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    dueAt?: SortOrder
    workcenterId?: SortOrderInput | SortOrder
    shopfloorTitle?: SortOrderInput | SortOrder
    colorHex?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    orderNo?: StringWithAggregatesFilter<"Order"> | string
    skuId?: IntWithAggregatesFilter<"Order"> | number
    qty?: IntWithAggregatesFilter<"Order"> | number
    runRateUph?: IntWithAggregatesFilter<"Order"> | number
    performanceLeverPct?: FloatWithAggregatesFilter<"Order"> | number
    priority?: IntWithAggregatesFilter<"Order"> | number
    dueAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    workcenterId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    shopfloorTitle?: StringNullableWithAggregatesFilter<"Order"> | string | null
    colorHex?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type ScheduleBlockWhereInput = {
    AND?: ScheduleBlockWhereInput | ScheduleBlockWhereInput[]
    OR?: ScheduleBlockWhereInput[]
    NOT?: ScheduleBlockWhereInput | ScheduleBlockWhereInput[]
    id?: IntFilter<"ScheduleBlock"> | number
    workcenterId?: IntFilter<"ScheduleBlock"> | number
    orderId?: IntNullableFilter<"ScheduleBlock"> | number | null
    startAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
    endAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
    toChangeovers?: ChangeoverListRelationFilter
    fromChangeovers?: ChangeoverListRelationFilter
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }

  export type ScheduleBlockOrderByWithRelationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    toChangeovers?: ChangeoverOrderByRelationAggregateInput
    fromChangeovers?: ChangeoverOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
    workcenter?: WorkcenterOrderByWithRelationInput
  }

  export type ScheduleBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduleBlockWhereInput | ScheduleBlockWhereInput[]
    OR?: ScheduleBlockWhereInput[]
    NOT?: ScheduleBlockWhereInput | ScheduleBlockWhereInput[]
    workcenterId?: IntFilter<"ScheduleBlock"> | number
    orderId?: IntNullableFilter<"ScheduleBlock"> | number | null
    startAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
    endAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
    toChangeovers?: ChangeoverListRelationFilter
    fromChangeovers?: ChangeoverListRelationFilter
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }, "id">

  export type ScheduleBlockOrderByWithAggregationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    _count?: ScheduleBlockCountOrderByAggregateInput
    _avg?: ScheduleBlockAvgOrderByAggregateInput
    _max?: ScheduleBlockMaxOrderByAggregateInput
    _min?: ScheduleBlockMinOrderByAggregateInput
    _sum?: ScheduleBlockSumOrderByAggregateInput
  }

  export type ScheduleBlockScalarWhereWithAggregatesInput = {
    AND?: ScheduleBlockScalarWhereWithAggregatesInput | ScheduleBlockScalarWhereWithAggregatesInput[]
    OR?: ScheduleBlockScalarWhereWithAggregatesInput[]
    NOT?: ScheduleBlockScalarWhereWithAggregatesInput | ScheduleBlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScheduleBlock"> | number
    workcenterId?: IntWithAggregatesFilter<"ScheduleBlock"> | number
    orderId?: IntNullableWithAggregatesFilter<"ScheduleBlock"> | number | null
    startAt?: DateTimeWithAggregatesFilter<"ScheduleBlock"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"ScheduleBlock"> | Date | string
  }

  export type ChangeoverWhereInput = {
    AND?: ChangeoverWhereInput | ChangeoverWhereInput[]
    OR?: ChangeoverWhereInput[]
    NOT?: ChangeoverWhereInput | ChangeoverWhereInput[]
    id?: IntFilter<"Changeover"> | number
    workcenterId?: IntFilter<"Changeover"> | number
    fromBlockId?: IntFilter<"Changeover"> | number
    toBlockId?: IntFilter<"Changeover"> | number
    typeCode?: StringFilter<"Changeover"> | string
    plannedMinutes?: IntFilter<"Changeover"> | number
    includeInOee?: BoolFilter<"Changeover"> | boolean
    complexityTier?: StringNullableFilter<"Changeover"> | string | null
    toBlock?: XOR<ScheduleBlockRelationFilter, ScheduleBlockWhereInput>
    fromBlock?: XOR<ScheduleBlockRelationFilter, ScheduleBlockWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }

  export type ChangeoverOrderByWithRelationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    typeCode?: SortOrder
    plannedMinutes?: SortOrder
    includeInOee?: SortOrder
    complexityTier?: SortOrderInput | SortOrder
    toBlock?: ScheduleBlockOrderByWithRelationInput
    fromBlock?: ScheduleBlockOrderByWithRelationInput
    workcenter?: WorkcenterOrderByWithRelationInput
  }

  export type ChangeoverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChangeoverWhereInput | ChangeoverWhereInput[]
    OR?: ChangeoverWhereInput[]
    NOT?: ChangeoverWhereInput | ChangeoverWhereInput[]
    workcenterId?: IntFilter<"Changeover"> | number
    fromBlockId?: IntFilter<"Changeover"> | number
    toBlockId?: IntFilter<"Changeover"> | number
    typeCode?: StringFilter<"Changeover"> | string
    plannedMinutes?: IntFilter<"Changeover"> | number
    includeInOee?: BoolFilter<"Changeover"> | boolean
    complexityTier?: StringNullableFilter<"Changeover"> | string | null
    toBlock?: XOR<ScheduleBlockRelationFilter, ScheduleBlockWhereInput>
    fromBlock?: XOR<ScheduleBlockRelationFilter, ScheduleBlockWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }, "id">

  export type ChangeoverOrderByWithAggregationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    typeCode?: SortOrder
    plannedMinutes?: SortOrder
    includeInOee?: SortOrder
    complexityTier?: SortOrderInput | SortOrder
    _count?: ChangeoverCountOrderByAggregateInput
    _avg?: ChangeoverAvgOrderByAggregateInput
    _max?: ChangeoverMaxOrderByAggregateInput
    _min?: ChangeoverMinOrderByAggregateInput
    _sum?: ChangeoverSumOrderByAggregateInput
  }

  export type ChangeoverScalarWhereWithAggregatesInput = {
    AND?: ChangeoverScalarWhereWithAggregatesInput | ChangeoverScalarWhereWithAggregatesInput[]
    OR?: ChangeoverScalarWhereWithAggregatesInput[]
    NOT?: ChangeoverScalarWhereWithAggregatesInput | ChangeoverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Changeover"> | number
    workcenterId?: IntWithAggregatesFilter<"Changeover"> | number
    fromBlockId?: IntWithAggregatesFilter<"Changeover"> | number
    toBlockId?: IntWithAggregatesFilter<"Changeover"> | number
    typeCode?: StringWithAggregatesFilter<"Changeover"> | string
    plannedMinutes?: IntWithAggregatesFilter<"Changeover"> | number
    includeInOee?: BoolWithAggregatesFilter<"Changeover"> | boolean
    complexityTier?: StringNullableWithAggregatesFilter<"Changeover"> | string | null
  }

  export type OperatorWhereInput = {
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    id?: IntFilter<"Operator"> | number
    employeeId?: StringFilter<"Operator"> | string
    firstName?: StringFilter<"Operator"> | string
    lastName?: StringFilter<"Operator"> | string
    email?: StringNullableFilter<"Operator"> | string | null
    phone?: StringNullableFilter<"Operator"> | string | null
    hireDate?: DateTimeFilter<"Operator"> | Date | string
    departmentId?: IntNullableFilter<"Operator"> | number | null
    isActive?: BoolFilter<"Operator"> | boolean
    basePayRate?: FloatNullableFilter<"Operator"> | number | null
    emergencyContact?: StringNullableFilter<"Operator"> | string | null
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeFilter<"Operator"> | Date | string
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    competencies?: OperatorCompetencyListRelationFilter
    shiftAssignments?: ShiftAssignmentListRelationFilter
  }

  export type OperatorOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    basePayRate?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    competencies?: OperatorCompetencyOrderByRelationAggregateInput
    shiftAssignments?: ShiftAssignmentOrderByRelationAggregateInput
  }

  export type OperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId?: string
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    firstName?: StringFilter<"Operator"> | string
    lastName?: StringFilter<"Operator"> | string
    email?: StringNullableFilter<"Operator"> | string | null
    phone?: StringNullableFilter<"Operator"> | string | null
    hireDate?: DateTimeFilter<"Operator"> | Date | string
    departmentId?: IntNullableFilter<"Operator"> | number | null
    isActive?: BoolFilter<"Operator"> | boolean
    basePayRate?: FloatNullableFilter<"Operator"> | number | null
    emergencyContact?: StringNullableFilter<"Operator"> | string | null
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeFilter<"Operator"> | Date | string
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    competencies?: OperatorCompetencyListRelationFilter
    shiftAssignments?: ShiftAssignmentListRelationFilter
  }, "id" | "employeeId">

  export type OperatorOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    basePayRate?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperatorCountOrderByAggregateInput
    _avg?: OperatorAvgOrderByAggregateInput
    _max?: OperatorMaxOrderByAggregateInput
    _min?: OperatorMinOrderByAggregateInput
    _sum?: OperatorSumOrderByAggregateInput
  }

  export type OperatorScalarWhereWithAggregatesInput = {
    AND?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    OR?: OperatorScalarWhereWithAggregatesInput[]
    NOT?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Operator"> | number
    employeeId?: StringWithAggregatesFilter<"Operator"> | string
    firstName?: StringWithAggregatesFilter<"Operator"> | string
    lastName?: StringWithAggregatesFilter<"Operator"> | string
    email?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    hireDate?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
    departmentId?: IntNullableWithAggregatesFilter<"Operator"> | number | null
    isActive?: BoolWithAggregatesFilter<"Operator"> | boolean
    basePayRate?: FloatNullableWithAggregatesFilter<"Operator"> | number | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: IntFilter<"Skill"> | number
    code?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringFilter<"Skill"> | string
    isCore?: BoolFilter<"Skill"> | boolean
    isCertification?: BoolFilter<"Skill"> | boolean
    expiryMonths?: IntNullableFilter<"Skill"> | number | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    competencies?: OperatorCompetencyListRelationFilter
    skillRequirements?: SkillRequirementListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isCore?: SortOrder
    isCertification?: SortOrder
    expiryMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    competencies?: OperatorCompetencyOrderByRelationAggregateInput
    skillRequirements?: SkillRequirementOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    category?: StringFilter<"Skill"> | string
    isCore?: BoolFilter<"Skill"> | boolean
    isCertification?: BoolFilter<"Skill"> | boolean
    expiryMonths?: IntNullableFilter<"Skill"> | number | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    competencies?: OperatorCompetencyListRelationFilter
    skillRequirements?: SkillRequirementListRelationFilter
  }, "id" | "code">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isCore?: SortOrder
    isCertification?: SortOrder
    expiryMonths?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _avg?: SkillAvgOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
    _sum?: SkillSumOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Skill"> | number
    code?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    category?: StringWithAggregatesFilter<"Skill"> | string
    isCore?: BoolWithAggregatesFilter<"Skill"> | boolean
    isCertification?: BoolWithAggregatesFilter<"Skill"> | boolean
    expiryMonths?: IntNullableWithAggregatesFilter<"Skill"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type OperatorCompetencyWhereInput = {
    AND?: OperatorCompetencyWhereInput | OperatorCompetencyWhereInput[]
    OR?: OperatorCompetencyWhereInput[]
    NOT?: OperatorCompetencyWhereInput | OperatorCompetencyWhereInput[]
    id?: IntFilter<"OperatorCompetency"> | number
    operatorId?: IntFilter<"OperatorCompetency"> | number
    skillId?: IntFilter<"OperatorCompetency"> | number
    level?: IntFilter<"OperatorCompetency"> | number
    certifiedAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    certifiedBy?: StringNullableFilter<"OperatorCompetency"> | string | null
    notes?: StringNullableFilter<"OperatorCompetency"> | string | null
    isActive?: BoolFilter<"OperatorCompetency"> | boolean
    createdAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
    updatedAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
  }

  export type OperatorCompetencyOrderByWithRelationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    certifiedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    certifiedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skill?: SkillOrderByWithRelationInput
    operator?: OperatorOrderByWithRelationInput
  }

  export type OperatorCompetencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operatorId_skillId?: OperatorCompetencyOperatorIdSkillIdCompoundUniqueInput
    AND?: OperatorCompetencyWhereInput | OperatorCompetencyWhereInput[]
    OR?: OperatorCompetencyWhereInput[]
    NOT?: OperatorCompetencyWhereInput | OperatorCompetencyWhereInput[]
    operatorId?: IntFilter<"OperatorCompetency"> | number
    skillId?: IntFilter<"OperatorCompetency"> | number
    level?: IntFilter<"OperatorCompetency"> | number
    certifiedAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    certifiedBy?: StringNullableFilter<"OperatorCompetency"> | string | null
    notes?: StringNullableFilter<"OperatorCompetency"> | string | null
    isActive?: BoolFilter<"OperatorCompetency"> | boolean
    createdAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
    updatedAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
  }, "id" | "operatorId_skillId">

  export type OperatorCompetencyOrderByWithAggregationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    certifiedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    certifiedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperatorCompetencyCountOrderByAggregateInput
    _avg?: OperatorCompetencyAvgOrderByAggregateInput
    _max?: OperatorCompetencyMaxOrderByAggregateInput
    _min?: OperatorCompetencyMinOrderByAggregateInput
    _sum?: OperatorCompetencySumOrderByAggregateInput
  }

  export type OperatorCompetencyScalarWhereWithAggregatesInput = {
    AND?: OperatorCompetencyScalarWhereWithAggregatesInput | OperatorCompetencyScalarWhereWithAggregatesInput[]
    OR?: OperatorCompetencyScalarWhereWithAggregatesInput[]
    NOT?: OperatorCompetencyScalarWhereWithAggregatesInput | OperatorCompetencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperatorCompetency"> | number
    operatorId?: IntWithAggregatesFilter<"OperatorCompetency"> | number
    skillId?: IntWithAggregatesFilter<"OperatorCompetency"> | number
    level?: IntWithAggregatesFilter<"OperatorCompetency"> | number
    certifiedAt?: DateTimeNullableWithAggregatesFilter<"OperatorCompetency"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"OperatorCompetency"> | Date | string | null
    certifiedBy?: StringNullableWithAggregatesFilter<"OperatorCompetency"> | string | null
    notes?: StringNullableWithAggregatesFilter<"OperatorCompetency"> | string | null
    isActive?: BoolWithAggregatesFilter<"OperatorCompetency"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OperatorCompetency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OperatorCompetency"> | Date | string
  }

  export type SkillRequirementWhereInput = {
    AND?: SkillRequirementWhereInput | SkillRequirementWhereInput[]
    OR?: SkillRequirementWhereInput[]
    NOT?: SkillRequirementWhereInput | SkillRequirementWhereInput[]
    id?: IntFilter<"SkillRequirement"> | number
    workcenterId?: IntFilter<"SkillRequirement"> | number
    skillId?: IntFilter<"SkillRequirement"> | number
    minLevel?: IntFilter<"SkillRequirement"> | number
    isRequired?: BoolFilter<"SkillRequirement"> | boolean
    shiftType?: StringNullableFilter<"SkillRequirement"> | string | null
    createdAt?: DateTimeFilter<"SkillRequirement"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }

  export type SkillRequirementOrderByWithRelationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    isRequired?: SortOrder
    shiftType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    skill?: SkillOrderByWithRelationInput
    workcenter?: WorkcenterOrderByWithRelationInput
  }

  export type SkillRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    workcenterId_skillId_shiftType?: SkillRequirementWorkcenterIdSkillIdShiftTypeCompoundUniqueInput
    AND?: SkillRequirementWhereInput | SkillRequirementWhereInput[]
    OR?: SkillRequirementWhereInput[]
    NOT?: SkillRequirementWhereInput | SkillRequirementWhereInput[]
    workcenterId?: IntFilter<"SkillRequirement"> | number
    skillId?: IntFilter<"SkillRequirement"> | number
    minLevel?: IntFilter<"SkillRequirement"> | number
    isRequired?: BoolFilter<"SkillRequirement"> | boolean
    shiftType?: StringNullableFilter<"SkillRequirement"> | string | null
    createdAt?: DateTimeFilter<"SkillRequirement"> | Date | string
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
  }, "id" | "workcenterId_skillId_shiftType">

  export type SkillRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    isRequired?: SortOrder
    shiftType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SkillRequirementCountOrderByAggregateInput
    _avg?: SkillRequirementAvgOrderByAggregateInput
    _max?: SkillRequirementMaxOrderByAggregateInput
    _min?: SkillRequirementMinOrderByAggregateInput
    _sum?: SkillRequirementSumOrderByAggregateInput
  }

  export type SkillRequirementScalarWhereWithAggregatesInput = {
    AND?: SkillRequirementScalarWhereWithAggregatesInput | SkillRequirementScalarWhereWithAggregatesInput[]
    OR?: SkillRequirementScalarWhereWithAggregatesInput[]
    NOT?: SkillRequirementScalarWhereWithAggregatesInput | SkillRequirementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SkillRequirement"> | number
    workcenterId?: IntWithAggregatesFilter<"SkillRequirement"> | number
    skillId?: IntWithAggregatesFilter<"SkillRequirement"> | number
    minLevel?: IntWithAggregatesFilter<"SkillRequirement"> | number
    isRequired?: BoolWithAggregatesFilter<"SkillRequirement"> | boolean
    shiftType?: StringNullableWithAggregatesFilter<"SkillRequirement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SkillRequirement"> | Date | string
  }

  export type ShiftPatternWhereInput = {
    AND?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    OR?: ShiftPatternWhereInput[]
    NOT?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    id?: IntFilter<"ShiftPattern"> | number
    name?: StringFilter<"ShiftPattern"> | string
    description?: StringNullableFilter<"ShiftPattern"> | string | null
    startTime?: StringFilter<"ShiftPattern"> | string
    endTime?: StringFilter<"ShiftPattern"> | string
    hoursPerShift?: FloatFilter<"ShiftPattern"> | number
    daysPattern?: StringFilter<"ShiftPattern"> | string
    isActive?: BoolFilter<"ShiftPattern"> | boolean
    createdAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    shiftAssignments?: ShiftAssignmentListRelationFilter
  }

  export type ShiftPatternOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hoursPerShift?: SortOrder
    daysPattern?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    shiftAssignments?: ShiftAssignmentOrderByRelationAggregateInput
  }

  export type ShiftPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    OR?: ShiftPatternWhereInput[]
    NOT?: ShiftPatternWhereInput | ShiftPatternWhereInput[]
    description?: StringNullableFilter<"ShiftPattern"> | string | null
    startTime?: StringFilter<"ShiftPattern"> | string
    endTime?: StringFilter<"ShiftPattern"> | string
    hoursPerShift?: FloatFilter<"ShiftPattern"> | number
    daysPattern?: StringFilter<"ShiftPattern"> | string
    isActive?: BoolFilter<"ShiftPattern"> | boolean
    createdAt?: DateTimeFilter<"ShiftPattern"> | Date | string
    shiftAssignments?: ShiftAssignmentListRelationFilter
  }, "id" | "name">

  export type ShiftPatternOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hoursPerShift?: SortOrder
    daysPattern?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ShiftPatternCountOrderByAggregateInput
    _avg?: ShiftPatternAvgOrderByAggregateInput
    _max?: ShiftPatternMaxOrderByAggregateInput
    _min?: ShiftPatternMinOrderByAggregateInput
    _sum?: ShiftPatternSumOrderByAggregateInput
  }

  export type ShiftPatternScalarWhereWithAggregatesInput = {
    AND?: ShiftPatternScalarWhereWithAggregatesInput | ShiftPatternScalarWhereWithAggregatesInput[]
    OR?: ShiftPatternScalarWhereWithAggregatesInput[]
    NOT?: ShiftPatternScalarWhereWithAggregatesInput | ShiftPatternScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShiftPattern"> | number
    name?: StringWithAggregatesFilter<"ShiftPattern"> | string
    description?: StringNullableWithAggregatesFilter<"ShiftPattern"> | string | null
    startTime?: StringWithAggregatesFilter<"ShiftPattern"> | string
    endTime?: StringWithAggregatesFilter<"ShiftPattern"> | string
    hoursPerShift?: FloatWithAggregatesFilter<"ShiftPattern"> | number
    daysPattern?: StringWithAggregatesFilter<"ShiftPattern"> | string
    isActive?: BoolWithAggregatesFilter<"ShiftPattern"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ShiftPattern"> | Date | string
  }

  export type ShiftAssignmentWhereInput = {
    AND?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    OR?: ShiftAssignmentWhereInput[]
    NOT?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    id?: IntFilter<"ShiftAssignment"> | number
    operatorId?: IntFilter<"ShiftAssignment"> | number
    workcenterId?: IntFilter<"ShiftAssignment"> | number
    shiftPatternId?: IntFilter<"ShiftAssignment"> | number
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    role?: StringFilter<"ShiftAssignment"> | string
    payRate?: FloatNullableFilter<"ShiftAssignment"> | number | null
    notes?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    shiftPattern?: XOR<ShiftPatternRelationFilter, ShiftPatternWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
  }

  export type ShiftAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    payRate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shiftPattern?: ShiftPatternOrderByWithRelationInput
    workcenter?: WorkcenterOrderByWithRelationInput
    operator?: OperatorOrderByWithRelationInput
  }

  export type ShiftAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    operatorId_workcenterId_startDate?: ShiftAssignmentOperatorIdWorkcenterIdStartDateCompoundUniqueInput
    AND?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    OR?: ShiftAssignmentWhereInput[]
    NOT?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    operatorId?: IntFilter<"ShiftAssignment"> | number
    workcenterId?: IntFilter<"ShiftAssignment"> | number
    shiftPatternId?: IntFilter<"ShiftAssignment"> | number
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    role?: StringFilter<"ShiftAssignment"> | string
    payRate?: FloatNullableFilter<"ShiftAssignment"> | number | null
    notes?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    shiftPattern?: XOR<ShiftPatternRelationFilter, ShiftPatternWhereInput>
    workcenter?: XOR<WorkcenterRelationFilter, WorkcenterWhereInput>
    operator?: XOR<OperatorRelationFilter, OperatorWhereInput>
  }, "id" | "operatorId_workcenterId_startDate">

  export type ShiftAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    payRate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftAssignmentCountOrderByAggregateInput
    _avg?: ShiftAssignmentAvgOrderByAggregateInput
    _max?: ShiftAssignmentMaxOrderByAggregateInput
    _min?: ShiftAssignmentMinOrderByAggregateInput
    _sum?: ShiftAssignmentSumOrderByAggregateInput
  }

  export type ShiftAssignmentScalarWhereWithAggregatesInput = {
    AND?: ShiftAssignmentScalarWhereWithAggregatesInput | ShiftAssignmentScalarWhereWithAggregatesInput[]
    OR?: ShiftAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ShiftAssignmentScalarWhereWithAggregatesInput | ShiftAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShiftAssignment"> | number
    operatorId?: IntWithAggregatesFilter<"ShiftAssignment"> | number
    workcenterId?: IntWithAggregatesFilter<"ShiftAssignment"> | number
    shiftPatternId?: IntWithAggregatesFilter<"ShiftAssignment"> | number
    startDate?: DateTimeWithAggregatesFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ShiftAssignment"> | boolean
    role?: StringWithAggregatesFilter<"ShiftAssignment"> | string
    payRate?: FloatNullableWithAggregatesFilter<"ShiftAssignment"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShiftAssignment"> | Date | string
  }

  export type PlantCreateInput = {
    name: string
    departments?: DepartmentCreateNestedManyWithoutPlantInput
    holidays?: HolidayCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterCreateNestedManyWithoutPlantInput
  }

  export type PlantUncheckedCreateInput = {
    id?: number
    name: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutPlantInput
    holidays?: HolidayUncheckedCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutPlantNestedInput
    holidays?: HolidayUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUpdateManyWithoutPlantNestedInput
  }

  export type PlantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutPlantNestedInput
    holidays?: HolidayUncheckedUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCreateManyInput = {
    id?: number
    name: string
  }

  export type PlantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateInput = {
    name: string
    plant: PlantCreateNestedOneWithoutDepartmentsInput
    operators?: OperatorCreateNestedManyWithoutDepartmentInput
    workcenters?: WorkcenterCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    plantId: number
    name: string
    operators?: OperatorUncheckedCreateNestedManyWithoutDepartmentInput
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plant?: PlantUpdateOneRequiredWithoutDepartmentsNestedInput
    operators?: OperatorUpdateManyWithoutDepartmentNestedInput
    workcenters?: WorkcenterUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    operators?: OperatorUncheckedUpdateManyWithoutDepartmentNestedInput
    workcenters?: WorkcenterUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    plantId: number
    name: string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WorkcenterCreateInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterUpdateInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type WorkcenterCreateManyInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
  }

  export type WorkcenterUpdateManyMutationInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkcenterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayCreateInput = {
    date: Date | string
    label?: string | null
    plant: PlantCreateNestedOneWithoutHolidaysInput
  }

  export type HolidayUncheckedCreateInput = {
    id?: number
    plantId: number
    date: Date | string
    label?: string | null
  }

  export type HolidayUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    plant?: PlantUpdateOneRequiredWithoutHolidaysNestedInput
  }

  export type HolidayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayCreateManyInput = {
    id?: number
    plantId: number
    date: Date | string
    label?: string | null
  }

  export type HolidayUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SKUCreateInput = {
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    orders?: OrderCreateNestedManyWithoutSkuInput
    products?: ProductCreateNestedManyWithoutSkuInput
  }

  export type SKUUncheckedCreateInput = {
    id?: number
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutSkuInput
    products?: ProductUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SKUUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutSkuNestedInput
    products?: ProductUpdateManyWithoutSkuNestedInput
  }

  export type SKUUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutSkuNestedInput
    products?: ProductUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type SKUCreateManyInput = {
    id?: number
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
  }

  export type SKUUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SKUUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    name: string
    sku: SKUCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    skuId: number
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sku?: SKUUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    skuId: number
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
  }

  export type OrderCreateInput = {
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
    plannedWorkcenter?: WorkcenterCreateNestedOneWithoutOrdersInput
    sku: SKUCreateNestedOneWithoutOrdersInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    workcenterId?: number | null
    shopfloorTitle?: string | null
    colorHex?: string | null
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWorkcenter?: WorkcenterUpdateOneWithoutOrdersNestedInput
    sku?: SKUUpdateOneRequiredWithoutOrdersNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenterId?: NullableIntFieldUpdateOperationsInput | number | null
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    workcenterId?: number | null
    shopfloorTitle?: string | null
    colorHex?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenterId?: NullableIntFieldUpdateOperationsInput | number | null
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleBlockCreateInput = {
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverCreateNestedManyWithoutFromBlockInput
    order?: OrderCreateNestedOneWithoutScheduleBlocksInput
    workcenter: WorkcenterCreateNestedOneWithoutScheduleBlocksInput
  }

  export type ScheduleBlockUncheckedCreateInput = {
    id?: number
    workcenterId: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutFromBlockInput
  }

  export type ScheduleBlockUpdateInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUpdateManyWithoutFromBlockNestedInput
    order?: OrderUpdateOneWithoutScheduleBlocksNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutScheduleBlocksNestedInput
  }

  export type ScheduleBlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUncheckedUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUncheckedUpdateManyWithoutFromBlockNestedInput
  }

  export type ScheduleBlockCreateManyInput = {
    id?: number
    workcenterId: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
  }

  export type ScheduleBlockUpdateManyMutationInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleBlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeoverCreateInput = {
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
    toBlock: ScheduleBlockCreateNestedOneWithoutToChangeoversInput
    fromBlock: ScheduleBlockCreateNestedOneWithoutFromChangeoversInput
    workcenter: WorkcenterCreateNestedOneWithoutChangeoversInput
  }

  export type ChangeoverUncheckedCreateInput = {
    id?: number
    workcenterId: number
    fromBlockId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverUpdateInput = {
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
    toBlock?: ScheduleBlockUpdateOneRequiredWithoutToChangeoversNestedInput
    fromBlock?: ScheduleBlockUpdateOneRequiredWithoutFromChangeoversNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutChangeoversNestedInput
  }

  export type ChangeoverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverCreateManyInput = {
    id?: number
    workcenterId: number
    fromBlockId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverUpdateManyMutationInput = {
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperatorCreateInput = {
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutOperatorsInput
    competencies?: OperatorCompetencyCreateNestedManyWithoutOperatorInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    departmentId?: number | null
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    competencies?: OperatorCompetencyUncheckedCreateNestedManyWithoutOperatorInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutOperatorsNestedInput
    competencies?: OperatorCompetencyUpdateManyWithoutOperatorNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUncheckedUpdateManyWithoutOperatorNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorCreateManyInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    departmentId?: number | null
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    competencies?: OperatorCompetencyCreateNestedManyWithoutSkillInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    competencies?: OperatorCompetencyUncheckedCreateNestedManyWithoutSkillInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUpdateManyWithoutSkillNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUncheckedUpdateManyWithoutSkillNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyCreateInput = {
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutCompetenciesInput
    operator: OperatorCreateNestedOneWithoutCompetenciesInput
  }

  export type OperatorCompetencyUncheckedCreateInput = {
    id?: number
    operatorId: number
    skillId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorCompetencyUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCompetenciesNestedInput
    operator?: OperatorUpdateOneRequiredWithoutCompetenciesNestedInput
  }

  export type OperatorCompetencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyCreateManyInput = {
    id?: number
    operatorId: number
    skillId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorCompetencyUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementCreateInput = {
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
    skill: SkillCreateNestedOneWithoutSkillRequirementsInput
    workcenter: WorkcenterCreateNestedOneWithoutSkillRequirementsInput
  }

  export type SkillRequirementUncheckedCreateInput = {
    id?: number
    workcenterId: number
    skillId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type SkillRequirementUpdateInput = {
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutSkillRequirementsNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutSkillRequirementsNestedInput
  }

  export type SkillRequirementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementCreateManyInput = {
    id?: number
    workcenterId: number
    skillId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type SkillRequirementUpdateManyMutationInput = {
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternCreateInput = {
    name: string
    description?: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive?: boolean
    createdAt?: Date | string
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutShiftPatternInput
  }

  export type ShiftPatternUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive?: boolean
    createdAt?: Date | string
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutShiftPatternInput
  }

  export type ShiftPatternUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutShiftPatternNestedInput
  }

  export type ShiftPatternUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutShiftPatternNestedInput
  }

  export type ShiftPatternCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ShiftPatternUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentCreateInput = {
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shiftPattern: ShiftPatternCreateNestedOneWithoutShiftAssignmentsInput
    workcenter: WorkcenterCreateNestedOneWithoutShiftAssignmentsInput
    operator: OperatorCreateNestedOneWithoutShiftAssignmentsInput
  }

  export type ShiftAssignmentUncheckedCreateInput = {
    id?: number
    operatorId: number
    workcenterId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftPattern?: ShiftPatternUpdateOneRequiredWithoutShiftAssignmentsNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutShiftAssignmentsNestedInput
    operator?: OperatorUpdateOneRequiredWithoutShiftAssignmentsNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentCreateManyInput = {
    id?: number
    operatorId: number
    workcenterId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type HolidayListRelationFilter = {
    every?: HolidayWhereInput
    some?: HolidayWhereInput
    none?: HolidayWhereInput
  }

  export type WorkcenterListRelationFilter = {
    every?: WorkcenterWhereInput
    some?: WorkcenterWhereInput
    none?: WorkcenterWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HolidayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkcenterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlantAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PlantSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type PlantRelationFilter = {
    is?: PlantWhereInput
    isNot?: PlantWhereInput
  }

  export type OperatorListRelationFilter = {
    every?: OperatorWhereInput
    some?: OperatorWhereInput
    none?: OperatorWhereInput
  }

  export type OperatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    name?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    name?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    name?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ChangeoverListRelationFilter = {
    every?: ChangeoverWhereInput
    some?: ChangeoverWhereInput
    none?: ChangeoverWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ScheduleBlockListRelationFilter = {
    every?: ScheduleBlockWhereInput
    some?: ScheduleBlockWhereInput
    none?: ScheduleBlockWhereInput
  }

  export type ShiftAssignmentListRelationFilter = {
    every?: ShiftAssignmentWhereInput
    some?: ShiftAssignmentWhereInput
    none?: ShiftAssignmentWhereInput
  }

  export type SkillRequirementListRelationFilter = {
    every?: SkillRequirementWhereInput
    some?: SkillRequirementWhereInput
    none?: SkillRequirementWhereInput
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChangeoverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkcenterPlantIdWorkcenterNoCompoundUniqueInput = {
    plantId: number
    workcenterNo: string
  }

  export type WorkcenterCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    workcenterNo?: SortOrder
    name?: SortOrder
    displayTitle?: SortOrder
    defaultSchemeId?: SortOrder
    minStaff?: SortOrder
    gatingRules?: SortOrder
    changeoverFamily?: SortOrder
  }

  export type WorkcenterAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    defaultSchemeId?: SortOrder
    minStaff?: SortOrder
  }

  export type WorkcenterMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    workcenterNo?: SortOrder
    name?: SortOrder
    displayTitle?: SortOrder
    defaultSchemeId?: SortOrder
    minStaff?: SortOrder
    gatingRules?: SortOrder
    changeoverFamily?: SortOrder
  }

  export type WorkcenterMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    workcenterNo?: SortOrder
    name?: SortOrder
    displayTitle?: SortOrder
    defaultSchemeId?: SortOrder
    minStaff?: SortOrder
    gatingRules?: SortOrder
    changeoverFamily?: SortOrder
  }

  export type WorkcenterSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    departmentId?: SortOrder
    defaultSchemeId?: SortOrder
    minStaff?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    label?: SortOrder
  }

  export type HolidayAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    label?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    label?: SortOrder
  }

  export type HolidaySumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SKUCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    family?: SortOrder
    familyColorHex?: SortOrder
    formula?: SortOrder
    bottleSize?: SortOrder
    caseSize?: SortOrder
  }

  export type SKUAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SKUMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    family?: SortOrder
    familyColorHex?: SortOrder
    formula?: SortOrder
    bottleSize?: SortOrder
    caseSize?: SortOrder
  }

  export type SKUMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    family?: SortOrder
    familyColorHex?: SortOrder
    formula?: SortOrder
    bottleSize?: SortOrder
    caseSize?: SortOrder
  }

  export type SKUSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SKURelationFilter = {
    is?: SKUWhereInput
    isNot?: SKUWhereInput
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    skuId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    skuId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    skuId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WorkcenterNullableRelationFilter = {
    is?: WorkcenterWhereInput | null
    isNot?: WorkcenterWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    dueAt?: SortOrder
    workcenterId?: SortOrder
    shopfloorTitle?: SortOrder
    colorHex?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    workcenterId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    dueAt?: SortOrder
    workcenterId?: SortOrder
    shopfloorTitle?: SortOrder
    colorHex?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    dueAt?: SortOrder
    workcenterId?: SortOrder
    shopfloorTitle?: SortOrder
    colorHex?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    qty?: SortOrder
    runRateUph?: SortOrder
    performanceLeverPct?: SortOrder
    priority?: SortOrder
    workcenterId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type WorkcenterRelationFilter = {
    is?: WorkcenterWhereInput
    isNot?: WorkcenterWhereInput
  }

  export type ScheduleBlockCountOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type ScheduleBlockAvgOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrder
  }

  export type ScheduleBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type ScheduleBlockMinOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type ScheduleBlockSumOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    orderId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ScheduleBlockRelationFilter = {
    is?: ScheduleBlockWhereInput
    isNot?: ScheduleBlockWhereInput
  }

  export type ChangeoverCountOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    typeCode?: SortOrder
    plannedMinutes?: SortOrder
    includeInOee?: SortOrder
    complexityTier?: SortOrder
  }

  export type ChangeoverAvgOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    plannedMinutes?: SortOrder
  }

  export type ChangeoverMaxOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    typeCode?: SortOrder
    plannedMinutes?: SortOrder
    includeInOee?: SortOrder
    complexityTier?: SortOrder
  }

  export type ChangeoverMinOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    typeCode?: SortOrder
    plannedMinutes?: SortOrder
    includeInOee?: SortOrder
    complexityTier?: SortOrder
  }

  export type ChangeoverSumOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    fromBlockId?: SortOrder
    toBlockId?: SortOrder
    plannedMinutes?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type OperatorCompetencyListRelationFilter = {
    every?: OperatorCompetencyWhereInput
    some?: OperatorCompetencyWhereInput
    none?: OperatorCompetencyWhereInput
  }

  export type OperatorCompetencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatorCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    isActive?: SortOrder
    basePayRate?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    basePayRate?: SortOrder
  }

  export type OperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    isActive?: SortOrder
    basePayRate?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    hireDate?: SortOrder
    departmentId?: SortOrder
    isActive?: SortOrder
    basePayRate?: SortOrder
    emergencyContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    basePayRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCore?: SortOrder
    isCertification?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillAvgOrderByAggregateInput = {
    id?: SortOrder
    expiryMonths?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCore?: SortOrder
    isCertification?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isCore?: SortOrder
    isCertification?: SortOrder
    expiryMonths?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillSumOrderByAggregateInput = {
    id?: SortOrder
    expiryMonths?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type OperatorRelationFilter = {
    is?: OperatorWhereInput
    isNot?: OperatorWhereInput
  }

  export type OperatorCompetencyOperatorIdSkillIdCompoundUniqueInput = {
    operatorId: number
    skillId: number
  }

  export type OperatorCompetencyCountOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    certifiedAt?: SortOrder
    expiresAt?: SortOrder
    certifiedBy?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorCompetencyAvgOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type OperatorCompetencyMaxOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    certifiedAt?: SortOrder
    expiresAt?: SortOrder
    certifiedBy?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorCompetencyMinOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
    certifiedAt?: SortOrder
    expiresAt?: SortOrder
    certifiedBy?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorCompetencySumOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    skillId?: SortOrder
    level?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SkillRequirementWorkcenterIdSkillIdShiftTypeCompoundUniqueInput = {
    workcenterId: number
    skillId: number
    shiftType: string
  }

  export type SkillRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    isRequired?: SortOrder
    shiftType?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillRequirementAvgOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
  }

  export type SkillRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    isRequired?: SortOrder
    shiftType?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
    isRequired?: SortOrder
    shiftType?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillRequirementSumOrderByAggregateInput = {
    id?: SortOrder
    workcenterId?: SortOrder
    skillId?: SortOrder
    minLevel?: SortOrder
  }

  export type ShiftPatternCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hoursPerShift?: SortOrder
    daysPattern?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftPatternAvgOrderByAggregateInput = {
    id?: SortOrder
    hoursPerShift?: SortOrder
  }

  export type ShiftPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hoursPerShift?: SortOrder
    daysPattern?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftPatternMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hoursPerShift?: SortOrder
    daysPattern?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftPatternSumOrderByAggregateInput = {
    id?: SortOrder
    hoursPerShift?: SortOrder
  }

  export type ShiftPatternRelationFilter = {
    is?: ShiftPatternWhereInput
    isNot?: ShiftPatternWhereInput
  }

  export type ShiftAssignmentOperatorIdWorkcenterIdStartDateCompoundUniqueInput = {
    operatorId: number
    workcenterId: number
    startDate: Date | string
  }

  export type ShiftAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    payRate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    payRate?: SortOrder
  }

  export type ShiftAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    payRate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    payRate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    operatorId?: SortOrder
    workcenterId?: SortOrder
    shiftPatternId?: SortOrder
    payRate?: SortOrder
  }

  export type DepartmentCreateNestedManyWithoutPlantInput = {
    create?: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput> | DepartmentCreateWithoutPlantInput[] | DepartmentUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutPlantInput | DepartmentCreateOrConnectWithoutPlantInput[]
    createMany?: DepartmentCreateManyPlantInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type HolidayCreateNestedManyWithoutPlantInput = {
    create?: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput> | HolidayCreateWithoutPlantInput[] | HolidayUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutPlantInput | HolidayCreateOrConnectWithoutPlantInput[]
    createMany?: HolidayCreateManyPlantInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type WorkcenterCreateNestedManyWithoutPlantInput = {
    create?: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput> | WorkcenterCreateWithoutPlantInput[] | WorkcenterUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutPlantInput | WorkcenterCreateOrConnectWithoutPlantInput[]
    createMany?: WorkcenterCreateManyPlantInputEnvelope
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput> | DepartmentCreateWithoutPlantInput[] | DepartmentUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutPlantInput | DepartmentCreateOrConnectWithoutPlantInput[]
    createMany?: DepartmentCreateManyPlantInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type HolidayUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput> | HolidayCreateWithoutPlantInput[] | HolidayUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutPlantInput | HolidayCreateOrConnectWithoutPlantInput[]
    createMany?: HolidayCreateManyPlantInputEnvelope
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
  }

  export type WorkcenterUncheckedCreateNestedManyWithoutPlantInput = {
    create?: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput> | WorkcenterCreateWithoutPlantInput[] | WorkcenterUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutPlantInput | WorkcenterCreateOrConnectWithoutPlantInput[]
    createMany?: WorkcenterCreateManyPlantInputEnvelope
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DepartmentUpdateManyWithoutPlantNestedInput = {
    create?: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput> | DepartmentCreateWithoutPlantInput[] | DepartmentUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutPlantInput | DepartmentCreateOrConnectWithoutPlantInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutPlantInput | DepartmentUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: DepartmentCreateManyPlantInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutPlantInput | DepartmentUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutPlantInput | DepartmentUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type HolidayUpdateManyWithoutPlantNestedInput = {
    create?: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput> | HolidayCreateWithoutPlantInput[] | HolidayUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutPlantInput | HolidayCreateOrConnectWithoutPlantInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutPlantInput | HolidayUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: HolidayCreateManyPlantInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutPlantInput | HolidayUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutPlantInput | HolidayUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type WorkcenterUpdateManyWithoutPlantNestedInput = {
    create?: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput> | WorkcenterCreateWithoutPlantInput[] | WorkcenterUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutPlantInput | WorkcenterCreateOrConnectWithoutPlantInput[]
    upsert?: WorkcenterUpsertWithWhereUniqueWithoutPlantInput | WorkcenterUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: WorkcenterCreateManyPlantInputEnvelope
    set?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    disconnect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    delete?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    update?: WorkcenterUpdateWithWhereUniqueWithoutPlantInput | WorkcenterUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: WorkcenterUpdateManyWithWhereWithoutPlantInput | WorkcenterUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput> | DepartmentCreateWithoutPlantInput[] | DepartmentUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutPlantInput | DepartmentCreateOrConnectWithoutPlantInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutPlantInput | DepartmentUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: DepartmentCreateManyPlantInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutPlantInput | DepartmentUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutPlantInput | DepartmentUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type HolidayUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput> | HolidayCreateWithoutPlantInput[] | HolidayUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: HolidayCreateOrConnectWithoutPlantInput | HolidayCreateOrConnectWithoutPlantInput[]
    upsert?: HolidayUpsertWithWhereUniqueWithoutPlantInput | HolidayUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: HolidayCreateManyPlantInputEnvelope
    set?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    disconnect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    delete?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    connect?: HolidayWhereUniqueInput | HolidayWhereUniqueInput[]
    update?: HolidayUpdateWithWhereUniqueWithoutPlantInput | HolidayUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: HolidayUpdateManyWithWhereWithoutPlantInput | HolidayUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
  }

  export type WorkcenterUncheckedUpdateManyWithoutPlantNestedInput = {
    create?: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput> | WorkcenterCreateWithoutPlantInput[] | WorkcenterUncheckedCreateWithoutPlantInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutPlantInput | WorkcenterCreateOrConnectWithoutPlantInput[]
    upsert?: WorkcenterUpsertWithWhereUniqueWithoutPlantInput | WorkcenterUpsertWithWhereUniqueWithoutPlantInput[]
    createMany?: WorkcenterCreateManyPlantInputEnvelope
    set?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    disconnect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    delete?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    update?: WorkcenterUpdateWithWhereUniqueWithoutPlantInput | WorkcenterUpdateWithWhereUniqueWithoutPlantInput[]
    updateMany?: WorkcenterUpdateManyWithWhereWithoutPlantInput | WorkcenterUpdateManyWithWhereWithoutPlantInput[]
    deleteMany?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
  }

  export type PlantCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<PlantCreateWithoutDepartmentsInput, PlantUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: PlantCreateOrConnectWithoutDepartmentsInput
    connect?: PlantWhereUniqueInput
  }

  export type OperatorCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput> | OperatorCreateWithoutDepartmentInput[] | OperatorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutDepartmentInput | OperatorCreateOrConnectWithoutDepartmentInput[]
    createMany?: OperatorCreateManyDepartmentInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type WorkcenterCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput> | WorkcenterCreateWithoutDepartmentInput[] | WorkcenterUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutDepartmentInput | WorkcenterCreateOrConnectWithoutDepartmentInput[]
    createMany?: WorkcenterCreateManyDepartmentInputEnvelope
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
  }

  export type OperatorUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput> | OperatorCreateWithoutDepartmentInput[] | OperatorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutDepartmentInput | OperatorCreateOrConnectWithoutDepartmentInput[]
    createMany?: OperatorCreateManyDepartmentInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type WorkcenterUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput> | WorkcenterCreateWithoutDepartmentInput[] | WorkcenterUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutDepartmentInput | WorkcenterCreateOrConnectWithoutDepartmentInput[]
    createMany?: WorkcenterCreateManyDepartmentInputEnvelope
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
  }

  export type PlantUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<PlantCreateWithoutDepartmentsInput, PlantUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: PlantCreateOrConnectWithoutDepartmentsInput
    upsert?: PlantUpsertWithoutDepartmentsInput
    connect?: PlantWhereUniqueInput
    update?: XOR<XOR<PlantUpdateToOneWithWhereWithoutDepartmentsInput, PlantUpdateWithoutDepartmentsInput>, PlantUncheckedUpdateWithoutDepartmentsInput>
  }

  export type OperatorUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput> | OperatorCreateWithoutDepartmentInput[] | OperatorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutDepartmentInput | OperatorCreateOrConnectWithoutDepartmentInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutDepartmentInput | OperatorUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: OperatorCreateManyDepartmentInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutDepartmentInput | OperatorUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutDepartmentInput | OperatorUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type WorkcenterUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput> | WorkcenterCreateWithoutDepartmentInput[] | WorkcenterUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutDepartmentInput | WorkcenterCreateOrConnectWithoutDepartmentInput[]
    upsert?: WorkcenterUpsertWithWhereUniqueWithoutDepartmentInput | WorkcenterUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: WorkcenterCreateManyDepartmentInputEnvelope
    set?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    disconnect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    delete?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    update?: WorkcenterUpdateWithWhereUniqueWithoutDepartmentInput | WorkcenterUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: WorkcenterUpdateManyWithWhereWithoutDepartmentInput | WorkcenterUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
  }

  export type OperatorUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput> | OperatorCreateWithoutDepartmentInput[] | OperatorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutDepartmentInput | OperatorCreateOrConnectWithoutDepartmentInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutDepartmentInput | OperatorUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: OperatorCreateManyDepartmentInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutDepartmentInput | OperatorUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutDepartmentInput | OperatorUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type WorkcenterUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput> | WorkcenterCreateWithoutDepartmentInput[] | WorkcenterUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WorkcenterCreateOrConnectWithoutDepartmentInput | WorkcenterCreateOrConnectWithoutDepartmentInput[]
    upsert?: WorkcenterUpsertWithWhereUniqueWithoutDepartmentInput | WorkcenterUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: WorkcenterCreateManyDepartmentInputEnvelope
    set?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    disconnect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    delete?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    connect?: WorkcenterWhereUniqueInput | WorkcenterWhereUniqueInput[]
    update?: WorkcenterUpdateWithWhereUniqueWithoutDepartmentInput | WorkcenterUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: WorkcenterUpdateManyWithWhereWithoutDepartmentInput | WorkcenterUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
  }

  export type ChangeoverCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput> | ChangeoverCreateWithoutWorkcenterInput[] | ChangeoverUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutWorkcenterInput | ChangeoverCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ChangeoverCreateManyWorkcenterInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutPlannedWorkcenterInput = {
    create?: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput> | OrderCreateWithoutPlannedWorkcenterInput[] | OrderUncheckedCreateWithoutPlannedWorkcenterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlannedWorkcenterInput | OrderCreateOrConnectWithoutPlannedWorkcenterInput[]
    createMany?: OrderCreateManyPlannedWorkcenterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ScheduleBlockCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput> | ScheduleBlockCreateWithoutWorkcenterInput[] | ScheduleBlockUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutWorkcenterInput | ScheduleBlockCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ScheduleBlockCreateManyWorkcenterInputEnvelope
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
  }

  export type ShiftAssignmentCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput> | ShiftAssignmentCreateWithoutWorkcenterInput[] | ShiftAssignmentUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutWorkcenterInput | ShiftAssignmentCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ShiftAssignmentCreateManyWorkcenterInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type SkillRequirementCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput> | SkillRequirementCreateWithoutWorkcenterInput[] | SkillRequirementUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutWorkcenterInput | SkillRequirementCreateOrConnectWithoutWorkcenterInput[]
    createMany?: SkillRequirementCreateManyWorkcenterInputEnvelope
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutWorkcentersInput = {
    create?: XOR<DepartmentCreateWithoutWorkcentersInput, DepartmentUncheckedCreateWithoutWorkcentersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkcentersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type PlantCreateNestedOneWithoutWorkcentersInput = {
    create?: XOR<PlantCreateWithoutWorkcentersInput, PlantUncheckedCreateWithoutWorkcentersInput>
    connectOrCreate?: PlantCreateOrConnectWithoutWorkcentersInput
    connect?: PlantWhereUniqueInput
  }

  export type ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput> | ChangeoverCreateWithoutWorkcenterInput[] | ChangeoverUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutWorkcenterInput | ChangeoverCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ChangeoverCreateManyWorkcenterInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput = {
    create?: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput> | OrderCreateWithoutPlannedWorkcenterInput[] | OrderUncheckedCreateWithoutPlannedWorkcenterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlannedWorkcenterInput | OrderCreateOrConnectWithoutPlannedWorkcenterInput[]
    createMany?: OrderCreateManyPlannedWorkcenterInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput> | ScheduleBlockCreateWithoutWorkcenterInput[] | ScheduleBlockUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutWorkcenterInput | ScheduleBlockCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ScheduleBlockCreateManyWorkcenterInputEnvelope
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput> | ShiftAssignmentCreateWithoutWorkcenterInput[] | ShiftAssignmentUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutWorkcenterInput | ShiftAssignmentCreateOrConnectWithoutWorkcenterInput[]
    createMany?: ShiftAssignmentCreateManyWorkcenterInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput = {
    create?: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput> | SkillRequirementCreateWithoutWorkcenterInput[] | SkillRequirementUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutWorkcenterInput | SkillRequirementCreateOrConnectWithoutWorkcenterInput[]
    createMany?: SkillRequirementCreateManyWorkcenterInputEnvelope
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChangeoverUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput> | ChangeoverCreateWithoutWorkcenterInput[] | ChangeoverUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutWorkcenterInput | ChangeoverCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutWorkcenterInput | ChangeoverUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ChangeoverCreateManyWorkcenterInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutWorkcenterInput | ChangeoverUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutWorkcenterInput | ChangeoverUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutPlannedWorkcenterNestedInput = {
    create?: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput> | OrderCreateWithoutPlannedWorkcenterInput[] | OrderUncheckedCreateWithoutPlannedWorkcenterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlannedWorkcenterInput | OrderCreateOrConnectWithoutPlannedWorkcenterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPlannedWorkcenterInput | OrderUpsertWithWhereUniqueWithoutPlannedWorkcenterInput[]
    createMany?: OrderCreateManyPlannedWorkcenterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPlannedWorkcenterInput | OrderUpdateWithWhereUniqueWithoutPlannedWorkcenterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPlannedWorkcenterInput | OrderUpdateManyWithWhereWithoutPlannedWorkcenterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ScheduleBlockUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput> | ScheduleBlockCreateWithoutWorkcenterInput[] | ScheduleBlockUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutWorkcenterInput | ScheduleBlockCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ScheduleBlockUpsertWithWhereUniqueWithoutWorkcenterInput | ScheduleBlockUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ScheduleBlockCreateManyWorkcenterInputEnvelope
    set?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    disconnect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    delete?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    update?: ScheduleBlockUpdateWithWhereUniqueWithoutWorkcenterInput | ScheduleBlockUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ScheduleBlockUpdateManyWithWhereWithoutWorkcenterInput | ScheduleBlockUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput> | ShiftAssignmentCreateWithoutWorkcenterInput[] | ShiftAssignmentUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutWorkcenterInput | ShiftAssignmentCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutWorkcenterInput | ShiftAssignmentUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ShiftAssignmentCreateManyWorkcenterInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutWorkcenterInput | ShiftAssignmentUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutWorkcenterInput | ShiftAssignmentUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type SkillRequirementUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput> | SkillRequirementCreateWithoutWorkcenterInput[] | SkillRequirementUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutWorkcenterInput | SkillRequirementCreateOrConnectWithoutWorkcenterInput[]
    upsert?: SkillRequirementUpsertWithWhereUniqueWithoutWorkcenterInput | SkillRequirementUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: SkillRequirementCreateManyWorkcenterInputEnvelope
    set?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    disconnect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    delete?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    update?: SkillRequirementUpdateWithWhereUniqueWithoutWorkcenterInput | SkillRequirementUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: SkillRequirementUpdateManyWithWhereWithoutWorkcenterInput | SkillRequirementUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
  }

  export type DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput = {
    create?: XOR<DepartmentCreateWithoutWorkcentersInput, DepartmentUncheckedCreateWithoutWorkcentersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkcentersInput
    upsert?: DepartmentUpsertWithoutWorkcentersInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutWorkcentersInput, DepartmentUpdateWithoutWorkcentersInput>, DepartmentUncheckedUpdateWithoutWorkcentersInput>
  }

  export type PlantUpdateOneRequiredWithoutWorkcentersNestedInput = {
    create?: XOR<PlantCreateWithoutWorkcentersInput, PlantUncheckedCreateWithoutWorkcentersInput>
    connectOrCreate?: PlantCreateOrConnectWithoutWorkcentersInput
    upsert?: PlantUpsertWithoutWorkcentersInput
    connect?: PlantWhereUniqueInput
    update?: XOR<XOR<PlantUpdateToOneWithWhereWithoutWorkcentersInput, PlantUpdateWithoutWorkcentersInput>, PlantUncheckedUpdateWithoutWorkcentersInput>
  }

  export type ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput> | ChangeoverCreateWithoutWorkcenterInput[] | ChangeoverUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutWorkcenterInput | ChangeoverCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutWorkcenterInput | ChangeoverUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ChangeoverCreateManyWorkcenterInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutWorkcenterInput | ChangeoverUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutWorkcenterInput | ChangeoverUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput = {
    create?: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput> | OrderCreateWithoutPlannedWorkcenterInput[] | OrderUncheckedCreateWithoutPlannedWorkcenterInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlannedWorkcenterInput | OrderCreateOrConnectWithoutPlannedWorkcenterInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPlannedWorkcenterInput | OrderUpsertWithWhereUniqueWithoutPlannedWorkcenterInput[]
    createMany?: OrderCreateManyPlannedWorkcenterInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPlannedWorkcenterInput | OrderUpdateWithWhereUniqueWithoutPlannedWorkcenterInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPlannedWorkcenterInput | OrderUpdateManyWithWhereWithoutPlannedWorkcenterInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput> | ScheduleBlockCreateWithoutWorkcenterInput[] | ScheduleBlockUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutWorkcenterInput | ScheduleBlockCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ScheduleBlockUpsertWithWhereUniqueWithoutWorkcenterInput | ScheduleBlockUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ScheduleBlockCreateManyWorkcenterInputEnvelope
    set?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    disconnect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    delete?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    update?: ScheduleBlockUpdateWithWhereUniqueWithoutWorkcenterInput | ScheduleBlockUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ScheduleBlockUpdateManyWithWhereWithoutWorkcenterInput | ScheduleBlockUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput> | ShiftAssignmentCreateWithoutWorkcenterInput[] | ShiftAssignmentUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutWorkcenterInput | ShiftAssignmentCreateOrConnectWithoutWorkcenterInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutWorkcenterInput | ShiftAssignmentUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: ShiftAssignmentCreateManyWorkcenterInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutWorkcenterInput | ShiftAssignmentUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutWorkcenterInput | ShiftAssignmentUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput = {
    create?: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput> | SkillRequirementCreateWithoutWorkcenterInput[] | SkillRequirementUncheckedCreateWithoutWorkcenterInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutWorkcenterInput | SkillRequirementCreateOrConnectWithoutWorkcenterInput[]
    upsert?: SkillRequirementUpsertWithWhereUniqueWithoutWorkcenterInput | SkillRequirementUpsertWithWhereUniqueWithoutWorkcenterInput[]
    createMany?: SkillRequirementCreateManyWorkcenterInputEnvelope
    set?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    disconnect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    delete?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    update?: SkillRequirementUpdateWithWhereUniqueWithoutWorkcenterInput | SkillRequirementUpdateWithWhereUniqueWithoutWorkcenterInput[]
    updateMany?: SkillRequirementUpdateManyWithWhereWithoutWorkcenterInput | SkillRequirementUpdateManyWithWhereWithoutWorkcenterInput[]
    deleteMany?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
  }

  export type PlantCreateNestedOneWithoutHolidaysInput = {
    create?: XOR<PlantCreateWithoutHolidaysInput, PlantUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: PlantCreateOrConnectWithoutHolidaysInput
    connect?: PlantWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PlantUpdateOneRequiredWithoutHolidaysNestedInput = {
    create?: XOR<PlantCreateWithoutHolidaysInput, PlantUncheckedCreateWithoutHolidaysInput>
    connectOrCreate?: PlantCreateOrConnectWithoutHolidaysInput
    upsert?: PlantUpsertWithoutHolidaysInput
    connect?: PlantWhereUniqueInput
    update?: XOR<XOR<PlantUpdateToOneWithWhereWithoutHolidaysInput, PlantUpdateWithoutHolidaysInput>, PlantUncheckedUpdateWithoutHolidaysInput>
  }

  export type OrderCreateNestedManyWithoutSkuInput = {
    create?: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput> | OrderCreateWithoutSkuInput[] | OrderUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSkuInput | OrderCreateOrConnectWithoutSkuInput[]
    createMany?: OrderCreateManySkuInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSkuInput = {
    create?: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput> | ProductCreateWithoutSkuInput[] | ProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSkuInput | ProductCreateOrConnectWithoutSkuInput[]
    createMany?: ProductCreateManySkuInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput> | OrderCreateWithoutSkuInput[] | OrderUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSkuInput | OrderCreateOrConnectWithoutSkuInput[]
    createMany?: OrderCreateManySkuInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput> | ProductCreateWithoutSkuInput[] | ProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSkuInput | ProductCreateOrConnectWithoutSkuInput[]
    createMany?: ProductCreateManySkuInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutSkuNestedInput = {
    create?: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput> | OrderCreateWithoutSkuInput[] | OrderUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSkuInput | OrderCreateOrConnectWithoutSkuInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSkuInput | OrderUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: OrderCreateManySkuInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSkuInput | OrderUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSkuInput | OrderUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSkuNestedInput = {
    create?: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput> | ProductCreateWithoutSkuInput[] | ProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSkuInput | ProductCreateOrConnectWithoutSkuInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSkuInput | ProductUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: ProductCreateManySkuInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSkuInput | ProductUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSkuInput | ProductUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput> | OrderCreateWithoutSkuInput[] | OrderUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSkuInput | OrderCreateOrConnectWithoutSkuInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSkuInput | OrderUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: OrderCreateManySkuInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSkuInput | OrderUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSkuInput | OrderUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput> | ProductCreateWithoutSkuInput[] | ProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSkuInput | ProductCreateOrConnectWithoutSkuInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSkuInput | ProductUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: ProductCreateManySkuInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSkuInput | ProductUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSkuInput | ProductUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SKUCreateNestedOneWithoutProductsInput = {
    create?: XOR<SKUCreateWithoutProductsInput, SKUUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SKUCreateOrConnectWithoutProductsInput
    connect?: SKUWhereUniqueInput
  }

  export type SKUUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SKUCreateWithoutProductsInput, SKUUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SKUCreateOrConnectWithoutProductsInput
    upsert?: SKUUpsertWithoutProductsInput
    connect?: SKUWhereUniqueInput
    update?: XOR<XOR<SKUUpdateToOneWithWhereWithoutProductsInput, SKUUpdateWithoutProductsInput>, SKUUncheckedUpdateWithoutProductsInput>
  }

  export type WorkcenterCreateNestedOneWithoutOrdersInput = {
    create?: XOR<WorkcenterCreateWithoutOrdersInput, WorkcenterUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutOrdersInput
    connect?: WorkcenterWhereUniqueInput
  }

  export type SKUCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SKUCreateWithoutOrdersInput, SKUUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SKUCreateOrConnectWithoutOrdersInput
    connect?: SKUWhereUniqueInput
  }

  export type ScheduleBlockCreateNestedManyWithoutOrderInput = {
    create?: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput> | ScheduleBlockCreateWithoutOrderInput[] | ScheduleBlockUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutOrderInput | ScheduleBlockCreateOrConnectWithoutOrderInput[]
    createMany?: ScheduleBlockCreateManyOrderInputEnvelope
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
  }

  export type ScheduleBlockUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput> | ScheduleBlockCreateWithoutOrderInput[] | ScheduleBlockUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutOrderInput | ScheduleBlockCreateOrConnectWithoutOrderInput[]
    createMany?: ScheduleBlockCreateManyOrderInputEnvelope
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkcenterUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<WorkcenterCreateWithoutOrdersInput, WorkcenterUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutOrdersInput
    upsert?: WorkcenterUpsertWithoutOrdersInput
    disconnect?: WorkcenterWhereInput | boolean
    delete?: WorkcenterWhereInput | boolean
    connect?: WorkcenterWhereUniqueInput
    update?: XOR<XOR<WorkcenterUpdateToOneWithWhereWithoutOrdersInput, WorkcenterUpdateWithoutOrdersInput>, WorkcenterUncheckedUpdateWithoutOrdersInput>
  }

  export type SKUUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<SKUCreateWithoutOrdersInput, SKUUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SKUCreateOrConnectWithoutOrdersInput
    upsert?: SKUUpsertWithoutOrdersInput
    connect?: SKUWhereUniqueInput
    update?: XOR<XOR<SKUUpdateToOneWithWhereWithoutOrdersInput, SKUUpdateWithoutOrdersInput>, SKUUncheckedUpdateWithoutOrdersInput>
  }

  export type ScheduleBlockUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput> | ScheduleBlockCreateWithoutOrderInput[] | ScheduleBlockUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutOrderInput | ScheduleBlockCreateOrConnectWithoutOrderInput[]
    upsert?: ScheduleBlockUpsertWithWhereUniqueWithoutOrderInput | ScheduleBlockUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ScheduleBlockCreateManyOrderInputEnvelope
    set?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    disconnect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    delete?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    update?: ScheduleBlockUpdateWithWhereUniqueWithoutOrderInput | ScheduleBlockUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ScheduleBlockUpdateManyWithWhereWithoutOrderInput | ScheduleBlockUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
  }

  export type ScheduleBlockUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput> | ScheduleBlockCreateWithoutOrderInput[] | ScheduleBlockUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutOrderInput | ScheduleBlockCreateOrConnectWithoutOrderInput[]
    upsert?: ScheduleBlockUpsertWithWhereUniqueWithoutOrderInput | ScheduleBlockUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ScheduleBlockCreateManyOrderInputEnvelope
    set?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    disconnect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    delete?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    connect?: ScheduleBlockWhereUniqueInput | ScheduleBlockWhereUniqueInput[]
    update?: ScheduleBlockUpdateWithWhereUniqueWithoutOrderInput | ScheduleBlockUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ScheduleBlockUpdateManyWithWhereWithoutOrderInput | ScheduleBlockUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
  }

  export type ChangeoverCreateNestedManyWithoutToBlockInput = {
    create?: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput> | ChangeoverCreateWithoutToBlockInput[] | ChangeoverUncheckedCreateWithoutToBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutToBlockInput | ChangeoverCreateOrConnectWithoutToBlockInput[]
    createMany?: ChangeoverCreateManyToBlockInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type ChangeoverCreateNestedManyWithoutFromBlockInput = {
    create?: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput> | ChangeoverCreateWithoutFromBlockInput[] | ChangeoverUncheckedCreateWithoutFromBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutFromBlockInput | ChangeoverCreateOrConnectWithoutFromBlockInput[]
    createMany?: ChangeoverCreateManyFromBlockInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutScheduleBlocksInput = {
    create?: XOR<OrderCreateWithoutScheduleBlocksInput, OrderUncheckedCreateWithoutScheduleBlocksInput>
    connectOrCreate?: OrderCreateOrConnectWithoutScheduleBlocksInput
    connect?: OrderWhereUniqueInput
  }

  export type WorkcenterCreateNestedOneWithoutScheduleBlocksInput = {
    create?: XOR<WorkcenterCreateWithoutScheduleBlocksInput, WorkcenterUncheckedCreateWithoutScheduleBlocksInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutScheduleBlocksInput
    connect?: WorkcenterWhereUniqueInput
  }

  export type ChangeoverUncheckedCreateNestedManyWithoutToBlockInput = {
    create?: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput> | ChangeoverCreateWithoutToBlockInput[] | ChangeoverUncheckedCreateWithoutToBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutToBlockInput | ChangeoverCreateOrConnectWithoutToBlockInput[]
    createMany?: ChangeoverCreateManyToBlockInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type ChangeoverUncheckedCreateNestedManyWithoutFromBlockInput = {
    create?: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput> | ChangeoverCreateWithoutFromBlockInput[] | ChangeoverUncheckedCreateWithoutFromBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutFromBlockInput | ChangeoverCreateOrConnectWithoutFromBlockInput[]
    createMany?: ChangeoverCreateManyFromBlockInputEnvelope
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
  }

  export type ChangeoverUpdateManyWithoutToBlockNestedInput = {
    create?: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput> | ChangeoverCreateWithoutToBlockInput[] | ChangeoverUncheckedCreateWithoutToBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutToBlockInput | ChangeoverCreateOrConnectWithoutToBlockInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutToBlockInput | ChangeoverUpsertWithWhereUniqueWithoutToBlockInput[]
    createMany?: ChangeoverCreateManyToBlockInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutToBlockInput | ChangeoverUpdateWithWhereUniqueWithoutToBlockInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutToBlockInput | ChangeoverUpdateManyWithWhereWithoutToBlockInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type ChangeoverUpdateManyWithoutFromBlockNestedInput = {
    create?: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput> | ChangeoverCreateWithoutFromBlockInput[] | ChangeoverUncheckedCreateWithoutFromBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutFromBlockInput | ChangeoverCreateOrConnectWithoutFromBlockInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutFromBlockInput | ChangeoverUpsertWithWhereUniqueWithoutFromBlockInput[]
    createMany?: ChangeoverCreateManyFromBlockInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutFromBlockInput | ChangeoverUpdateWithWhereUniqueWithoutFromBlockInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutFromBlockInput | ChangeoverUpdateManyWithWhereWithoutFromBlockInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutScheduleBlocksNestedInput = {
    create?: XOR<OrderCreateWithoutScheduleBlocksInput, OrderUncheckedCreateWithoutScheduleBlocksInput>
    connectOrCreate?: OrderCreateOrConnectWithoutScheduleBlocksInput
    upsert?: OrderUpsertWithoutScheduleBlocksInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutScheduleBlocksInput, OrderUpdateWithoutScheduleBlocksInput>, OrderUncheckedUpdateWithoutScheduleBlocksInput>
  }

  export type WorkcenterUpdateOneRequiredWithoutScheduleBlocksNestedInput = {
    create?: XOR<WorkcenterCreateWithoutScheduleBlocksInput, WorkcenterUncheckedCreateWithoutScheduleBlocksInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutScheduleBlocksInput
    upsert?: WorkcenterUpsertWithoutScheduleBlocksInput
    connect?: WorkcenterWhereUniqueInput
    update?: XOR<XOR<WorkcenterUpdateToOneWithWhereWithoutScheduleBlocksInput, WorkcenterUpdateWithoutScheduleBlocksInput>, WorkcenterUncheckedUpdateWithoutScheduleBlocksInput>
  }

  export type ChangeoverUncheckedUpdateManyWithoutToBlockNestedInput = {
    create?: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput> | ChangeoverCreateWithoutToBlockInput[] | ChangeoverUncheckedCreateWithoutToBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutToBlockInput | ChangeoverCreateOrConnectWithoutToBlockInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutToBlockInput | ChangeoverUpsertWithWhereUniqueWithoutToBlockInput[]
    createMany?: ChangeoverCreateManyToBlockInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutToBlockInput | ChangeoverUpdateWithWhereUniqueWithoutToBlockInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutToBlockInput | ChangeoverUpdateManyWithWhereWithoutToBlockInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type ChangeoverUncheckedUpdateManyWithoutFromBlockNestedInput = {
    create?: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput> | ChangeoverCreateWithoutFromBlockInput[] | ChangeoverUncheckedCreateWithoutFromBlockInput[]
    connectOrCreate?: ChangeoverCreateOrConnectWithoutFromBlockInput | ChangeoverCreateOrConnectWithoutFromBlockInput[]
    upsert?: ChangeoverUpsertWithWhereUniqueWithoutFromBlockInput | ChangeoverUpsertWithWhereUniqueWithoutFromBlockInput[]
    createMany?: ChangeoverCreateManyFromBlockInputEnvelope
    set?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    disconnect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    delete?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    connect?: ChangeoverWhereUniqueInput | ChangeoverWhereUniqueInput[]
    update?: ChangeoverUpdateWithWhereUniqueWithoutFromBlockInput | ChangeoverUpdateWithWhereUniqueWithoutFromBlockInput[]
    updateMany?: ChangeoverUpdateManyWithWhereWithoutFromBlockInput | ChangeoverUpdateManyWithWhereWithoutFromBlockInput[]
    deleteMany?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
  }

  export type ScheduleBlockCreateNestedOneWithoutToChangeoversInput = {
    create?: XOR<ScheduleBlockCreateWithoutToChangeoversInput, ScheduleBlockUncheckedCreateWithoutToChangeoversInput>
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutToChangeoversInput
    connect?: ScheduleBlockWhereUniqueInput
  }

  export type ScheduleBlockCreateNestedOneWithoutFromChangeoversInput = {
    create?: XOR<ScheduleBlockCreateWithoutFromChangeoversInput, ScheduleBlockUncheckedCreateWithoutFromChangeoversInput>
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutFromChangeoversInput
    connect?: ScheduleBlockWhereUniqueInput
  }

  export type WorkcenterCreateNestedOneWithoutChangeoversInput = {
    create?: XOR<WorkcenterCreateWithoutChangeoversInput, WorkcenterUncheckedCreateWithoutChangeoversInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutChangeoversInput
    connect?: WorkcenterWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ScheduleBlockUpdateOneRequiredWithoutToChangeoversNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutToChangeoversInput, ScheduleBlockUncheckedCreateWithoutToChangeoversInput>
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutToChangeoversInput
    upsert?: ScheduleBlockUpsertWithoutToChangeoversInput
    connect?: ScheduleBlockWhereUniqueInput
    update?: XOR<XOR<ScheduleBlockUpdateToOneWithWhereWithoutToChangeoversInput, ScheduleBlockUpdateWithoutToChangeoversInput>, ScheduleBlockUncheckedUpdateWithoutToChangeoversInput>
  }

  export type ScheduleBlockUpdateOneRequiredWithoutFromChangeoversNestedInput = {
    create?: XOR<ScheduleBlockCreateWithoutFromChangeoversInput, ScheduleBlockUncheckedCreateWithoutFromChangeoversInput>
    connectOrCreate?: ScheduleBlockCreateOrConnectWithoutFromChangeoversInput
    upsert?: ScheduleBlockUpsertWithoutFromChangeoversInput
    connect?: ScheduleBlockWhereUniqueInput
    update?: XOR<XOR<ScheduleBlockUpdateToOneWithWhereWithoutFromChangeoversInput, ScheduleBlockUpdateWithoutFromChangeoversInput>, ScheduleBlockUncheckedUpdateWithoutFromChangeoversInput>
  }

  export type WorkcenterUpdateOneRequiredWithoutChangeoversNestedInput = {
    create?: XOR<WorkcenterCreateWithoutChangeoversInput, WorkcenterUncheckedCreateWithoutChangeoversInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutChangeoversInput
    upsert?: WorkcenterUpsertWithoutChangeoversInput
    connect?: WorkcenterWhereUniqueInput
    update?: XOR<XOR<WorkcenterUpdateToOneWithWhereWithoutChangeoversInput, WorkcenterUpdateWithoutChangeoversInput>, WorkcenterUncheckedUpdateWithoutChangeoversInput>
  }

  export type DepartmentCreateNestedOneWithoutOperatorsInput = {
    create?: XOR<DepartmentCreateWithoutOperatorsInput, DepartmentUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutOperatorsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type OperatorCompetencyCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput> | OperatorCompetencyCreateWithoutOperatorInput[] | OperatorCompetencyUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutOperatorInput | OperatorCompetencyCreateOrConnectWithoutOperatorInput[]
    createMany?: OperatorCompetencyCreateManyOperatorInputEnvelope
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
  }

  export type ShiftAssignmentCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput> | ShiftAssignmentCreateWithoutOperatorInput[] | ShiftAssignmentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutOperatorInput | ShiftAssignmentCreateOrConnectWithoutOperatorInput[]
    createMany?: ShiftAssignmentCreateManyOperatorInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type OperatorCompetencyUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput> | OperatorCompetencyCreateWithoutOperatorInput[] | OperatorCompetencyUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutOperatorInput | OperatorCompetencyCreateOrConnectWithoutOperatorInput[]
    createMany?: OperatorCompetencyCreateManyOperatorInputEnvelope
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput> | ShiftAssignmentCreateWithoutOperatorInput[] | ShiftAssignmentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutOperatorInput | ShiftAssignmentCreateOrConnectWithoutOperatorInput[]
    createMany?: ShiftAssignmentCreateManyOperatorInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUpdateOneWithoutOperatorsNestedInput = {
    create?: XOR<DepartmentCreateWithoutOperatorsInput, DepartmentUncheckedCreateWithoutOperatorsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutOperatorsInput
    upsert?: DepartmentUpsertWithoutOperatorsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutOperatorsInput, DepartmentUpdateWithoutOperatorsInput>, DepartmentUncheckedUpdateWithoutOperatorsInput>
  }

  export type OperatorCompetencyUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput> | OperatorCompetencyCreateWithoutOperatorInput[] | OperatorCompetencyUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutOperatorInput | OperatorCompetencyCreateOrConnectWithoutOperatorInput[]
    upsert?: OperatorCompetencyUpsertWithWhereUniqueWithoutOperatorInput | OperatorCompetencyUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OperatorCompetencyCreateManyOperatorInputEnvelope
    set?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    disconnect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    delete?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    update?: OperatorCompetencyUpdateWithWhereUniqueWithoutOperatorInput | OperatorCompetencyUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OperatorCompetencyUpdateManyWithWhereWithoutOperatorInput | OperatorCompetencyUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput> | ShiftAssignmentCreateWithoutOperatorInput[] | ShiftAssignmentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutOperatorInput | ShiftAssignmentCreateOrConnectWithoutOperatorInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutOperatorInput | ShiftAssignmentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ShiftAssignmentCreateManyOperatorInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutOperatorInput | ShiftAssignmentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutOperatorInput | ShiftAssignmentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type OperatorCompetencyUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput> | OperatorCompetencyCreateWithoutOperatorInput[] | OperatorCompetencyUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutOperatorInput | OperatorCompetencyCreateOrConnectWithoutOperatorInput[]
    upsert?: OperatorCompetencyUpsertWithWhereUniqueWithoutOperatorInput | OperatorCompetencyUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OperatorCompetencyCreateManyOperatorInputEnvelope
    set?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    disconnect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    delete?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    update?: OperatorCompetencyUpdateWithWhereUniqueWithoutOperatorInput | OperatorCompetencyUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OperatorCompetencyUpdateManyWithWhereWithoutOperatorInput | OperatorCompetencyUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput> | ShiftAssignmentCreateWithoutOperatorInput[] | ShiftAssignmentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutOperatorInput | ShiftAssignmentCreateOrConnectWithoutOperatorInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutOperatorInput | ShiftAssignmentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ShiftAssignmentCreateManyOperatorInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutOperatorInput | ShiftAssignmentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutOperatorInput | ShiftAssignmentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type OperatorCompetencyCreateNestedManyWithoutSkillInput = {
    create?: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput> | OperatorCompetencyCreateWithoutSkillInput[] | OperatorCompetencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutSkillInput | OperatorCompetencyCreateOrConnectWithoutSkillInput[]
    createMany?: OperatorCompetencyCreateManySkillInputEnvelope
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
  }

  export type SkillRequirementCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput> | SkillRequirementCreateWithoutSkillInput[] | SkillRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutSkillInput | SkillRequirementCreateOrConnectWithoutSkillInput[]
    createMany?: SkillRequirementCreateManySkillInputEnvelope
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
  }

  export type OperatorCompetencyUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput> | OperatorCompetencyCreateWithoutSkillInput[] | OperatorCompetencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutSkillInput | OperatorCompetencyCreateOrConnectWithoutSkillInput[]
    createMany?: OperatorCompetencyCreateManySkillInputEnvelope
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
  }

  export type SkillRequirementUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput> | SkillRequirementCreateWithoutSkillInput[] | SkillRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutSkillInput | SkillRequirementCreateOrConnectWithoutSkillInput[]
    createMany?: SkillRequirementCreateManySkillInputEnvelope
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
  }

  export type OperatorCompetencyUpdateManyWithoutSkillNestedInput = {
    create?: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput> | OperatorCompetencyCreateWithoutSkillInput[] | OperatorCompetencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutSkillInput | OperatorCompetencyCreateOrConnectWithoutSkillInput[]
    upsert?: OperatorCompetencyUpsertWithWhereUniqueWithoutSkillInput | OperatorCompetencyUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: OperatorCompetencyCreateManySkillInputEnvelope
    set?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    disconnect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    delete?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    update?: OperatorCompetencyUpdateWithWhereUniqueWithoutSkillInput | OperatorCompetencyUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: OperatorCompetencyUpdateManyWithWhereWithoutSkillInput | OperatorCompetencyUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
  }

  export type SkillRequirementUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput> | SkillRequirementCreateWithoutSkillInput[] | SkillRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutSkillInput | SkillRequirementCreateOrConnectWithoutSkillInput[]
    upsert?: SkillRequirementUpsertWithWhereUniqueWithoutSkillInput | SkillRequirementUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillRequirementCreateManySkillInputEnvelope
    set?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    disconnect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    delete?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    update?: SkillRequirementUpdateWithWhereUniqueWithoutSkillInput | SkillRequirementUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillRequirementUpdateManyWithWhereWithoutSkillInput | SkillRequirementUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
  }

  export type OperatorCompetencyUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput> | OperatorCompetencyCreateWithoutSkillInput[] | OperatorCompetencyUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: OperatorCompetencyCreateOrConnectWithoutSkillInput | OperatorCompetencyCreateOrConnectWithoutSkillInput[]
    upsert?: OperatorCompetencyUpsertWithWhereUniqueWithoutSkillInput | OperatorCompetencyUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: OperatorCompetencyCreateManySkillInputEnvelope
    set?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    disconnect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    delete?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    connect?: OperatorCompetencyWhereUniqueInput | OperatorCompetencyWhereUniqueInput[]
    update?: OperatorCompetencyUpdateWithWhereUniqueWithoutSkillInput | OperatorCompetencyUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: OperatorCompetencyUpdateManyWithWhereWithoutSkillInput | OperatorCompetencyUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
  }

  export type SkillRequirementUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput> | SkillRequirementCreateWithoutSkillInput[] | SkillRequirementUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: SkillRequirementCreateOrConnectWithoutSkillInput | SkillRequirementCreateOrConnectWithoutSkillInput[]
    upsert?: SkillRequirementUpsertWithWhereUniqueWithoutSkillInput | SkillRequirementUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: SkillRequirementCreateManySkillInputEnvelope
    set?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    disconnect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    delete?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    connect?: SkillRequirementWhereUniqueInput | SkillRequirementWhereUniqueInput[]
    update?: SkillRequirementUpdateWithWhereUniqueWithoutSkillInput | SkillRequirementUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: SkillRequirementUpdateManyWithWhereWithoutSkillInput | SkillRequirementUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
  }

  export type SkillCreateNestedOneWithoutCompetenciesInput = {
    create?: XOR<SkillCreateWithoutCompetenciesInput, SkillUncheckedCreateWithoutCompetenciesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCompetenciesInput
    connect?: SkillWhereUniqueInput
  }

  export type OperatorCreateNestedOneWithoutCompetenciesInput = {
    create?: XOR<OperatorCreateWithoutCompetenciesInput, OperatorUncheckedCreateWithoutCompetenciesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutCompetenciesInput
    connect?: OperatorWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SkillUpdateOneRequiredWithoutCompetenciesNestedInput = {
    create?: XOR<SkillCreateWithoutCompetenciesInput, SkillUncheckedCreateWithoutCompetenciesInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCompetenciesInput
    upsert?: SkillUpsertWithoutCompetenciesInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCompetenciesInput, SkillUpdateWithoutCompetenciesInput>, SkillUncheckedUpdateWithoutCompetenciesInput>
  }

  export type OperatorUpdateOneRequiredWithoutCompetenciesNestedInput = {
    create?: XOR<OperatorCreateWithoutCompetenciesInput, OperatorUncheckedCreateWithoutCompetenciesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutCompetenciesInput
    upsert?: OperatorUpsertWithoutCompetenciesInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutCompetenciesInput, OperatorUpdateWithoutCompetenciesInput>, OperatorUncheckedUpdateWithoutCompetenciesInput>
  }

  export type SkillCreateNestedOneWithoutSkillRequirementsInput = {
    create?: XOR<SkillCreateWithoutSkillRequirementsInput, SkillUncheckedCreateWithoutSkillRequirementsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutSkillRequirementsInput
    connect?: SkillWhereUniqueInput
  }

  export type WorkcenterCreateNestedOneWithoutSkillRequirementsInput = {
    create?: XOR<WorkcenterCreateWithoutSkillRequirementsInput, WorkcenterUncheckedCreateWithoutSkillRequirementsInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutSkillRequirementsInput
    connect?: WorkcenterWhereUniqueInput
  }

  export type SkillUpdateOneRequiredWithoutSkillRequirementsNestedInput = {
    create?: XOR<SkillCreateWithoutSkillRequirementsInput, SkillUncheckedCreateWithoutSkillRequirementsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutSkillRequirementsInput
    upsert?: SkillUpsertWithoutSkillRequirementsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutSkillRequirementsInput, SkillUpdateWithoutSkillRequirementsInput>, SkillUncheckedUpdateWithoutSkillRequirementsInput>
  }

  export type WorkcenterUpdateOneRequiredWithoutSkillRequirementsNestedInput = {
    create?: XOR<WorkcenterCreateWithoutSkillRequirementsInput, WorkcenterUncheckedCreateWithoutSkillRequirementsInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutSkillRequirementsInput
    upsert?: WorkcenterUpsertWithoutSkillRequirementsInput
    connect?: WorkcenterWhereUniqueInput
    update?: XOR<XOR<WorkcenterUpdateToOneWithWhereWithoutSkillRequirementsInput, WorkcenterUpdateWithoutSkillRequirementsInput>, WorkcenterUncheckedUpdateWithoutSkillRequirementsInput>
  }

  export type ShiftAssignmentCreateNestedManyWithoutShiftPatternInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput> | ShiftAssignmentCreateWithoutShiftPatternInput[] | ShiftAssignmentUncheckedCreateWithoutShiftPatternInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftPatternInput | ShiftAssignmentCreateOrConnectWithoutShiftPatternInput[]
    createMany?: ShiftAssignmentCreateManyShiftPatternInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutShiftPatternInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput> | ShiftAssignmentCreateWithoutShiftPatternInput[] | ShiftAssignmentUncheckedCreateWithoutShiftPatternInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftPatternInput | ShiftAssignmentCreateOrConnectWithoutShiftPatternInput[]
    createMany?: ShiftAssignmentCreateManyShiftPatternInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutShiftPatternNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput> | ShiftAssignmentCreateWithoutShiftPatternInput[] | ShiftAssignmentUncheckedCreateWithoutShiftPatternInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftPatternInput | ShiftAssignmentCreateOrConnectWithoutShiftPatternInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutShiftPatternInput | ShiftAssignmentUpsertWithWhereUniqueWithoutShiftPatternInput[]
    createMany?: ShiftAssignmentCreateManyShiftPatternInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutShiftPatternInput | ShiftAssignmentUpdateWithWhereUniqueWithoutShiftPatternInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutShiftPatternInput | ShiftAssignmentUpdateManyWithWhereWithoutShiftPatternInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutShiftPatternNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput> | ShiftAssignmentCreateWithoutShiftPatternInput[] | ShiftAssignmentUncheckedCreateWithoutShiftPatternInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftPatternInput | ShiftAssignmentCreateOrConnectWithoutShiftPatternInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutShiftPatternInput | ShiftAssignmentUpsertWithWhereUniqueWithoutShiftPatternInput[]
    createMany?: ShiftAssignmentCreateManyShiftPatternInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutShiftPatternInput | ShiftAssignmentUpdateWithWhereUniqueWithoutShiftPatternInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutShiftPatternInput | ShiftAssignmentUpdateManyWithWhereWithoutShiftPatternInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type ShiftPatternCreateNestedOneWithoutShiftAssignmentsInput = {
    create?: XOR<ShiftPatternCreateWithoutShiftAssignmentsInput, ShiftPatternUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: ShiftPatternCreateOrConnectWithoutShiftAssignmentsInput
    connect?: ShiftPatternWhereUniqueInput
  }

  export type WorkcenterCreateNestedOneWithoutShiftAssignmentsInput = {
    create?: XOR<WorkcenterCreateWithoutShiftAssignmentsInput, WorkcenterUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutShiftAssignmentsInput
    connect?: WorkcenterWhereUniqueInput
  }

  export type OperatorCreateNestedOneWithoutShiftAssignmentsInput = {
    create?: XOR<OperatorCreateWithoutShiftAssignmentsInput, OperatorUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutShiftAssignmentsInput
    connect?: OperatorWhereUniqueInput
  }

  export type ShiftPatternUpdateOneRequiredWithoutShiftAssignmentsNestedInput = {
    create?: XOR<ShiftPatternCreateWithoutShiftAssignmentsInput, ShiftPatternUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: ShiftPatternCreateOrConnectWithoutShiftAssignmentsInput
    upsert?: ShiftPatternUpsertWithoutShiftAssignmentsInput
    connect?: ShiftPatternWhereUniqueInput
    update?: XOR<XOR<ShiftPatternUpdateToOneWithWhereWithoutShiftAssignmentsInput, ShiftPatternUpdateWithoutShiftAssignmentsInput>, ShiftPatternUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type WorkcenterUpdateOneRequiredWithoutShiftAssignmentsNestedInput = {
    create?: XOR<WorkcenterCreateWithoutShiftAssignmentsInput, WorkcenterUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: WorkcenterCreateOrConnectWithoutShiftAssignmentsInput
    upsert?: WorkcenterUpsertWithoutShiftAssignmentsInput
    connect?: WorkcenterWhereUniqueInput
    update?: XOR<XOR<WorkcenterUpdateToOneWithWhereWithoutShiftAssignmentsInput, WorkcenterUpdateWithoutShiftAssignmentsInput>, WorkcenterUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type OperatorUpdateOneRequiredWithoutShiftAssignmentsNestedInput = {
    create?: XOR<OperatorCreateWithoutShiftAssignmentsInput, OperatorUncheckedCreateWithoutShiftAssignmentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutShiftAssignmentsInput
    upsert?: OperatorUpsertWithoutShiftAssignmentsInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutShiftAssignmentsInput, OperatorUpdateWithoutShiftAssignmentsInput>, OperatorUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutPlantInput = {
    name: string
    operators?: OperatorCreateNestedManyWithoutDepartmentInput
    workcenters?: WorkcenterCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPlantInput = {
    id?: number
    name: string
    operators?: OperatorUncheckedCreateNestedManyWithoutDepartmentInput
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPlantInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput>
  }

  export type DepartmentCreateManyPlantInputEnvelope = {
    data: DepartmentCreateManyPlantInput | DepartmentCreateManyPlantInput[]
  }

  export type HolidayCreateWithoutPlantInput = {
    date: Date | string
    label?: string | null
  }

  export type HolidayUncheckedCreateWithoutPlantInput = {
    id?: number
    date: Date | string
    label?: string | null
  }

  export type HolidayCreateOrConnectWithoutPlantInput = {
    where: HolidayWhereUniqueInput
    create: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput>
  }

  export type HolidayCreateManyPlantInputEnvelope = {
    data: HolidayCreateManyPlantInput | HolidayCreateManyPlantInput[]
  }

  export type WorkcenterCreateWithoutPlantInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutPlantInput = {
    id?: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutPlantInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput>
  }

  export type WorkcenterCreateManyPlantInputEnvelope = {
    data: WorkcenterCreateManyPlantInput | WorkcenterCreateManyPlantInput[]
  }

  export type DepartmentUpsertWithWhereUniqueWithoutPlantInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutPlantInput, DepartmentUncheckedUpdateWithoutPlantInput>
    create: XOR<DepartmentCreateWithoutPlantInput, DepartmentUncheckedCreateWithoutPlantInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutPlantInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutPlantInput, DepartmentUncheckedUpdateWithoutPlantInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutPlantInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutPlantInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: IntFilter<"Department"> | number
    plantId?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
  }

  export type HolidayUpsertWithWhereUniqueWithoutPlantInput = {
    where: HolidayWhereUniqueInput
    update: XOR<HolidayUpdateWithoutPlantInput, HolidayUncheckedUpdateWithoutPlantInput>
    create: XOR<HolidayCreateWithoutPlantInput, HolidayUncheckedCreateWithoutPlantInput>
  }

  export type HolidayUpdateWithWhereUniqueWithoutPlantInput = {
    where: HolidayWhereUniqueInput
    data: XOR<HolidayUpdateWithoutPlantInput, HolidayUncheckedUpdateWithoutPlantInput>
  }

  export type HolidayUpdateManyWithWhereWithoutPlantInput = {
    where: HolidayScalarWhereInput
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyWithoutPlantInput>
  }

  export type HolidayScalarWhereInput = {
    AND?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    OR?: HolidayScalarWhereInput[]
    NOT?: HolidayScalarWhereInput | HolidayScalarWhereInput[]
    id?: IntFilter<"Holiday"> | number
    plantId?: IntFilter<"Holiday"> | number
    date?: DateTimeFilter<"Holiday"> | Date | string
    label?: StringNullableFilter<"Holiday"> | string | null
  }

  export type WorkcenterUpsertWithWhereUniqueWithoutPlantInput = {
    where: WorkcenterWhereUniqueInput
    update: XOR<WorkcenterUpdateWithoutPlantInput, WorkcenterUncheckedUpdateWithoutPlantInput>
    create: XOR<WorkcenterCreateWithoutPlantInput, WorkcenterUncheckedCreateWithoutPlantInput>
  }

  export type WorkcenterUpdateWithWhereUniqueWithoutPlantInput = {
    where: WorkcenterWhereUniqueInput
    data: XOR<WorkcenterUpdateWithoutPlantInput, WorkcenterUncheckedUpdateWithoutPlantInput>
  }

  export type WorkcenterUpdateManyWithWhereWithoutPlantInput = {
    where: WorkcenterScalarWhereInput
    data: XOR<WorkcenterUpdateManyMutationInput, WorkcenterUncheckedUpdateManyWithoutPlantInput>
  }

  export type WorkcenterScalarWhereInput = {
    AND?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
    OR?: WorkcenterScalarWhereInput[]
    NOT?: WorkcenterScalarWhereInput | WorkcenterScalarWhereInput[]
    id?: IntFilter<"Workcenter"> | number
    plantId?: IntFilter<"Workcenter"> | number
    departmentId?: IntFilter<"Workcenter"> | number
    workcenterNo?: StringFilter<"Workcenter"> | string
    name?: StringFilter<"Workcenter"> | string
    displayTitle?: StringNullableFilter<"Workcenter"> | string | null
    defaultSchemeId?: IntNullableFilter<"Workcenter"> | number | null
    minStaff?: IntFilter<"Workcenter"> | number
    gatingRules?: StringNullableFilter<"Workcenter"> | string | null
    changeoverFamily?: StringNullableFilter<"Workcenter"> | string | null
  }

  export type PlantCreateWithoutDepartmentsInput = {
    name: string
    holidays?: HolidayCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterCreateNestedManyWithoutPlantInput
  }

  export type PlantUncheckedCreateWithoutDepartmentsInput = {
    id?: number
    name: string
    holidays?: HolidayUncheckedCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCreateOrConnectWithoutDepartmentsInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutDepartmentsInput, PlantUncheckedCreateWithoutDepartmentsInput>
  }

  export type OperatorCreateWithoutDepartmentInput = {
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    competencies?: OperatorCompetencyCreateNestedManyWithoutOperatorInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutDepartmentInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    competencies?: OperatorCompetencyUncheckedCreateNestedManyWithoutOperatorInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutDepartmentInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput>
  }

  export type OperatorCreateManyDepartmentInputEnvelope = {
    data: OperatorCreateManyDepartmentInput | OperatorCreateManyDepartmentInput[]
  }

  export type WorkcenterCreateWithoutDepartmentInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutDepartmentInput = {
    id?: number
    plantId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutDepartmentInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput>
  }

  export type WorkcenterCreateManyDepartmentInputEnvelope = {
    data: WorkcenterCreateManyDepartmentInput | WorkcenterCreateManyDepartmentInput[]
  }

  export type PlantUpsertWithoutDepartmentsInput = {
    update: XOR<PlantUpdateWithoutDepartmentsInput, PlantUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<PlantCreateWithoutDepartmentsInput, PlantUncheckedCreateWithoutDepartmentsInput>
    where?: PlantWhereInput
  }

  export type PlantUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: PlantWhereInput
    data: XOR<PlantUpdateWithoutDepartmentsInput, PlantUncheckedUpdateWithoutDepartmentsInput>
  }

  export type PlantUpdateWithoutDepartmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    holidays?: HolidayUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUpdateManyWithoutPlantNestedInput
  }

  export type PlantUncheckedUpdateWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    holidays?: HolidayUncheckedUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type OperatorUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: OperatorWhereUniqueInput
    update: XOR<OperatorUpdateWithoutDepartmentInput, OperatorUncheckedUpdateWithoutDepartmentInput>
    create: XOR<OperatorCreateWithoutDepartmentInput, OperatorUncheckedCreateWithoutDepartmentInput>
  }

  export type OperatorUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: OperatorWhereUniqueInput
    data: XOR<OperatorUpdateWithoutDepartmentInput, OperatorUncheckedUpdateWithoutDepartmentInput>
  }

  export type OperatorUpdateManyWithWhereWithoutDepartmentInput = {
    where: OperatorScalarWhereInput
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type OperatorScalarWhereInput = {
    AND?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    OR?: OperatorScalarWhereInput[]
    NOT?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    id?: IntFilter<"Operator"> | number
    employeeId?: StringFilter<"Operator"> | string
    firstName?: StringFilter<"Operator"> | string
    lastName?: StringFilter<"Operator"> | string
    email?: StringNullableFilter<"Operator"> | string | null
    phone?: StringNullableFilter<"Operator"> | string | null
    hireDate?: DateTimeFilter<"Operator"> | Date | string
    departmentId?: IntNullableFilter<"Operator"> | number | null
    isActive?: BoolFilter<"Operator"> | boolean
    basePayRate?: FloatNullableFilter<"Operator"> | number | null
    emergencyContact?: StringNullableFilter<"Operator"> | string | null
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeFilter<"Operator"> | Date | string
  }

  export type WorkcenterUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: WorkcenterWhereUniqueInput
    update: XOR<WorkcenterUpdateWithoutDepartmentInput, WorkcenterUncheckedUpdateWithoutDepartmentInput>
    create: XOR<WorkcenterCreateWithoutDepartmentInput, WorkcenterUncheckedCreateWithoutDepartmentInput>
  }

  export type WorkcenterUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: WorkcenterWhereUniqueInput
    data: XOR<WorkcenterUpdateWithoutDepartmentInput, WorkcenterUncheckedUpdateWithoutDepartmentInput>
  }

  export type WorkcenterUpdateManyWithWhereWithoutDepartmentInput = {
    where: WorkcenterScalarWhereInput
    data: XOR<WorkcenterUpdateManyMutationInput, WorkcenterUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type ChangeoverCreateWithoutWorkcenterInput = {
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
    toBlock: ScheduleBlockCreateNestedOneWithoutToChangeoversInput
    fromBlock: ScheduleBlockCreateNestedOneWithoutFromChangeoversInput
  }

  export type ChangeoverUncheckedCreateWithoutWorkcenterInput = {
    id?: number
    fromBlockId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverCreateOrConnectWithoutWorkcenterInput = {
    where: ChangeoverWhereUniqueInput
    create: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput>
  }

  export type ChangeoverCreateManyWorkcenterInputEnvelope = {
    data: ChangeoverCreateManyWorkcenterInput | ChangeoverCreateManyWorkcenterInput[]
  }

  export type OrderCreateWithoutPlannedWorkcenterInput = {
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
    sku: SKUCreateNestedOneWithoutOrdersInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPlannedWorkcenterInput = {
    id?: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPlannedWorkcenterInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput>
  }

  export type OrderCreateManyPlannedWorkcenterInputEnvelope = {
    data: OrderCreateManyPlannedWorkcenterInput | OrderCreateManyPlannedWorkcenterInput[]
  }

  export type ScheduleBlockCreateWithoutWorkcenterInput = {
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverCreateNestedManyWithoutFromBlockInput
    order?: OrderCreateNestedOneWithoutScheduleBlocksInput
  }

  export type ScheduleBlockUncheckedCreateWithoutWorkcenterInput = {
    id?: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutFromBlockInput
  }

  export type ScheduleBlockCreateOrConnectWithoutWorkcenterInput = {
    where: ScheduleBlockWhereUniqueInput
    create: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput>
  }

  export type ScheduleBlockCreateManyWorkcenterInputEnvelope = {
    data: ScheduleBlockCreateManyWorkcenterInput | ScheduleBlockCreateManyWorkcenterInput[]
  }

  export type ShiftAssignmentCreateWithoutWorkcenterInput = {
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shiftPattern: ShiftPatternCreateNestedOneWithoutShiftAssignmentsInput
    operator: OperatorCreateNestedOneWithoutShiftAssignmentsInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutWorkcenterInput = {
    id?: number
    operatorId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutWorkcenterInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput>
  }

  export type ShiftAssignmentCreateManyWorkcenterInputEnvelope = {
    data: ShiftAssignmentCreateManyWorkcenterInput | ShiftAssignmentCreateManyWorkcenterInput[]
  }

  export type SkillRequirementCreateWithoutWorkcenterInput = {
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
    skill: SkillCreateNestedOneWithoutSkillRequirementsInput
  }

  export type SkillRequirementUncheckedCreateWithoutWorkcenterInput = {
    id?: number
    skillId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type SkillRequirementCreateOrConnectWithoutWorkcenterInput = {
    where: SkillRequirementWhereUniqueInput
    create: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput>
  }

  export type SkillRequirementCreateManyWorkcenterInputEnvelope = {
    data: SkillRequirementCreateManyWorkcenterInput | SkillRequirementCreateManyWorkcenterInput[]
  }

  export type DepartmentCreateWithoutWorkcentersInput = {
    name: string
    plant: PlantCreateNestedOneWithoutDepartmentsInput
    operators?: OperatorCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutWorkcentersInput = {
    id?: number
    plantId: number
    name: string
    operators?: OperatorUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutWorkcentersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutWorkcentersInput, DepartmentUncheckedCreateWithoutWorkcentersInput>
  }

  export type PlantCreateWithoutWorkcentersInput = {
    name: string
    departments?: DepartmentCreateNestedManyWithoutPlantInput
    holidays?: HolidayCreateNestedManyWithoutPlantInput
  }

  export type PlantUncheckedCreateWithoutWorkcentersInput = {
    id?: number
    name: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutPlantInput
    holidays?: HolidayUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCreateOrConnectWithoutWorkcentersInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutWorkcentersInput, PlantUncheckedCreateWithoutWorkcentersInput>
  }

  export type ChangeoverUpsertWithWhereUniqueWithoutWorkcenterInput = {
    where: ChangeoverWhereUniqueInput
    update: XOR<ChangeoverUpdateWithoutWorkcenterInput, ChangeoverUncheckedUpdateWithoutWorkcenterInput>
    create: XOR<ChangeoverCreateWithoutWorkcenterInput, ChangeoverUncheckedCreateWithoutWorkcenterInput>
  }

  export type ChangeoverUpdateWithWhereUniqueWithoutWorkcenterInput = {
    where: ChangeoverWhereUniqueInput
    data: XOR<ChangeoverUpdateWithoutWorkcenterInput, ChangeoverUncheckedUpdateWithoutWorkcenterInput>
  }

  export type ChangeoverUpdateManyWithWhereWithoutWorkcenterInput = {
    where: ChangeoverScalarWhereInput
    data: XOR<ChangeoverUpdateManyMutationInput, ChangeoverUncheckedUpdateManyWithoutWorkcenterInput>
  }

  export type ChangeoverScalarWhereInput = {
    AND?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
    OR?: ChangeoverScalarWhereInput[]
    NOT?: ChangeoverScalarWhereInput | ChangeoverScalarWhereInput[]
    id?: IntFilter<"Changeover"> | number
    workcenterId?: IntFilter<"Changeover"> | number
    fromBlockId?: IntFilter<"Changeover"> | number
    toBlockId?: IntFilter<"Changeover"> | number
    typeCode?: StringFilter<"Changeover"> | string
    plannedMinutes?: IntFilter<"Changeover"> | number
    includeInOee?: BoolFilter<"Changeover"> | boolean
    complexityTier?: StringNullableFilter<"Changeover"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutPlannedWorkcenterInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPlannedWorkcenterInput, OrderUncheckedUpdateWithoutPlannedWorkcenterInput>
    create: XOR<OrderCreateWithoutPlannedWorkcenterInput, OrderUncheckedCreateWithoutPlannedWorkcenterInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPlannedWorkcenterInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPlannedWorkcenterInput, OrderUncheckedUpdateWithoutPlannedWorkcenterInput>
  }

  export type OrderUpdateManyWithWhereWithoutPlannedWorkcenterInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPlannedWorkcenterInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNo?: StringFilter<"Order"> | string
    skuId?: IntFilter<"Order"> | number
    qty?: IntFilter<"Order"> | number
    runRateUph?: IntFilter<"Order"> | number
    performanceLeverPct?: FloatFilter<"Order"> | number
    priority?: IntFilter<"Order"> | number
    dueAt?: DateTimeFilter<"Order"> | Date | string
    workcenterId?: IntNullableFilter<"Order"> | number | null
    shopfloorTitle?: StringNullableFilter<"Order"> | string | null
    colorHex?: StringNullableFilter<"Order"> | string | null
  }

  export type ScheduleBlockUpsertWithWhereUniqueWithoutWorkcenterInput = {
    where: ScheduleBlockWhereUniqueInput
    update: XOR<ScheduleBlockUpdateWithoutWorkcenterInput, ScheduleBlockUncheckedUpdateWithoutWorkcenterInput>
    create: XOR<ScheduleBlockCreateWithoutWorkcenterInput, ScheduleBlockUncheckedCreateWithoutWorkcenterInput>
  }

  export type ScheduleBlockUpdateWithWhereUniqueWithoutWorkcenterInput = {
    where: ScheduleBlockWhereUniqueInput
    data: XOR<ScheduleBlockUpdateWithoutWorkcenterInput, ScheduleBlockUncheckedUpdateWithoutWorkcenterInput>
  }

  export type ScheduleBlockUpdateManyWithWhereWithoutWorkcenterInput = {
    where: ScheduleBlockScalarWhereInput
    data: XOR<ScheduleBlockUpdateManyMutationInput, ScheduleBlockUncheckedUpdateManyWithoutWorkcenterInput>
  }

  export type ScheduleBlockScalarWhereInput = {
    AND?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
    OR?: ScheduleBlockScalarWhereInput[]
    NOT?: ScheduleBlockScalarWhereInput | ScheduleBlockScalarWhereInput[]
    id?: IntFilter<"ScheduleBlock"> | number
    workcenterId?: IntFilter<"ScheduleBlock"> | number
    orderId?: IntNullableFilter<"ScheduleBlock"> | number | null
    startAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
    endAt?: DateTimeFilter<"ScheduleBlock"> | Date | string
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutWorkcenterInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutWorkcenterInput, ShiftAssignmentUncheckedUpdateWithoutWorkcenterInput>
    create: XOR<ShiftAssignmentCreateWithoutWorkcenterInput, ShiftAssignmentUncheckedCreateWithoutWorkcenterInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutWorkcenterInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutWorkcenterInput, ShiftAssignmentUncheckedUpdateWithoutWorkcenterInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutWorkcenterInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterInput>
  }

  export type ShiftAssignmentScalarWhereInput = {
    AND?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
    OR?: ShiftAssignmentScalarWhereInput[]
    NOT?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
    id?: IntFilter<"ShiftAssignment"> | number
    operatorId?: IntFilter<"ShiftAssignment"> | number
    workcenterId?: IntFilter<"ShiftAssignment"> | number
    shiftPatternId?: IntFilter<"ShiftAssignment"> | number
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    role?: StringFilter<"ShiftAssignment"> | string
    payRate?: FloatNullableFilter<"ShiftAssignment"> | number | null
    notes?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
  }

  export type SkillRequirementUpsertWithWhereUniqueWithoutWorkcenterInput = {
    where: SkillRequirementWhereUniqueInput
    update: XOR<SkillRequirementUpdateWithoutWorkcenterInput, SkillRequirementUncheckedUpdateWithoutWorkcenterInput>
    create: XOR<SkillRequirementCreateWithoutWorkcenterInput, SkillRequirementUncheckedCreateWithoutWorkcenterInput>
  }

  export type SkillRequirementUpdateWithWhereUniqueWithoutWorkcenterInput = {
    where: SkillRequirementWhereUniqueInput
    data: XOR<SkillRequirementUpdateWithoutWorkcenterInput, SkillRequirementUncheckedUpdateWithoutWorkcenterInput>
  }

  export type SkillRequirementUpdateManyWithWhereWithoutWorkcenterInput = {
    where: SkillRequirementScalarWhereInput
    data: XOR<SkillRequirementUpdateManyMutationInput, SkillRequirementUncheckedUpdateManyWithoutWorkcenterInput>
  }

  export type SkillRequirementScalarWhereInput = {
    AND?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
    OR?: SkillRequirementScalarWhereInput[]
    NOT?: SkillRequirementScalarWhereInput | SkillRequirementScalarWhereInput[]
    id?: IntFilter<"SkillRequirement"> | number
    workcenterId?: IntFilter<"SkillRequirement"> | number
    skillId?: IntFilter<"SkillRequirement"> | number
    minLevel?: IntFilter<"SkillRequirement"> | number
    isRequired?: BoolFilter<"SkillRequirement"> | boolean
    shiftType?: StringNullableFilter<"SkillRequirement"> | string | null
    createdAt?: DateTimeFilter<"SkillRequirement"> | Date | string
  }

  export type DepartmentUpsertWithoutWorkcentersInput = {
    update: XOR<DepartmentUpdateWithoutWorkcentersInput, DepartmentUncheckedUpdateWithoutWorkcentersInput>
    create: XOR<DepartmentCreateWithoutWorkcentersInput, DepartmentUncheckedCreateWithoutWorkcentersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutWorkcentersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutWorkcentersInput, DepartmentUncheckedUpdateWithoutWorkcentersInput>
  }

  export type DepartmentUpdateWithoutWorkcentersInput = {
    name?: StringFieldUpdateOperationsInput | string
    plant?: PlantUpdateOneRequiredWithoutDepartmentsNestedInput
    operators?: OperatorUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutWorkcentersInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    operators?: OperatorUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type PlantUpsertWithoutWorkcentersInput = {
    update: XOR<PlantUpdateWithoutWorkcentersInput, PlantUncheckedUpdateWithoutWorkcentersInput>
    create: XOR<PlantCreateWithoutWorkcentersInput, PlantUncheckedCreateWithoutWorkcentersInput>
    where?: PlantWhereInput
  }

  export type PlantUpdateToOneWithWhereWithoutWorkcentersInput = {
    where?: PlantWhereInput
    data: XOR<PlantUpdateWithoutWorkcentersInput, PlantUncheckedUpdateWithoutWorkcentersInput>
  }

  export type PlantUpdateWithoutWorkcentersInput = {
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutPlantNestedInput
    holidays?: HolidayUpdateManyWithoutPlantNestedInput
  }

  export type PlantUncheckedUpdateWithoutWorkcentersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutPlantNestedInput
    holidays?: HolidayUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type PlantCreateWithoutHolidaysInput = {
    name: string
    departments?: DepartmentCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterCreateNestedManyWithoutPlantInput
  }

  export type PlantUncheckedCreateWithoutHolidaysInput = {
    id?: number
    name: string
    departments?: DepartmentUncheckedCreateNestedManyWithoutPlantInput
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutPlantInput
  }

  export type PlantCreateOrConnectWithoutHolidaysInput = {
    where: PlantWhereUniqueInput
    create: XOR<PlantCreateWithoutHolidaysInput, PlantUncheckedCreateWithoutHolidaysInput>
  }

  export type PlantUpsertWithoutHolidaysInput = {
    update: XOR<PlantUpdateWithoutHolidaysInput, PlantUncheckedUpdateWithoutHolidaysInput>
    create: XOR<PlantCreateWithoutHolidaysInput, PlantUncheckedCreateWithoutHolidaysInput>
    where?: PlantWhereInput
  }

  export type PlantUpdateToOneWithWhereWithoutHolidaysInput = {
    where?: PlantWhereInput
    data: XOR<PlantUpdateWithoutHolidaysInput, PlantUncheckedUpdateWithoutHolidaysInput>
  }

  export type PlantUpdateWithoutHolidaysInput = {
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUpdateManyWithoutPlantNestedInput
  }

  export type PlantUncheckedUpdateWithoutHolidaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departments?: DepartmentUncheckedUpdateManyWithoutPlantNestedInput
    workcenters?: WorkcenterUncheckedUpdateManyWithoutPlantNestedInput
  }

  export type OrderCreateWithoutSkuInput = {
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
    plannedWorkcenter?: WorkcenterCreateNestedOneWithoutOrdersInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSkuInput = {
    id?: number
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    workcenterId?: number | null
    shopfloorTitle?: string | null
    colorHex?: string | null
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSkuInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput>
  }

  export type OrderCreateManySkuInputEnvelope = {
    data: OrderCreateManySkuInput | OrderCreateManySkuInput[]
  }

  export type ProductCreateWithoutSkuInput = {
    name: string
  }

  export type ProductUncheckedCreateWithoutSkuInput = {
    id?: number
    name: string
  }

  export type ProductCreateOrConnectWithoutSkuInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput>
  }

  export type ProductCreateManySkuInputEnvelope = {
    data: ProductCreateManySkuInput | ProductCreateManySkuInput[]
  }

  export type OrderUpsertWithWhereUniqueWithoutSkuInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSkuInput, OrderUncheckedUpdateWithoutSkuInput>
    create: XOR<OrderCreateWithoutSkuInput, OrderUncheckedCreateWithoutSkuInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSkuInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSkuInput, OrderUncheckedUpdateWithoutSkuInput>
  }

  export type OrderUpdateManyWithWhereWithoutSkuInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSkuInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutSkuInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSkuInput, ProductUncheckedUpdateWithoutSkuInput>
    create: XOR<ProductCreateWithoutSkuInput, ProductUncheckedCreateWithoutSkuInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSkuInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSkuInput, ProductUncheckedUpdateWithoutSkuInput>
  }

  export type ProductUpdateManyWithWhereWithoutSkuInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSkuInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    skuId?: IntFilter<"Product"> | number
  }

  export type SKUCreateWithoutProductsInput = {
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    orders?: OrderCreateNestedManyWithoutSkuInput
  }

  export type SKUUncheckedCreateWithoutProductsInput = {
    id?: number
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SKUCreateOrConnectWithoutProductsInput = {
    where: SKUWhereUniqueInput
    create: XOR<SKUCreateWithoutProductsInput, SKUUncheckedCreateWithoutProductsInput>
  }

  export type SKUUpsertWithoutProductsInput = {
    update: XOR<SKUUpdateWithoutProductsInput, SKUUncheckedUpdateWithoutProductsInput>
    create: XOR<SKUCreateWithoutProductsInput, SKUUncheckedCreateWithoutProductsInput>
    where?: SKUWhereInput
  }

  export type SKUUpdateToOneWithWhereWithoutProductsInput = {
    where?: SKUWhereInput
    data: XOR<SKUUpdateWithoutProductsInput, SKUUncheckedUpdateWithoutProductsInput>
  }

  export type SKUUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutSkuNestedInput
  }

  export type SKUUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type WorkcenterCreateWithoutOrdersInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutOrdersInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutOrdersInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutOrdersInput, WorkcenterUncheckedCreateWithoutOrdersInput>
  }

  export type SKUCreateWithoutOrdersInput = {
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    products?: ProductCreateNestedManyWithoutSkuInput
  }

  export type SKUUncheckedCreateWithoutOrdersInput = {
    id?: number
    code: string
    family: string
    familyColorHex?: string | null
    formula?: string | null
    bottleSize?: string | null
    caseSize?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SKUCreateOrConnectWithoutOrdersInput = {
    where: SKUWhereUniqueInput
    create: XOR<SKUCreateWithoutOrdersInput, SKUUncheckedCreateWithoutOrdersInput>
  }

  export type ScheduleBlockCreateWithoutOrderInput = {
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverCreateNestedManyWithoutFromBlockInput
    workcenter: WorkcenterCreateNestedOneWithoutScheduleBlocksInput
  }

  export type ScheduleBlockUncheckedCreateWithoutOrderInput = {
    id?: number
    workcenterId: number
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutToBlockInput
    fromChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutFromBlockInput
  }

  export type ScheduleBlockCreateOrConnectWithoutOrderInput = {
    where: ScheduleBlockWhereUniqueInput
    create: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput>
  }

  export type ScheduleBlockCreateManyOrderInputEnvelope = {
    data: ScheduleBlockCreateManyOrderInput | ScheduleBlockCreateManyOrderInput[]
  }

  export type WorkcenterUpsertWithoutOrdersInput = {
    update: XOR<WorkcenterUpdateWithoutOrdersInput, WorkcenterUncheckedUpdateWithoutOrdersInput>
    create: XOR<WorkcenterCreateWithoutOrdersInput, WorkcenterUncheckedCreateWithoutOrdersInput>
    where?: WorkcenterWhereInput
  }

  export type WorkcenterUpdateToOneWithWhereWithoutOrdersInput = {
    where?: WorkcenterWhereInput
    data: XOR<WorkcenterUpdateWithoutOrdersInput, WorkcenterUncheckedUpdateWithoutOrdersInput>
  }

  export type WorkcenterUpdateWithoutOrdersInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type SKUUpsertWithoutOrdersInput = {
    update: XOR<SKUUpdateWithoutOrdersInput, SKUUncheckedUpdateWithoutOrdersInput>
    create: XOR<SKUCreateWithoutOrdersInput, SKUUncheckedCreateWithoutOrdersInput>
    where?: SKUWhereInput
  }

  export type SKUUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SKUWhereInput
    data: XOR<SKUUpdateWithoutOrdersInput, SKUUncheckedUpdateWithoutOrdersInput>
  }

  export type SKUUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutSkuNestedInput
  }

  export type SKUUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    family?: StringFieldUpdateOperationsInput | string
    familyColorHex?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    bottleSize?: NullableStringFieldUpdateOperationsInput | string | null
    caseSize?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type ScheduleBlockUpsertWithWhereUniqueWithoutOrderInput = {
    where: ScheduleBlockWhereUniqueInput
    update: XOR<ScheduleBlockUpdateWithoutOrderInput, ScheduleBlockUncheckedUpdateWithoutOrderInput>
    create: XOR<ScheduleBlockCreateWithoutOrderInput, ScheduleBlockUncheckedCreateWithoutOrderInput>
  }

  export type ScheduleBlockUpdateWithWhereUniqueWithoutOrderInput = {
    where: ScheduleBlockWhereUniqueInput
    data: XOR<ScheduleBlockUpdateWithoutOrderInput, ScheduleBlockUncheckedUpdateWithoutOrderInput>
  }

  export type ScheduleBlockUpdateManyWithWhereWithoutOrderInput = {
    where: ScheduleBlockScalarWhereInput
    data: XOR<ScheduleBlockUpdateManyMutationInput, ScheduleBlockUncheckedUpdateManyWithoutOrderInput>
  }

  export type ChangeoverCreateWithoutToBlockInput = {
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
    fromBlock: ScheduleBlockCreateNestedOneWithoutFromChangeoversInput
    workcenter: WorkcenterCreateNestedOneWithoutChangeoversInput
  }

  export type ChangeoverUncheckedCreateWithoutToBlockInput = {
    id?: number
    workcenterId: number
    fromBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverCreateOrConnectWithoutToBlockInput = {
    where: ChangeoverWhereUniqueInput
    create: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput>
  }

  export type ChangeoverCreateManyToBlockInputEnvelope = {
    data: ChangeoverCreateManyToBlockInput | ChangeoverCreateManyToBlockInput[]
  }

  export type ChangeoverCreateWithoutFromBlockInput = {
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
    toBlock: ScheduleBlockCreateNestedOneWithoutToChangeoversInput
    workcenter: WorkcenterCreateNestedOneWithoutChangeoversInput
  }

  export type ChangeoverUncheckedCreateWithoutFromBlockInput = {
    id?: number
    workcenterId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverCreateOrConnectWithoutFromBlockInput = {
    where: ChangeoverWhereUniqueInput
    create: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput>
  }

  export type ChangeoverCreateManyFromBlockInputEnvelope = {
    data: ChangeoverCreateManyFromBlockInput | ChangeoverCreateManyFromBlockInput[]
  }

  export type OrderCreateWithoutScheduleBlocksInput = {
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
    plannedWorkcenter?: WorkcenterCreateNestedOneWithoutOrdersInput
    sku: SKUCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutScheduleBlocksInput = {
    id?: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    workcenterId?: number | null
    shopfloorTitle?: string | null
    colorHex?: string | null
  }

  export type OrderCreateOrConnectWithoutScheduleBlocksInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutScheduleBlocksInput, OrderUncheckedCreateWithoutScheduleBlocksInput>
  }

  export type WorkcenterCreateWithoutScheduleBlocksInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutScheduleBlocksInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutScheduleBlocksInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutScheduleBlocksInput, WorkcenterUncheckedCreateWithoutScheduleBlocksInput>
  }

  export type ChangeoverUpsertWithWhereUniqueWithoutToBlockInput = {
    where: ChangeoverWhereUniqueInput
    update: XOR<ChangeoverUpdateWithoutToBlockInput, ChangeoverUncheckedUpdateWithoutToBlockInput>
    create: XOR<ChangeoverCreateWithoutToBlockInput, ChangeoverUncheckedCreateWithoutToBlockInput>
  }

  export type ChangeoverUpdateWithWhereUniqueWithoutToBlockInput = {
    where: ChangeoverWhereUniqueInput
    data: XOR<ChangeoverUpdateWithoutToBlockInput, ChangeoverUncheckedUpdateWithoutToBlockInput>
  }

  export type ChangeoverUpdateManyWithWhereWithoutToBlockInput = {
    where: ChangeoverScalarWhereInput
    data: XOR<ChangeoverUpdateManyMutationInput, ChangeoverUncheckedUpdateManyWithoutToBlockInput>
  }

  export type ChangeoverUpsertWithWhereUniqueWithoutFromBlockInput = {
    where: ChangeoverWhereUniqueInput
    update: XOR<ChangeoverUpdateWithoutFromBlockInput, ChangeoverUncheckedUpdateWithoutFromBlockInput>
    create: XOR<ChangeoverCreateWithoutFromBlockInput, ChangeoverUncheckedCreateWithoutFromBlockInput>
  }

  export type ChangeoverUpdateWithWhereUniqueWithoutFromBlockInput = {
    where: ChangeoverWhereUniqueInput
    data: XOR<ChangeoverUpdateWithoutFromBlockInput, ChangeoverUncheckedUpdateWithoutFromBlockInput>
  }

  export type ChangeoverUpdateManyWithWhereWithoutFromBlockInput = {
    where: ChangeoverScalarWhereInput
    data: XOR<ChangeoverUpdateManyMutationInput, ChangeoverUncheckedUpdateManyWithoutFromBlockInput>
  }

  export type OrderUpsertWithoutScheduleBlocksInput = {
    update: XOR<OrderUpdateWithoutScheduleBlocksInput, OrderUncheckedUpdateWithoutScheduleBlocksInput>
    create: XOR<OrderCreateWithoutScheduleBlocksInput, OrderUncheckedCreateWithoutScheduleBlocksInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutScheduleBlocksInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutScheduleBlocksInput, OrderUncheckedUpdateWithoutScheduleBlocksInput>
  }

  export type OrderUpdateWithoutScheduleBlocksInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWorkcenter?: WorkcenterUpdateOneWithoutOrdersNestedInput
    sku?: SKUUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutScheduleBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenterId?: NullableIntFieldUpdateOperationsInput | number | null
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkcenterUpsertWithoutScheduleBlocksInput = {
    update: XOR<WorkcenterUpdateWithoutScheduleBlocksInput, WorkcenterUncheckedUpdateWithoutScheduleBlocksInput>
    create: XOR<WorkcenterCreateWithoutScheduleBlocksInput, WorkcenterUncheckedCreateWithoutScheduleBlocksInput>
    where?: WorkcenterWhereInput
  }

  export type WorkcenterUpdateToOneWithWhereWithoutScheduleBlocksInput = {
    where?: WorkcenterWhereInput
    data: XOR<WorkcenterUpdateWithoutScheduleBlocksInput, WorkcenterUncheckedUpdateWithoutScheduleBlocksInput>
  }

  export type WorkcenterUpdateWithoutScheduleBlocksInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutScheduleBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type ScheduleBlockCreateWithoutToChangeoversInput = {
    startAt: Date | string
    endAt: Date | string
    fromChangeovers?: ChangeoverCreateNestedManyWithoutFromBlockInput
    order?: OrderCreateNestedOneWithoutScheduleBlocksInput
    workcenter: WorkcenterCreateNestedOneWithoutScheduleBlocksInput
  }

  export type ScheduleBlockUncheckedCreateWithoutToChangeoversInput = {
    id?: number
    workcenterId: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
    fromChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutFromBlockInput
  }

  export type ScheduleBlockCreateOrConnectWithoutToChangeoversInput = {
    where: ScheduleBlockWhereUniqueInput
    create: XOR<ScheduleBlockCreateWithoutToChangeoversInput, ScheduleBlockUncheckedCreateWithoutToChangeoversInput>
  }

  export type ScheduleBlockCreateWithoutFromChangeoversInput = {
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverCreateNestedManyWithoutToBlockInput
    order?: OrderCreateNestedOneWithoutScheduleBlocksInput
    workcenter: WorkcenterCreateNestedOneWithoutScheduleBlocksInput
  }

  export type ScheduleBlockUncheckedCreateWithoutFromChangeoversInput = {
    id?: number
    workcenterId: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
    toChangeovers?: ChangeoverUncheckedCreateNestedManyWithoutToBlockInput
  }

  export type ScheduleBlockCreateOrConnectWithoutFromChangeoversInput = {
    where: ScheduleBlockWhereUniqueInput
    create: XOR<ScheduleBlockCreateWithoutFromChangeoversInput, ScheduleBlockUncheckedCreateWithoutFromChangeoversInput>
  }

  export type WorkcenterCreateWithoutChangeoversInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutChangeoversInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutChangeoversInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutChangeoversInput, WorkcenterUncheckedCreateWithoutChangeoversInput>
  }

  export type ScheduleBlockUpsertWithoutToChangeoversInput = {
    update: XOR<ScheduleBlockUpdateWithoutToChangeoversInput, ScheduleBlockUncheckedUpdateWithoutToChangeoversInput>
    create: XOR<ScheduleBlockCreateWithoutToChangeoversInput, ScheduleBlockUncheckedCreateWithoutToChangeoversInput>
    where?: ScheduleBlockWhereInput
  }

  export type ScheduleBlockUpdateToOneWithWhereWithoutToChangeoversInput = {
    where?: ScheduleBlockWhereInput
    data: XOR<ScheduleBlockUpdateWithoutToChangeoversInput, ScheduleBlockUncheckedUpdateWithoutToChangeoversInput>
  }

  export type ScheduleBlockUpdateWithoutToChangeoversInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromChangeovers?: ChangeoverUpdateManyWithoutFromBlockNestedInput
    order?: OrderUpdateOneWithoutScheduleBlocksNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutScheduleBlocksNestedInput
  }

  export type ScheduleBlockUncheckedUpdateWithoutToChangeoversInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromChangeovers?: ChangeoverUncheckedUpdateManyWithoutFromBlockNestedInput
  }

  export type ScheduleBlockUpsertWithoutFromChangeoversInput = {
    update: XOR<ScheduleBlockUpdateWithoutFromChangeoversInput, ScheduleBlockUncheckedUpdateWithoutFromChangeoversInput>
    create: XOR<ScheduleBlockCreateWithoutFromChangeoversInput, ScheduleBlockUncheckedCreateWithoutFromChangeoversInput>
    where?: ScheduleBlockWhereInput
  }

  export type ScheduleBlockUpdateToOneWithWhereWithoutFromChangeoversInput = {
    where?: ScheduleBlockWhereInput
    data: XOR<ScheduleBlockUpdateWithoutFromChangeoversInput, ScheduleBlockUncheckedUpdateWithoutFromChangeoversInput>
  }

  export type ScheduleBlockUpdateWithoutFromChangeoversInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUpdateManyWithoutToBlockNestedInput
    order?: OrderUpdateOneWithoutScheduleBlocksNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutScheduleBlocksNestedInput
  }

  export type ScheduleBlockUncheckedUpdateWithoutFromChangeoversInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUncheckedUpdateManyWithoutToBlockNestedInput
  }

  export type WorkcenterUpsertWithoutChangeoversInput = {
    update: XOR<WorkcenterUpdateWithoutChangeoversInput, WorkcenterUncheckedUpdateWithoutChangeoversInput>
    create: XOR<WorkcenterCreateWithoutChangeoversInput, WorkcenterUncheckedCreateWithoutChangeoversInput>
    where?: WorkcenterWhereInput
  }

  export type WorkcenterUpdateToOneWithWhereWithoutChangeoversInput = {
    where?: WorkcenterWhereInput
    data: XOR<WorkcenterUpdateWithoutChangeoversInput, WorkcenterUncheckedUpdateWithoutChangeoversInput>
  }

  export type WorkcenterUpdateWithoutChangeoversInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutChangeoversInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type DepartmentCreateWithoutOperatorsInput = {
    name: string
    plant: PlantCreateNestedOneWithoutDepartmentsInput
    workcenters?: WorkcenterCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutOperatorsInput = {
    id?: number
    plantId: number
    name: string
    workcenters?: WorkcenterUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutOperatorsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutOperatorsInput, DepartmentUncheckedCreateWithoutOperatorsInput>
  }

  export type OperatorCompetencyCreateWithoutOperatorInput = {
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutCompetenciesInput
  }

  export type OperatorCompetencyUncheckedCreateWithoutOperatorInput = {
    id?: number
    skillId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorCompetencyCreateOrConnectWithoutOperatorInput = {
    where: OperatorCompetencyWhereUniqueInput
    create: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput>
  }

  export type OperatorCompetencyCreateManyOperatorInputEnvelope = {
    data: OperatorCompetencyCreateManyOperatorInput | OperatorCompetencyCreateManyOperatorInput[]
  }

  export type ShiftAssignmentCreateWithoutOperatorInput = {
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shiftPattern: ShiftPatternCreateNestedOneWithoutShiftAssignmentsInput
    workcenter: WorkcenterCreateNestedOneWithoutShiftAssignmentsInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutOperatorInput = {
    id?: number
    workcenterId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutOperatorInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput>
  }

  export type ShiftAssignmentCreateManyOperatorInputEnvelope = {
    data: ShiftAssignmentCreateManyOperatorInput | ShiftAssignmentCreateManyOperatorInput[]
  }

  export type DepartmentUpsertWithoutOperatorsInput = {
    update: XOR<DepartmentUpdateWithoutOperatorsInput, DepartmentUncheckedUpdateWithoutOperatorsInput>
    create: XOR<DepartmentCreateWithoutOperatorsInput, DepartmentUncheckedCreateWithoutOperatorsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutOperatorsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutOperatorsInput, DepartmentUncheckedUpdateWithoutOperatorsInput>
  }

  export type DepartmentUpdateWithoutOperatorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    plant?: PlantUpdateOneRequiredWithoutDepartmentsNestedInput
    workcenters?: WorkcenterUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutOperatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    workcenters?: WorkcenterUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type OperatorCompetencyUpsertWithWhereUniqueWithoutOperatorInput = {
    where: OperatorCompetencyWhereUniqueInput
    update: XOR<OperatorCompetencyUpdateWithoutOperatorInput, OperatorCompetencyUncheckedUpdateWithoutOperatorInput>
    create: XOR<OperatorCompetencyCreateWithoutOperatorInput, OperatorCompetencyUncheckedCreateWithoutOperatorInput>
  }

  export type OperatorCompetencyUpdateWithWhereUniqueWithoutOperatorInput = {
    where: OperatorCompetencyWhereUniqueInput
    data: XOR<OperatorCompetencyUpdateWithoutOperatorInput, OperatorCompetencyUncheckedUpdateWithoutOperatorInput>
  }

  export type OperatorCompetencyUpdateManyWithWhereWithoutOperatorInput = {
    where: OperatorCompetencyScalarWhereInput
    data: XOR<OperatorCompetencyUpdateManyMutationInput, OperatorCompetencyUncheckedUpdateManyWithoutOperatorInput>
  }

  export type OperatorCompetencyScalarWhereInput = {
    AND?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
    OR?: OperatorCompetencyScalarWhereInput[]
    NOT?: OperatorCompetencyScalarWhereInput | OperatorCompetencyScalarWhereInput[]
    id?: IntFilter<"OperatorCompetency"> | number
    operatorId?: IntFilter<"OperatorCompetency"> | number
    skillId?: IntFilter<"OperatorCompetency"> | number
    level?: IntFilter<"OperatorCompetency"> | number
    certifiedAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"OperatorCompetency"> | Date | string | null
    certifiedBy?: StringNullableFilter<"OperatorCompetency"> | string | null
    notes?: StringNullableFilter<"OperatorCompetency"> | string | null
    isActive?: BoolFilter<"OperatorCompetency"> | boolean
    createdAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
    updatedAt?: DateTimeFilter<"OperatorCompetency"> | Date | string
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutOperatorInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutOperatorInput, ShiftAssignmentUncheckedUpdateWithoutOperatorInput>
    create: XOR<ShiftAssignmentCreateWithoutOperatorInput, ShiftAssignmentUncheckedCreateWithoutOperatorInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutOperatorInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutOperatorInput, ShiftAssignmentUncheckedUpdateWithoutOperatorInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutOperatorInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutOperatorInput>
  }

  export type OperatorCompetencyCreateWithoutSkillInput = {
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    operator: OperatorCreateNestedOneWithoutCompetenciesInput
  }

  export type OperatorCompetencyUncheckedCreateWithoutSkillInput = {
    id?: number
    operatorId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorCompetencyCreateOrConnectWithoutSkillInput = {
    where: OperatorCompetencyWhereUniqueInput
    create: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput>
  }

  export type OperatorCompetencyCreateManySkillInputEnvelope = {
    data: OperatorCompetencyCreateManySkillInput | OperatorCompetencyCreateManySkillInput[]
  }

  export type SkillRequirementCreateWithoutSkillInput = {
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
    workcenter: WorkcenterCreateNestedOneWithoutSkillRequirementsInput
  }

  export type SkillRequirementUncheckedCreateWithoutSkillInput = {
    id?: number
    workcenterId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type SkillRequirementCreateOrConnectWithoutSkillInput = {
    where: SkillRequirementWhereUniqueInput
    create: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput>
  }

  export type SkillRequirementCreateManySkillInputEnvelope = {
    data: SkillRequirementCreateManySkillInput | SkillRequirementCreateManySkillInput[]
  }

  export type OperatorCompetencyUpsertWithWhereUniqueWithoutSkillInput = {
    where: OperatorCompetencyWhereUniqueInput
    update: XOR<OperatorCompetencyUpdateWithoutSkillInput, OperatorCompetencyUncheckedUpdateWithoutSkillInput>
    create: XOR<OperatorCompetencyCreateWithoutSkillInput, OperatorCompetencyUncheckedCreateWithoutSkillInput>
  }

  export type OperatorCompetencyUpdateWithWhereUniqueWithoutSkillInput = {
    where: OperatorCompetencyWhereUniqueInput
    data: XOR<OperatorCompetencyUpdateWithoutSkillInput, OperatorCompetencyUncheckedUpdateWithoutSkillInput>
  }

  export type OperatorCompetencyUpdateManyWithWhereWithoutSkillInput = {
    where: OperatorCompetencyScalarWhereInput
    data: XOR<OperatorCompetencyUpdateManyMutationInput, OperatorCompetencyUncheckedUpdateManyWithoutSkillInput>
  }

  export type SkillRequirementUpsertWithWhereUniqueWithoutSkillInput = {
    where: SkillRequirementWhereUniqueInput
    update: XOR<SkillRequirementUpdateWithoutSkillInput, SkillRequirementUncheckedUpdateWithoutSkillInput>
    create: XOR<SkillRequirementCreateWithoutSkillInput, SkillRequirementUncheckedCreateWithoutSkillInput>
  }

  export type SkillRequirementUpdateWithWhereUniqueWithoutSkillInput = {
    where: SkillRequirementWhereUniqueInput
    data: XOR<SkillRequirementUpdateWithoutSkillInput, SkillRequirementUncheckedUpdateWithoutSkillInput>
  }

  export type SkillRequirementUpdateManyWithWhereWithoutSkillInput = {
    where: SkillRequirementScalarWhereInput
    data: XOR<SkillRequirementUpdateManyMutationInput, SkillRequirementUncheckedUpdateManyWithoutSkillInput>
  }

  export type SkillCreateWithoutCompetenciesInput = {
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    skillRequirements?: SkillRequirementCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCompetenciesInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCompetenciesInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCompetenciesInput, SkillUncheckedCreateWithoutCompetenciesInput>
  }

  export type OperatorCreateWithoutCompetenciesInput = {
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutOperatorsInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutCompetenciesInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    departmentId?: number | null
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutCompetenciesInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutCompetenciesInput, OperatorUncheckedCreateWithoutCompetenciesInput>
  }

  export type SkillUpsertWithoutCompetenciesInput = {
    update: XOR<SkillUpdateWithoutCompetenciesInput, SkillUncheckedUpdateWithoutCompetenciesInput>
    create: XOR<SkillCreateWithoutCompetenciesInput, SkillUncheckedCreateWithoutCompetenciesInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCompetenciesInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCompetenciesInput, SkillUncheckedUpdateWithoutCompetenciesInput>
  }

  export type SkillUpdateWithoutCompetenciesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillRequirements?: SkillRequirementUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCompetenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type OperatorUpsertWithoutCompetenciesInput = {
    update: XOR<OperatorUpdateWithoutCompetenciesInput, OperatorUncheckedUpdateWithoutCompetenciesInput>
    create: XOR<OperatorCreateWithoutCompetenciesInput, OperatorUncheckedCreateWithoutCompetenciesInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutCompetenciesInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutCompetenciesInput, OperatorUncheckedUpdateWithoutCompetenciesInput>
  }

  export type OperatorUpdateWithoutCompetenciesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutOperatorsNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutCompetenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type SkillCreateWithoutSkillRequirementsInput = {
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    competencies?: OperatorCompetencyCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutSkillRequirementsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    category: string
    isCore?: boolean
    isCertification?: boolean
    expiryMonths?: number | null
    createdAt?: Date | string
    competencies?: OperatorCompetencyUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutSkillRequirementsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutSkillRequirementsInput, SkillUncheckedCreateWithoutSkillRequirementsInput>
  }

  export type WorkcenterCreateWithoutSkillRequirementsInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutSkillRequirementsInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    shiftAssignments?: ShiftAssignmentUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutSkillRequirementsInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutSkillRequirementsInput, WorkcenterUncheckedCreateWithoutSkillRequirementsInput>
  }

  export type SkillUpsertWithoutSkillRequirementsInput = {
    update: XOR<SkillUpdateWithoutSkillRequirementsInput, SkillUncheckedUpdateWithoutSkillRequirementsInput>
    create: XOR<SkillCreateWithoutSkillRequirementsInput, SkillUncheckedCreateWithoutSkillRequirementsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutSkillRequirementsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutSkillRequirementsInput, SkillUncheckedUpdateWithoutSkillRequirementsInput>
  }

  export type SkillUpdateWithoutSkillRequirementsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutSkillRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    isCertification?: BoolFieldUpdateOperationsInput | boolean
    expiryMonths?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type WorkcenterUpsertWithoutSkillRequirementsInput = {
    update: XOR<WorkcenterUpdateWithoutSkillRequirementsInput, WorkcenterUncheckedUpdateWithoutSkillRequirementsInput>
    create: XOR<WorkcenterCreateWithoutSkillRequirementsInput, WorkcenterUncheckedCreateWithoutSkillRequirementsInput>
    where?: WorkcenterWhereInput
  }

  export type WorkcenterUpdateToOneWithWhereWithoutSkillRequirementsInput = {
    where?: WorkcenterWhereInput
    data: XOR<WorkcenterUpdateWithoutSkillRequirementsInput, WorkcenterUncheckedUpdateWithoutSkillRequirementsInput>
  }

  export type WorkcenterUpdateWithoutSkillRequirementsInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutSkillRequirementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type ShiftAssignmentCreateWithoutShiftPatternInput = {
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workcenter: WorkcenterCreateNestedOneWithoutShiftAssignmentsInput
    operator: OperatorCreateNestedOneWithoutShiftAssignmentsInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutShiftPatternInput = {
    id?: number
    operatorId: number
    workcenterId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutShiftPatternInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput>
  }

  export type ShiftAssignmentCreateManyShiftPatternInputEnvelope = {
    data: ShiftAssignmentCreateManyShiftPatternInput | ShiftAssignmentCreateManyShiftPatternInput[]
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutShiftPatternInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutShiftPatternInput, ShiftAssignmentUncheckedUpdateWithoutShiftPatternInput>
    create: XOR<ShiftAssignmentCreateWithoutShiftPatternInput, ShiftAssignmentUncheckedCreateWithoutShiftPatternInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutShiftPatternInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutShiftPatternInput, ShiftAssignmentUncheckedUpdateWithoutShiftPatternInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutShiftPatternInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutShiftPatternInput>
  }

  export type ShiftPatternCreateWithoutShiftAssignmentsInput = {
    name: string
    description?: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ShiftPatternUncheckedCreateWithoutShiftAssignmentsInput = {
    id?: number
    name: string
    description?: string | null
    startTime: string
    endTime: string
    hoursPerShift: number
    daysPattern: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ShiftPatternCreateOrConnectWithoutShiftAssignmentsInput = {
    where: ShiftPatternWhereUniqueInput
    create: XOR<ShiftPatternCreateWithoutShiftAssignmentsInput, ShiftPatternUncheckedCreateWithoutShiftAssignmentsInput>
  }

  export type WorkcenterCreateWithoutShiftAssignmentsInput = {
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverCreateNestedManyWithoutWorkcenterInput
    orders?: OrderCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementCreateNestedManyWithoutWorkcenterInput
    department: DepartmentCreateNestedOneWithoutWorkcentersInput
    plant: PlantCreateNestedOneWithoutWorkcentersInput
  }

  export type WorkcenterUncheckedCreateWithoutShiftAssignmentsInput = {
    id?: number
    plantId: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
    changeovers?: ChangeoverUncheckedCreateNestedManyWithoutWorkcenterInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlannedWorkcenterInput
    scheduleBlocks?: ScheduleBlockUncheckedCreateNestedManyWithoutWorkcenterInput
    skillRequirements?: SkillRequirementUncheckedCreateNestedManyWithoutWorkcenterInput
  }

  export type WorkcenterCreateOrConnectWithoutShiftAssignmentsInput = {
    where: WorkcenterWhereUniqueInput
    create: XOR<WorkcenterCreateWithoutShiftAssignmentsInput, WorkcenterUncheckedCreateWithoutShiftAssignmentsInput>
  }

  export type OperatorCreateWithoutShiftAssignmentsInput = {
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutOperatorsInput
    competencies?: OperatorCompetencyCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutShiftAssignmentsInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    departmentId?: number | null
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    competencies?: OperatorCompetencyUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutShiftAssignmentsInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutShiftAssignmentsInput, OperatorUncheckedCreateWithoutShiftAssignmentsInput>
  }

  export type ShiftPatternUpsertWithoutShiftAssignmentsInput = {
    update: XOR<ShiftPatternUpdateWithoutShiftAssignmentsInput, ShiftPatternUncheckedUpdateWithoutShiftAssignmentsInput>
    create: XOR<ShiftPatternCreateWithoutShiftAssignmentsInput, ShiftPatternUncheckedCreateWithoutShiftAssignmentsInput>
    where?: ShiftPatternWhereInput
  }

  export type ShiftPatternUpdateToOneWithWhereWithoutShiftAssignmentsInput = {
    where?: ShiftPatternWhereInput
    data: XOR<ShiftPatternUpdateWithoutShiftAssignmentsInput, ShiftPatternUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type ShiftPatternUpdateWithoutShiftAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftPatternUncheckedUpdateWithoutShiftAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    hoursPerShift?: FloatFieldUpdateOperationsInput | number
    daysPattern?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkcenterUpsertWithoutShiftAssignmentsInput = {
    update: XOR<WorkcenterUpdateWithoutShiftAssignmentsInput, WorkcenterUncheckedUpdateWithoutShiftAssignmentsInput>
    create: XOR<WorkcenterCreateWithoutShiftAssignmentsInput, WorkcenterUncheckedCreateWithoutShiftAssignmentsInput>
    where?: WorkcenterWhereInput
  }

  export type WorkcenterUpdateToOneWithWhereWithoutShiftAssignmentsInput = {
    where?: WorkcenterWhereInput
    data: XOR<WorkcenterUpdateWithoutShiftAssignmentsInput, WorkcenterUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type WorkcenterUpdateWithoutShiftAssignmentsInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutShiftAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type OperatorUpsertWithoutShiftAssignmentsInput = {
    update: XOR<OperatorUpdateWithoutShiftAssignmentsInput, OperatorUncheckedUpdateWithoutShiftAssignmentsInput>
    create: XOR<OperatorCreateWithoutShiftAssignmentsInput, OperatorUncheckedCreateWithoutShiftAssignmentsInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutShiftAssignmentsInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutShiftAssignmentsInput, OperatorUncheckedUpdateWithoutShiftAssignmentsInput>
  }

  export type OperatorUpdateWithoutShiftAssignmentsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutOperatorsNestedInput
    competencies?: OperatorCompetencyUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutShiftAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type DepartmentCreateManyPlantInput = {
    id?: number
    name: string
  }

  export type HolidayCreateManyPlantInput = {
    id?: number
    date: Date | string
    label?: string | null
  }

  export type WorkcenterCreateManyPlantInput = {
    id?: number
    departmentId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
  }

  export type DepartmentUpdateWithoutPlantInput = {
    name?: StringFieldUpdateOperationsInput | string
    operators?: OperatorUpdateManyWithoutDepartmentNestedInput
    workcenters?: WorkcenterUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    operators?: OperatorUncheckedUpdateManyWithoutDepartmentNestedInput
    workcenters?: WorkcenterUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HolidayUpdateWithoutPlantInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkcenterUpdateWithoutPlantInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    department?: DepartmentUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type WorkcenterUncheckedUpdateManyWithoutPlantInput = {
    id?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperatorCreateManyDepartmentInput = {
    id?: number
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    hireDate: Date | string
    isActive?: boolean
    basePayRate?: number | null
    emergencyContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkcenterCreateManyDepartmentInput = {
    id?: number
    plantId: number
    workcenterNo: string
    name: string
    displayTitle?: string | null
    defaultSchemeId?: number | null
    minStaff?: number
    gatingRules?: string | null
    changeoverFamily?: string | null
  }

  export type OperatorUpdateWithoutDepartmentInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUpdateManyWithoutOperatorNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    competencies?: OperatorCompetencyUncheckedUpdateManyWithoutOperatorNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    basePayRate?: NullableFloatFieldUpdateOperationsInput | number | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkcenterUpdateWithoutDepartmentInput = {
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUpdateManyWithoutWorkcenterNestedInput
    plant?: PlantUpdateOneRequiredWithoutWorkcentersNestedInput
  }

  export type WorkcenterUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
    changeovers?: ChangeoverUncheckedUpdateManyWithoutWorkcenterNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlannedWorkcenterNestedInput
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutWorkcenterNestedInput
    shiftAssignments?: ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterNestedInput
    skillRequirements?: SkillRequirementUncheckedUpdateManyWithoutWorkcenterNestedInput
  }

  export type WorkcenterUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: IntFieldUpdateOperationsInput | number
    workcenterNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayTitle?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSchemeId?: NullableIntFieldUpdateOperationsInput | number | null
    minStaff?: IntFieldUpdateOperationsInput | number
    gatingRules?: NullableStringFieldUpdateOperationsInput | string | null
    changeoverFamily?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverCreateManyWorkcenterInput = {
    id?: number
    fromBlockId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type OrderCreateManyPlannedWorkcenterInput = {
    id?: number
    orderNo: string
    skuId: number
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    shopfloorTitle?: string | null
    colorHex?: string | null
  }

  export type ScheduleBlockCreateManyWorkcenterInput = {
    id?: number
    orderId?: number | null
    startAt: Date | string
    endAt: Date | string
  }

  export type ShiftAssignmentCreateManyWorkcenterInput = {
    id?: number
    operatorId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillRequirementCreateManyWorkcenterInput = {
    id?: number
    skillId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type ChangeoverUpdateWithoutWorkcenterInput = {
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
    toBlock?: ScheduleBlockUpdateOneRequiredWithoutToChangeoversNestedInput
    fromBlock?: ScheduleBlockUpdateOneRequiredWithoutFromChangeoversNestedInput
  }

  export type ChangeoverUncheckedUpdateWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverUncheckedUpdateManyWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutPlannedWorkcenterInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: SKUUpdateOneRequiredWithoutOrdersNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPlannedWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPlannedWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    skuId?: IntFieldUpdateOperationsInput | number
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleBlockUpdateWithoutWorkcenterInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUpdateManyWithoutFromBlockNestedInput
    order?: OrderUpdateOneWithoutScheduleBlocksNestedInput
  }

  export type ScheduleBlockUncheckedUpdateWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUncheckedUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUncheckedUpdateManyWithoutFromBlockNestedInput
  }

  export type ScheduleBlockUncheckedUpdateManyWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUpdateWithoutWorkcenterInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftPattern?: ShiftPatternUpdateOneRequiredWithoutShiftAssignmentsNestedInput
    operator?: OperatorUpdateOneRequiredWithoutShiftAssignmentsNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementUpdateWithoutWorkcenterInput = {
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutSkillRequirementsNestedInput
  }

  export type SkillRequirementUncheckedUpdateWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementUncheckedUpdateManyWithoutWorkcenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManySkuInput = {
    id?: number
    orderNo: string
    qty: number
    runRateUph: number
    performanceLeverPct?: number
    priority?: number
    dueAt: Date | string
    workcenterId?: number | null
    shopfloorTitle?: string | null
    colorHex?: string | null
  }

  export type ProductCreateManySkuInput = {
    id?: number
    name: string
  }

  export type OrderUpdateWithoutSkuInput = {
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    plannedWorkcenter?: WorkcenterUpdateOneWithoutOrdersNestedInput
    scheduleBlocks?: ScheduleBlockUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSkuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenterId?: NullableIntFieldUpdateOperationsInput | number | null
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleBlocks?: ScheduleBlockUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSkuInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    runRateUph?: IntFieldUpdateOperationsInput | number
    performanceLeverPct?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenterId?: NullableIntFieldUpdateOperationsInput | number | null
    shopfloorTitle?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutSkuInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateWithoutSkuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyWithoutSkuInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleBlockCreateManyOrderInput = {
    id?: number
    workcenterId: number
    startAt: Date | string
    endAt: Date | string
  }

  export type ScheduleBlockUpdateWithoutOrderInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUpdateManyWithoutFromBlockNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutScheduleBlocksNestedInput
  }

  export type ScheduleBlockUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toChangeovers?: ChangeoverUncheckedUpdateManyWithoutToBlockNestedInput
    fromChangeovers?: ChangeoverUncheckedUpdateManyWithoutFromBlockNestedInput
  }

  export type ScheduleBlockUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeoverCreateManyToBlockInput = {
    id?: number
    workcenterId: number
    fromBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverCreateManyFromBlockInput = {
    id?: number
    workcenterId: number
    toBlockId: number
    typeCode: string
    plannedMinutes: number
    includeInOee?: boolean
    complexityTier?: string | null
  }

  export type ChangeoverUpdateWithoutToBlockInput = {
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
    fromBlock?: ScheduleBlockUpdateOneRequiredWithoutFromChangeoversNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutChangeoversNestedInput
  }

  export type ChangeoverUncheckedUpdateWithoutToBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverUncheckedUpdateManyWithoutToBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    fromBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverUpdateWithoutFromBlockInput = {
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
    toBlock?: ScheduleBlockUpdateOneRequiredWithoutToChangeoversNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutChangeoversNestedInput
  }

  export type ChangeoverUncheckedUpdateWithoutFromBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeoverUncheckedUpdateManyWithoutFromBlockInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    toBlockId?: IntFieldUpdateOperationsInput | number
    typeCode?: StringFieldUpdateOperationsInput | string
    plannedMinutes?: IntFieldUpdateOperationsInput | number
    includeInOee?: BoolFieldUpdateOperationsInput | boolean
    complexityTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OperatorCompetencyCreateManyOperatorInput = {
    id?: number
    skillId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateManyOperatorInput = {
    id?: number
    workcenterId: number
    shiftPatternId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorCompetencyUpdateWithoutOperatorInput = {
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCompetenciesNestedInput
  }

  export type OperatorCompetencyUncheckedUpdateWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyUncheckedUpdateManyWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    skillId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUpdateWithoutOperatorInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shiftPattern?: ShiftPatternUpdateOneRequiredWithoutShiftAssignmentsNestedInput
    workcenter?: WorkcenterUpdateOneRequiredWithoutShiftAssignmentsNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutOperatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    shiftPatternId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyCreateManySkillInput = {
    id?: number
    operatorId: number
    level: number
    certifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    certifiedBy?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkillRequirementCreateManySkillInput = {
    id?: number
    workcenterId: number
    minLevel: number
    isRequired?: boolean
    shiftType?: string | null
    createdAt?: Date | string
  }

  export type OperatorCompetencyUpdateWithoutSkillInput = {
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: OperatorUpdateOneRequiredWithoutCompetenciesNestedInput
  }

  export type OperatorCompetencyUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCompetencyUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    certifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementUpdateWithoutSkillInput = {
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenter?: WorkcenterUpdateOneRequiredWithoutSkillRequirementsNestedInput
  }

  export type SkillRequirementUncheckedUpdateWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillRequirementUncheckedUpdateManyWithoutSkillInput = {
    id?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    minLevel?: IntFieldUpdateOperationsInput | number
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentCreateManyShiftPatternInput = {
    id?: number
    operatorId: number
    workcenterId: number
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    role?: string
    payRate?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentUpdateWithoutShiftPatternInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workcenter?: WorkcenterUpdateOneRequiredWithoutShiftAssignmentsNestedInput
    operator?: OperatorUpdateOneRequiredWithoutShiftAssignmentsNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutShiftPatternInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutShiftPatternInput = {
    id?: IntFieldUpdateOperationsInput | number
    operatorId?: IntFieldUpdateOperationsInput | number
    workcenterId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    payRate?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PlantCountOutputTypeDefaultArgs instead
     */
    export type PlantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkcenterCountOutputTypeDefaultArgs instead
     */
    export type WorkcenterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkcenterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SKUCountOutputTypeDefaultArgs instead
     */
    export type SKUCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SKUCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleBlockCountOutputTypeDefaultArgs instead
     */
    export type ScheduleBlockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleBlockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorCountOutputTypeDefaultArgs instead
     */
    export type OperatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftPatternCountOutputTypeDefaultArgs instead
     */
    export type ShiftPatternCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftPatternCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlantDefaultArgs instead
     */
    export type PlantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkcenterDefaultArgs instead
     */
    export type WorkcenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkcenterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HolidayDefaultArgs instead
     */
    export type HolidayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HolidayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SKUDefaultArgs instead
     */
    export type SKUArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SKUDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleBlockDefaultArgs instead
     */
    export type ScheduleBlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleBlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChangeoverDefaultArgs instead
     */
    export type ChangeoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChangeoverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorDefaultArgs instead
     */
    export type OperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperatorCompetencyDefaultArgs instead
     */
    export type OperatorCompetencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperatorCompetencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillRequirementDefaultArgs instead
     */
    export type SkillRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillRequirementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftPatternDefaultArgs instead
     */
    export type ShiftPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftAssignmentDefaultArgs instead
     */
    export type ShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftAssignmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}